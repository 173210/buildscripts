diff -Nbaur gcc-3.4.3/config.sub gcc-3.4.3-new/config.sub
--- gcc-3.4.3/config.sub	Sun Feb 22 14:44:23 2004
+++ gcc-3.4.3-new/config.sub	Fri Jan 21 10:25:50 2005
@@ -219,6 +219,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	-gekko)
+		basic_machine=powerpc-eabi
+		os=-elf
+		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
diff -Nbaur gcc-3.4.3/gcc/Makefile.in gcc-3.4.3-new/gcc/Makefile.in
--- gcc-3.4.3/gcc/Makefile.in	Mon Oct 18 17:00:39 2004
+++ gcc-3.4.3-new/gcc/Makefile.in	Fri Jan 21 10:25:50 2005
@@ -138,7 +138,7 @@
 # TCFLAGS is used for compilations with the GCC just built.
 XCFLAGS =
 TCFLAGS =
-CFLAGS = -g
+CFLAGS = -g0
 STAGE1_CFLAGS = -g @stage1_cflags@
 BOOT_CFLAGS = -g -O2
 
@@ -441,6 +441,7 @@
 gcc_gxx_include_dir = @gcc_gxx_include_dir@
 # Directory to search for site-specific includes.
 local_includedir = $(local_prefix)/include
+# local_includedir=$(libsubdir)/$(unlibsubdir)/..`echo $(exec_prefix) | sed -e 's|^$(prefix)||' -e 's|/[^/]*|/..|g'`/include
 includedir = $(prefix)/include
 # where the info files go
 infodir = @infodir@
diff -Nbaur gcc-3.4.3/gcc/c-format.c gcc-3.4.3-new/gcc/c-format.c
--- gcc-3.4.3/gcc/c-format.c	Sat Dec 20 00:00:27 2003
+++ gcc-3.4.3-new/gcc/c-format.c	Fri Jan 21 10:25:50 2005
@@ -31,6 +31,7 @@
 #include "diagnostic.h"
 #include "langhooks.h"
 
+
 /* Set format warning options according to a -Wformat=n option.  */
 
 void
@@ -509,6 +510,9 @@
   { "h", FMT_LEN_h, STD_C89, "hh", FMT_LEN_hh, STD_C99 },
   { "l", FMT_LEN_l, STD_C89, "ll", FMT_LEN_ll, STD_C9L },
   { "q", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },
+#ifdef __MINGW32__
+  { "I64", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },
+#endif
   { "L", FMT_LEN_L, STD_C89, NULL, 0, 0 },
   { "z", FMT_LEN_z, STD_C99, NULL, 0, 0 },
   { "Z", FMT_LEN_z, STD_EXT, NULL, 0, 0 },
@@ -543,6 +547,9 @@
   { "h", FMT_LEN_h, STD_C89, "hh", FMT_LEN_hh, STD_C99 },
   { "l", FMT_LEN_l, STD_C89, "ll", FMT_LEN_ll, STD_C9L },
   { "q", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },
+#ifdef __MINGW32__
+  { "I64", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },
+#endif
   { "L", FMT_LEN_L, STD_C89, NULL, 0, 0 },
   { "z", FMT_LEN_z, STD_C99, NULL, 0, 0 },
   { "t", FMT_LEN_t, STD_C99, NULL, 0, 0 },
@@ -568,7 +575,9 @@
   { '0',  0, 0, N_("`0' flag"),        N_("the `0' printf flag"),              STD_C89 },
   { '-',  0, 0, N_("`-' flag"),        N_("the `-' printf flag"),              STD_C89 },
   { '\'', 0, 0, N_("`'' flag"),        N_("the `'' printf flag"),              STD_EXT },
+#ifndef __MINGW32__
   { 'I',  0, 0, N_("`I' flag"),        N_("the `I' printf flag"),              STD_EXT },
+#endif
   { 'w',  0, 0, N_("field width"),     N_("field width in printf format"),     STD_C89 },
   { 'p',  0, 0, N_("precision"),       N_("precision in printf format"),       STD_C89 },
   { 'L',  0, 0, N_("length modifier"), N_("length modifier in printf format"), STD_C89 },
@@ -638,7 +647,9 @@
   { 'w',  0, 0, N_("field width"),            N_("field width in scanf format"),              STD_C89 },
   { 'L',  0, 0, N_("length modifier"),        N_("length modifier in scanf format"),          STD_C89 },
   { '\'', 0, 0, N_("`'' flag"),               N_("the `'' scanf flag"),                       STD_EXT },
+#ifndef __MINGW32__
   { 'I',  0, 0, N_("`I' flag"),               N_("the `I' scanf flag"),                       STD_EXT },
+#endif
   { 0, 0, 0, NULL, NULL, 0 }
 };
 
@@ -917,11 +928,18 @@
   { NULL, 0, 0, NOLENGTHS, NULL, NULL }
 };
 
+#ifdef __MINGW32__
+#define PRINTF_FLAG_CHARS " +#0-'"
+#define SCANF_FLAG_CHARS "*'"
+#else
+#define PRINTF_FLAG_CHARS " +#0-'I"
+#define SCANF_FLAG_CHARS "*'I"
+#endif
 
 /* This must be in the same order as enum format_type.  */
 static const format_kind_info format_types_orig[] =
 {
-  { "printf",   printf_length_specs,  print_char_table, " +#0-'I", NULL, 
+  { "printf",   printf_length_specs,  print_char_table, PRINTF_FLAG_CHARS, NULL, 
     printf_flag_specs, printf_flag_pairs,
     FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,
     'w', 0, 'p', 0, 'L',
@@ -951,7 +969,7 @@
     0, 0, 'p', 0, 'L',
     NULL, &integer_type_node
   },
-  { "scanf",    scanf_length_specs,   scan_char_table,  "*'I", NULL, 
+  { "scanf",    scanf_length_specs,   scan_char_table,  SCANF_FLAG_CHARS, NULL, 
     scanf_flag_specs, scanf_flag_pairs,
     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,
     'w', 0, 0, '*', 'L',
@@ -1929,7 +1947,13 @@
 	{
 	  while (fli->name != 0 && fli->name[0] != *format_chars)
 	    fli++;
-	  if (fli->name != 0)
+	  if (fli->name != 0
+#ifdef __MINGW32__
+	      /* Only accept "I64", not 'I' by itself.  */	
+	      && (format_chars[0] != 'I'
+		  || (format_chars[1] == '6' &&  format_chars[2] == '4'))
+#endif
+	     ) 
 	    {
 	      format_chars++;
 	      if (fli->double_name != 0 && fli->name[0] == *format_chars)
@@ -1941,6 +1965,10 @@
 		}
 	      else
 		{
+#ifdef __MINGW32__
+	          if (fli->name[0] == 'I')
+		    format_chars += 2;
+#endif
 		  length_chars = fli->name;
 		  length_chars_val = fli->index;
 		  length_chars_std = fli->std;
diff -Nbaur gcc-3.4.3/gcc/collect2.c gcc-3.4.3-new/gcc/collect2.c
--- gcc-3.4.3/gcc/collect2.c	Tue Mar  9 15:49:56 2004
+++ gcc-3.4.3-new/gcc/collect2.c	Fri Jan 21 10:25:50 2005
@@ -30,24 +30,13 @@
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "pex-read.h"
+
 #include <signal.h>
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
 #endif
 
-#ifdef vfork /* Autoconf may define this to fork for us.  */
-# define VFORK_STRING "fork"
-#else
-# define VFORK_STRING "vfork"
-#endif
-#ifdef HAVE_VFORK_H
-#include <vfork.h>
-#endif
-#ifdef VMS
-#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
-               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
-#endif /* VMS */
-
 #ifndef LIBRARY_PATH_ENV
 #define LIBRARY_PATH_ENV "LIBRARY_PATH"
 #endif
@@ -67,7 +56,6 @@
    cross-versions are in the proper directories.  */
 
 #ifdef CROSS_COMPILE
-#undef SUNOS4_SHARED_LIBRARIES
 #undef OBJECT_FORMAT_COFF
 #undef MD_EXEC_PREFIX
 #undef REAL_LD_FILE_NAME
@@ -140,7 +128,7 @@
   fprintf ((STREAM), "void _GLOBAL__DD() {\n\t%s();\n}\n", (FUNC))
 #endif
 
-#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES
+#ifdef LDD_SUFFIX
 #define SCAN_LIBRARIES
 #endif
 
@@ -255,7 +243,9 @@
 static void add_prefix (struct path_prefix *, const char *);
 static void prefix_from_env (const char *, struct path_prefix *);
 static void prefix_from_string (const char *, struct path_prefix *);
+static int collect_status (const char *, int status);
 static void do_wait (const char *);
+static void do_read_wait (const char *, FILE *);
 static void fork_execute (const char *, char **);
 static void maybe_unlink (const char *);
 static void add_to_list (struct head *, const char *);
@@ -424,7 +414,11 @@
 #endif
 
   signal (signo, SIG_DFL);
+#if HAVE_KILL
   kill (getpid (), signo);
+#else
+  raise (signo);
+#endif
 }
 
 
@@ -1456,14 +1450,11 @@
 }
 
 
-/* Wait for a process to finish, and exit if a nonzero status is found.  */
+/* Handle error status returned by a finished process.  */
 
-int
-collect_wait (const char *prog)
+static int
+collect_status (const char *prog, int status)
 {
-  int status;
-
-  pwait (pid, &status, 0);
   if (status)
     {
       if (WIFSIGNALED (status))
@@ -1481,6 +1472,17 @@
   return 0;
 }
 
+/* Wait for a process to finish, and exit if a nonzero status is found.  */
+
+int
+collect_wait (const char *prog)
+{
+  int status;
+
+  pwait (pid, &status, 0);
+  return collect_status (prog, status);
+}
+
 static void
 do_wait (const char *prog)
 {
@@ -1492,6 +1494,19 @@
     }
 }
 
+static void
+do_read_wait (const char *prog, FILE *inf)
+{
+  int status;
+
+  pex_read_close (pid, inf, &status, 0);
+  status = collect_status (prog, status);
+  if (status != 0)
+    {
+      error ("%s returned %d exit status", prog, status);
+      collect_exit (status);
+    }
+}
 
 /* Execute a program, and wait for the reply.  */
 
@@ -1532,7 +1547,7 @@
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
@@ -1995,9 +2010,10 @@
   char *real_nm_argv[4];
   const char **nm_argv = (const char **) real_nm_argv;
   int argc = 0;
-  int pipe_fd[2];
   char *p, buf[1024];
   FILE *inf;
+  char *errmsg_fmt;
+  char *errmsg_arg;
 
   if (which_pass == PASS_SECOND)
     return;
@@ -2013,13 +2029,6 @@
   nm_argv[argc++] = prog_name;
   nm_argv[argc++] = (char *) 0;
 
-  if (pipe (pipe_fd) < 0)
-    fatal_perror ("pipe");
-
-  inf = fdopen (pipe_fd[0], "r");
-  if (inf == (FILE *) 0)
-    fatal_perror ("fdopen");
-
   /* Trace if needed.  */
   if (vflag)
     {
@@ -2035,36 +2044,16 @@
   fflush (stdout);
   fflush (stderr);
 
-  /* Spawn child nm on pipe.  */
-  pid = vfork ();
-  if (pid == -1)
-    fatal_perror (VFORK_STRING);
-
-  if (pid == 0)			/* child context */
-    {
-      /* setup stdout */
-      if (dup2 (pipe_fd[1], 1) < 0)
-	fatal_perror ("dup2 %d 1", pipe_fd[1]);
-
-      if (close (pipe_fd[0]) < 0)
-	fatal_perror ("close %d", pipe_fd[0]);
-
-      if (close (pipe_fd[1]) < 0)
-	fatal_perror ("close %d", pipe_fd[1]);
-
-      execv (nm_file_name, real_nm_argv);
-      fatal_perror ("execv %s", nm_file_name);
-    }
+  inf = pex_read (nm_file_name, real_nm_argv, nm_file_name, NULL,
+		  &errmsg_fmt, &errmsg_arg, 0, &pid);
+  if (inf == (FILE *) 0)
+    fatal_perror (errmsg_fmt, errmsg_arg);
 
-  /* Parent context from here on.  */
   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);
 #ifdef SIGQUIT
   quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);
 #endif
 
-  if (close (pipe_fd[1]) < 0)
-    fatal_perror ("close %d", pipe_fd[1]);
-
   if (debug)
     fprintf (stderr, "\nnm output with constructors/destructors.\n");
 
@@ -2137,10 +2126,7 @@
   if (debug)
     fprintf (stderr, "\n");
 
-  if (fclose (inf) != 0)
-    fatal_perror ("fclose");
-
-  do_wait (nm_file_name);
+  do_read_wait (nm_file_name, inf);
 
   signal (SIGINT,  int_handler);
 #ifdef SIGQUIT
@@ -2148,269 +2134,6 @@
 #endif
 }
 
-#if SUNOS4_SHARED_LIBRARIES
-
-/* Routines to scan the SunOS 4 _DYNAMIC structure to find shared libraries
-   that the output file depends upon and their initialization/finalization
-   routines, if any.  */
-
-#include <a.out.h>
-#include <fcntl.h>
-#include <link.h>
-#include <sys/mman.h>
-#include <sys/param.h>
-#include <unistd.h>
-#include <sys/dir.h>
-
-/* pointers to the object file */
-unsigned object;	/* address of memory mapped file */
-unsigned objsize;	/* size of memory mapped to file */
-char * code;		/* pointer to code segment */
-char * data;		/* pointer to data segment */
-struct nlist *symtab;	/* pointer to symbol table */
-struct link_dynamic *ld;
-struct link_dynamic_2 *ld_2;
-struct head libraries;
-
-/* Map the file indicated by NAME into memory and store its address.  */
-
-static void
-mapfile (const char *name)
-{
-  int fp;
-  struct stat s;
-  if ((fp = open (name, O_RDONLY)) == -1)
-    fatal ("unable to open file '%s'", name);
-  if (fstat (fp, &s) == -1)
-    fatal ("unable to stat file '%s'", name);
-
-  objsize = s.st_size;
-  object = (unsigned) mmap (0, objsize, PROT_READ|PROT_WRITE, MAP_PRIVATE,
-			    fp, 0);
-  if (object == (unsigned)-1)
-    fatal ("unable to mmap file '%s'", name);
-
-  close (fp);
-}
-
-/* Helpers for locatelib.  */
-
-static const char *libname;
-
-static int
-libselect (struct direct *d)
-{
-  return (strncmp (libname, d->d_name, strlen (libname)) == 0);
-}
-
-/* If one file has an additional numeric extension past LIBNAME, then put
-   that one first in the sort.  If both files have additional numeric
-   extensions, then put the one with the higher number first in the sort.
-
-   We must verify that the extension is numeric, because Sun saves the
-   original versions of patched libraries with a .FCS extension.  Files with
-   invalid extensions must go last in the sort, so that they will not be used.  */
-
-static int
-libcompare (struct direct **d1, struct direct **d2)
-{
-  int i1, i2 = strlen (libname);
-  char *e1 = (*d1)->d_name + i2;
-  char *e2 = (*d2)->d_name + i2;
-
-  while (*e1 && *e2 && *e1 == '.' && *e2 == '.'
-	 && e1[1] && ISDIGIT (e1[1]) && e2[1] && ISDIGIT (e2[1]))
-    {
-      ++e1;
-      ++e2;
-      i1 = strtol (e1, &e1, 10);
-      i2 = strtol (e2, &e2, 10);
-      if (i1 != i2)
-	return i1 - i2;
-    }
-
-  if (*e1)
-    {
-      /* It has a valid numeric extension, prefer this one.  */
-      if (*e1 == '.' && e1[1] && ISDIGIT (e1[1]))
-	return 1;
-      /* It has an invalid numeric extension, must prefer the other one.  */
-      else
-	return -1;
-    }
-  else if (*e2)
-    {
-      /* It has a valid numeric extension, prefer this one.  */
-      if (*e2 == '.' && e2[1] && ISDIGIT (e2[1]))
-	return -1;
-      /* It has an invalid numeric extension, must prefer the other one.  */
-      else
-	return 1;
-    }
-  else
-    return 0;
-}
-
-/* Given the name NAME of a dynamic dependency, find its pathname and add
-   it to the list of libraries.  */
-
-static void
-locatelib (const char *name)
-{
-  static const char **l;
-  static int cnt;
-  char buf[MAXPATHLEN];
-  char *p, *q;
-  const char **pp;
-
-  if (l == 0)
-    {
-      char *ld_rules;
-      char *ldr = 0;
-      /* counting elements in array, need 1 extra for null */
-      cnt = 1;
-      ld_rules = (char *) (ld_2->ld_rules + code);
-      if (ld_rules)
-	{
-	  cnt++;
-	  for (; *ld_rules != 0; ld_rules++)
-	    if (*ld_rules == ':')
-	      cnt++;
-	  ld_rules = (char *) (ld_2->ld_rules + code);
-	  ldr = xstrdup (ld_rules);
-	}
-      p = getenv ("LD_LIBRARY_PATH");
-      q = 0;
-      if (p)
-	{
-	  cnt++;
-	  for (q = p ; *q != 0; q++)
-	    if (*q == ':')
-	      cnt++;
-	  q = xstrdup (p);
-	}
-      l = xmalloc ((cnt + 3) * sizeof (char *));
-      pp = l;
-      if (ldr)
-	{
-	  *pp++ = ldr;
-	  for (; *ldr != 0; ldr++)
-	    if (*ldr == ':')
-	      {
-		*ldr++ = 0;
-		*pp++ = ldr;
-	      }
-	}
-      if (q)
-	{
-	  *pp++ = q;
-	  for (; *q != 0; q++)
-	    if (*q == ':')
-	      {
-		*q++ = 0;
-		*pp++ = q;
-	      }
-	}
-      /* built in directories are /lib, /usr/lib, and /usr/local/lib */
-      *pp++ = "/lib";
-      *pp++ = "/usr/lib";
-      *pp++ = "/usr/local/lib";
-      *pp = 0;
-    }
-  libname = name;
-  for (pp = l; *pp != 0 ; pp++)
-    {
-      struct direct **namelist;
-      int entries;
-      if ((entries = scandir (*pp, &namelist, libselect, libcompare)) > 0)
-	{
-	  sprintf (buf, "%s/%s", *pp, namelist[entries - 1]->d_name);
-	  add_to_list (&libraries, buf);
-	  if (debug)
-	    fprintf (stderr, "%s\n", buf);
-	  break;
-	}
-    }
-  if (*pp == 0)
-    {
-      if (debug)
-	notice ("not found\n");
-      else
-	fatal ("dynamic dependency %s not found", name);
-    }
-}
-
-/* Scan the _DYNAMIC structure of the output file to find shared libraries
-   that it depends upon and any constructors or destructors they contain.  */
-
-static void
-scan_libraries (const char *prog_name)
-{
-  struct exec *header;
-  char *base;
-  struct link_object *lo;
-  char buff[MAXPATHLEN];
-  struct id *list;
-
-  mapfile (prog_name);
-  header = (struct exec *)object;
-  if (N_BADMAG (*header))
-    fatal ("bad magic number in file '%s'", prog_name);
-  if (header->a_dynamic == 0)
-    return;
-
-  code = (char *) (N_TXTOFF (*header) + (long) header);
-  data = (char *) (N_DATOFF (*header) + (long) header);
-  symtab = (struct nlist *) (N_SYMOFF (*header) + (long) header);
-
-  if (header->a_magic == ZMAGIC && header->a_entry == 0x20)
-    {
-      /* shared object */
-      ld = (struct link_dynamic *) (symtab->n_value + code);
-      base = code;
-    }
-  else
-    {
-      /* executable */
-      ld = (struct link_dynamic *) data;
-      base = code-PAGSIZ;
-    }
-
-  if (debug)
-    notice ("dynamic dependencies.\n");
-
-  ld_2 = (struct link_dynamic_2 *) ((long) ld->ld_un.ld_2 + (long)base);
-  for (lo = (struct link_object *) ld_2->ld_need; lo;
-       lo = (struct link_object *) lo->lo_next)
-    {
-      char *name;
-      lo = (struct link_object *) ((long) lo + code);
-      name = (char *) (code + lo->lo_name);
-      if (lo->lo_library)
-	{
-	  if (debug)
-	    fprintf (stderr, "\t-l%s.%d => ", name, lo->lo_major);
-	  sprintf (buff, "lib%s.so.%d.%d", name, lo->lo_major, lo->lo_minor);
-	  locatelib (buff);
-	}
-      else
-	{
-	  if (debug)
-	    fprintf (stderr, "\t%s\n", name);
-	  add_to_list (&libraries, name);
-	}
-    }
-
-  if (debug)
-    fprintf (stderr, "\n");
-
-  /* Now iterate through the library list adding their symbols to
-     the list.  */
-  for (list = libraries.first; list; list = list->next)
-    scan_prog_file (list->name, PASS_LIB);
-}
-
-#else  /* SUNOS4_SHARED_LIBRARIES */
 #ifdef LDD_SUFFIX
 
 /* Use the List Dynamic Dependencies program to find shared libraries that
@@ -2427,9 +2150,10 @@
   char *real_ldd_argv[4];
   const char **ldd_argv = (const char **) real_ldd_argv;
   int argc = 0;
-  int pipe_fd[2];
   char buf[1024];
   FILE *inf;
+  char *errmsg_fmt;
+  char *errmsg_arg;
 
   /* If we do not have an `ldd', complain.  */
   if (ldd_file_name == 0)
@@ -2464,26 +2188,10 @@
   fflush (stdout);
   fflush (stderr);
 
-  /* Spawn child ldd on pipe.  */
-  pid = vfork ();
-  if (pid == -1)
-    fatal_perror (VFORK_STRING);
-
-  if (pid == 0)			/* child context */
-    {
-      /* setup stdout */
-      if (dup2 (pipe_fd[1], 1) < 0)
-	fatal_perror ("dup2 %d 1", pipe_fd[1]);
-
-      if (close (pipe_fd[0]) < 0)
-	fatal_perror ("close %d", pipe_fd[0]);
-
-      if (close (pipe_fd[1]) < 0)
-	fatal_perror ("close %d", pipe_fd[1]);
-
-      execv (ldd_file_name, real_ldd_argv);
-      fatal_perror ("execv %s", ldd_file_name);
-    }
+  inf = pex_read (ldd_file_name, real_ldd_argv, ldd_file_name, NULL,
+		  &errmsg_fmt, &errmsg_arg, 0, &pid);
+  if (inf == (FILE *) 0)
+    fatal_perror (errmsg_fmt, errmsg_arg);
 
   /* Parent context from here on.  */
   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);
@@ -2491,9 +2199,6 @@
   quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);
 #endif
 
-  if (close (pipe_fd[1]) < 0)
-    fatal_perror ("close %d", pipe_fd[1]);
-
   if (debug)
     notice ("\nldd output with constructors/destructors.\n");
 
@@ -2530,10 +2235,7 @@
   if (debug)
     fprintf (stderr, "\n");
 
-  if (fclose (inf) != 0)
-    fatal_perror ("fclose");
-
-  do_wait (ldd_file_name);
+  do_read_wait (ldd_file_name, inf);
 
   signal (SIGINT,  int_handler);
 #ifdef SIGQUIT
@@ -2547,7 +2249,6 @@
 }
 
 #endif /* LDD_SUFFIX */
-#endif /* SUNOS4_SHARED_LIBRARIES */
 
 #endif /* OBJECT_FORMAT_NONE */
 
diff -Nbaur gcc-3.4.3/gcc/config/arm/arm.md gcc-3.4.3-new/gcc/config/arm/arm.md
--- gcc-3.4.3/gcc/config/arm/arm.md	Wed Aug 25 16:46:19 2004
+++ gcc-3.4.3-new/gcc/config/arm/arm.md	Fri Jan 21 10:25:50 2005
@@ -7205,6 +7205,12 @@
   {
     if (TARGET_CALLER_INTERWORKING)
       return \"bl\\t%__interwork_call_via_%0\";
+    else if (arm_arch5)
+      return \"blx\\t%0\";
+    else if (TARGET_LONG_CALLS)
+      /* For long calls the __call_via functions might not be near
+         this branch, so we have to synthesise their actions.  */
+      return \"bl\\t0f\\n\\tb\\t1f\\n0:\\tbx\\t%0\\n1:\";
     else
       return \"bl\\t%__call_via_%0\";
   }"
@@ -7222,6 +7228,12 @@
   {
     if (TARGET_CALLER_INTERWORKING)
       return \"bl\\t%__interwork_call_via_%1\";
+    else if (arm_arch5)
+      return \"blx\\t%1\";
+    else if (TARGET_LONG_CALLS)
+      /* For long calls the __call_via functions might not be near
+         this branch, so we have to synthesise their actions.  */
+      return \"bl\\t0f\\n\\tb\\t1f\\n0:\\tbx\\t%1\\n1:\";
     else
       return \"bl\\t%__call_via_%1\";
   }"
diff -Nbaur gcc-3.4.3/gcc/config/arm/t-arm-elf gcc-3.4.3-new/gcc/config/arm/t-arm-elf
--- gcc-3.4.3/gcc/config/arm/t-arm-elf	Tue Sep 30 11:21:41 2003
+++ gcc-3.4.3-new/gcc/config/arm/t-arm-elf	Fri Jan 21 10:25:50 2005
@@ -26,9 +26,9 @@
 # MULTILIB_DIRNAMES   += 32bit 26bit
 # MULTILIB_EXCEPTIONS += *mthumb/*mapcs-26*
 # 
-# MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork
-# MULTILIB_DIRNAMES   += normal interwork
-# MULTILIB_EXCEPTIONS += *mapcs-26/*mthumb-interwork*
+MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork
+MULTILIB_DIRNAMES   += normal interwork
+MULTILIB_EXCEPTIONS += *mapcs-26/*mthumb-interwork*
 # 
 # MULTILIB_OPTIONS    += fno-leading-underscore/fleading-underscore
 # MULTILIB_DIRNAMES   += elf under
diff -Nbaur gcc-3.4.3/gcc/config/i386/cygming.h gcc-3.4.3-new/gcc/config/i386/cygming.h
--- gcc-3.4.3/gcc/config/i386/cygming.h	Tue Jun  8 07:30:13 2004
+++ gcc-3.4.3-new/gcc/config/i386/cygming.h	Fri Jan 21 10:25:50 2005
@@ -251,7 +251,7 @@
    unit may not be bound to undefined symbols in another translation unit
    without user intervention.  For instance, under Microsoft Windows
    symbols must be explicitly imported from shared libraries (DLLs).  */
-#define MULTIPLE_SYMBOL_SPACES
+#define MULTIPLE_SYMBOL_SPACES 1
 
 extern void i386_pe_unique_section (TREE, int);
 #define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section
@@ -308,7 +308,7 @@
 /* DWARF2 Unwinding doesn't work with exception handling yet.  To make
    it work, we need to build a libgcc_s.dll, and dcrt0.o should be
    changed to call __register_frame_info/__deregister_frame_info.  */
-#define DWARF2_UNWIND_INFO 0
+#define DWARF2_UNWIND_INFO 1
 
 /* Don't assume anything about the header files.  */
 #define NO_IMPLICIT_EXTERN_C
diff -Nbaur gcc-3.4.3/gcc/config/i386/i386.c gcc-3.4.3-new/gcc/config/i386/i386.c
--- gcc-3.4.3/gcc/config/i386/i386.c	Wed Aug 25 06:19:08 2004
+++ gcc-3.4.3-new/gcc/config/i386/i386.c	Fri Jan 21 10:25:50 2005
@@ -5242,7 +5242,7 @@
 			       GEN_INT (-allocate), -1);
   else
     {
-      /* Only valid for Win32.  */
+      /* Only valid for Win32  */
       rtx eax = gen_rtx_REG (SImode, 0);
       bool eax_live = ix86_eax_live_at_start_p ();
 
diff -Nbaur gcc-3.4.3/gcc/config/i386/mingw32-1.c gcc-3.4.3-new/gcc/config/i386/mingw32-1.c
--- gcc-3.4.3/gcc/config/i386/mingw32-1.c	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/config/i386/mingw32-1.c	Fri Jan 21 10:25:50 2005
@@ -0,0 +1,41 @@
+/* This replaces the use of stat and struct stat.st_ino to determine if
+   files are different in gcc.c (do_spec_1) handling of --save-temps
+   switch.
+   Contributed by Danny Smith (dannysmith@users.sourceforge.net)
+   Copyright 2003 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+#include "config/i386/xm-mingw32.h"
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+/* Return non-zero if src and dst filenames do not refer to same files. */
+
+int
+w32_file_id_cmp (const char * src, const char * dst)
+{
+  char fullpath_src[MAX_PATH];
+  char fullpath_dst[MAX_PATH];
+  char* pfilename;
+
+ /* Just compare full pathnames, without regard to case. */
+  GetFullPathName (src, MAX_PATH, fullpath_src, &pfilename);
+  GetFullPathName (dst, MAX_PATH, fullpath_dst, &pfilename);
+  return  (lstrcmpi (fullpath_src, fullpath_dst));
+}
diff -Nbaur gcc-3.4.3/gcc/config/i386/mingw32.h gcc-3.4.3-new/gcc/config/i386/mingw32.h
--- gcc-3.4.3/gcc/config/i386/mingw32.h	Fri Sep 26 04:46:06 2003
+++ gcc-3.4.3-new/gcc/config/i386/mingw32.h	Fri Jan 21 10:25:50 2005
@@ -67,7 +67,11 @@
 
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC "%{shared|mdll:dllcrt2%O%s} \
-  %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s}"
+  %{!shared:%{!mdll:crt2%O%s}} %{pg:gcrt2%O%s}  \
+  %{!fno-exceptions:crtbegin%O%s}"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!fno-exceptions:crtend%O%s}"
 
 /* An additional prefix to try after the standard prefixes.  */
 #undef MD_STARTFILE_PREFIX
@@ -104,3 +108,4 @@
 /* Define as short unsigned for compatibility with MS runtime.  */
 #undef WINT_TYPE
 #define WINT_TYPE "short unsigned int"
+
diff -Nbaur gcc-3.4.3/gcc/config/i386/t-cygming gcc-3.4.3-new/gcc/config/i386/t-cygming
--- gcc-3.4.3/gcc/config/i386/t-cygming	Tue Sep 23 19:55:59 2003
+++ gcc-3.4.3-new/gcc/config/i386/t-cygming	Fri Jan 21 10:25:50 2005
@@ -10,6 +10,8 @@
 # first.
 LIBGCC2_INCLUDES = -I$(srcdir)/../winsup/w32api/include
 
+LIB2FUNCS_EXTRA = $(srcdir)/config/i386/w32-shared-ptr.c
+
 winnt.o: $(srcdir)/config/i386/winnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
   $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)
diff -Nbaur gcc-3.4.3/gcc/config/i386/t-mingw32 gcc-3.4.3-new/gcc/config/i386/t-mingw32
--- gcc-3.4.3/gcc/config/i386/t-mingw32	Tue Jun 11 06:25:44 2002
+++ gcc-3.4.3-new/gcc/config/i386/t-mingw32	Fri Jan 21 10:25:51 2005
@@ -1,7 +1,8 @@
 #
 # collect2 doesn't work for i386-mingw32* yet.
 #
-USE_COLLECT2=
+#USE_COLLECT2=
 
 # We hide calls to w32api needed for w32 thread support here:
-LIB2FUNCS_EXTRA = $(srcdir)/config/i386/gthr-win32.c
+LIB2FUNCS_EXTRA += $(srcdir)/config/i386/gthr-win32.c
+
diff -Nbaur gcc-3.4.3/gcc/config/i386/w32-shared-ptr.c gcc-3.4.3-new/gcc/config/i386/w32-shared-ptr.c
--- gcc-3.4.3/gcc/config/i386/w32-shared-ptr.c	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/config/i386/w32-shared-ptr.c	Fri Jan 21 10:25:51 2005
@@ -0,0 +1,244 @@
+/*
+ * w32-shared-ptr.c
+ *
+ * Share informations between EXE/DLLs without using an
+ * additional DLL.
+ *
+ * Contributors:
+ *  Created by Adriano dos Santos Fernandes <adrianosf@uol.com.br>
+ *  Enhanced by Thomas Pfaff <tpfaff@gmx.net>
+ *
+ *  THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ *  This source code is offered for use in the public domain. You may
+ *  use, modify or distribute it freely.
+ *
+ *  This code is distributed in the hope that it will be useful but
+ *  WITHOUT ANY WARRANTY. ALL WARRENTIES, EXPRESS OR IMPLIED ARE HEREBY
+ *  DISCLAMED. This includes but is not limited to warrenties of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifdef __MINGW32__
+#undef _CRTIMP
+#define _CRTIMP
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#ifdef __CYGWIN__
+#include <unistd.h>
+#endif
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "gthr.h"
+
+#include "w32-shared-ptr.h"
+
+#if defined (__CYGWIN__) /* FIXME: This shouldn't be necessary. */
+typedef unsigned short ATOM;
+ATOM __attribute__ ((stdcall)) AddAtomA(const char*);
+ATOM __attribute__  ((stdcall)) FindAtomA(const char*);
+unsigned int __attribute__  ((stdcall)) GetAtomNameA(ATOM,char*,int);
+#else
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
+W32_EH_SHARED *  __w32_sharedptr;
+
+void ** __w32_sharedptr_terminate;
+void ** __w32_sharedptr_unexpected;
+
+
+#define W32_ATOM_SUFFIX "-LIBGCCW32-EH"
+
+#ifdef __USING_SJLJ_EXCEPTIONS__
+#define SJLJ_SUFFIX "-SJLJ"
+#else
+#define SJLJ_SUFFIX
+#endif
+
+#if __GTHREADS
+#define GTHR_SUFFIX "-GTHR"
+#else
+#define GTHR_SUFFIX
+#endif
+
+#ifdef __CYGWIN__
+#define SYS_SUFFIX "-CYGWIN"
+#else
+#define SYS_SUFFIX "-MINGW32"
+#endif
+
+static const char w32_atom_suffix[] = W32_ATOM_SUFFIX SJLJ_SUFFIX GTHR_SUFFIX SYS_SUFFIX;
+
+#define SHAREDPTR_BIT1          'A'
+#define SHAREDPTR_BIT0          'a'
+
+#define SHAREDPTR_BITS          (sizeof(W32_EH_SHARED*)*8)
+#define SHARED_ATOM_NAME_LEN    (SHAREDPTR_BITS + sizeof(w32_atom_suffix))
+
+static ATOM __w32_sharedptr_set (W32_EH_SHARED *w32_sharedptr);
+static W32_EH_SHARED * __w32_sharedptr_get (ATOM atom);
+static void __w32_sharedptr_default_unexpected(void);
+
+#ifdef __CYGWIN__
+static void __w32_sharedptr_fixup_after_fork (void);
+#endif
+
+static void __w32_sharedptr_default_unexpected(void)
+{
+  ((void(*)(void))__w32_sharedptr->terminate)();
+}
+
+static void __w32_eh_shared_initialize (W32_EH_SHARED *w32_sharedptr)
+{
+#ifdef __GTHREAD_MUTEX_INIT
+  static __gthread_mutex_t dw2_object_mutex = __GTHREAD_MUTEX_INIT;
+#else
+  static __gthread_mutex_t dw2_object_mutex;
+#endif
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+  static __gthread_once_t dw2_once = __GTHREAD_ONCE_INIT;
+#endif
+
+#ifdef __USING_SJLJ_EXCEPTIONS__ 
+#if __GTHREADS
+  static __gthread_key_t sjl_fc_key;
+  static __gthread_once_t sjl_once = __GTHREAD_ONCE_INIT;
+#endif
+#endif
+
+  memset (w32_sharedptr, 0, sizeof(W32_EH_SHARED));
+
+  w32_sharedptr->size = sizeof(W32_EH_SHARED);
+
+  w32_sharedptr->terminate = (void*)abort;
+  w32_sharedptr->unexpected = (void*)__w32_sharedptr_default_unexpected;
+
+  w32_sharedptr->dw2_object_mutex = dw2_object_mutex;
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+  w32_sharedptr->dw2_once = dw2_once;
+#endif
+
+#ifdef __USING_SJLJ_EXCEPTIONS__
+  w32_sharedptr->sjlj_fc_static = NULL;
+#if __GTHREADS
+  w32_sharedptr->sjlj_fc_key = sjl_fc_key;
+  w32_sharedptr->sjlj_use_fc_key = -1;
+  w32_sharedptr->sjlj_once = sjl_once;
+#endif
+#endif
+}
+
+void __w32_sharedptr_initialize (void) 
+{
+  W32_EH_SHARED *w32_sharedptr;
+  char s[SHARED_ATOM_NAME_LEN];
+  ATOM atom;
+
+  if (__w32_sharedptr)
+    return;
+
+  memset (s, SHAREDPTR_BIT1, SHAREDPTR_BITS);
+  memcpy (&(s[SHAREDPTR_BITS]), w32_atom_suffix, sizeof(w32_atom_suffix));
+
+  atom = FindAtomA (s);
+  if (atom)
+    w32_sharedptr = __w32_sharedptr_get (atom);
+  else
+    {
+      w32_sharedptr = (W32_EH_SHARED *) malloc (sizeof(W32_EH_SHARED));
+      if (!w32_sharedptr)
+        abort ();
+
+      __w32_eh_shared_initialize (w32_sharedptr);
+
+      if (__w32_sharedptr_set (w32_sharedptr))
+        {
+#ifdef __CYGWIN__
+          /* recreate atom after fork */
+          pthread_atfork (NULL,NULL,__w32_sharedptr_fixup_after_fork);
+#endif
+        }
+      else
+        {
+          free (w32_sharedptr);
+          w32_sharedptr = __w32_sharedptr_get (FindAtomA (s));
+        }
+    }
+
+  __w32_sharedptr_terminate  = &w32_sharedptr->terminate;
+  __w32_sharedptr_unexpected = &w32_sharedptr->unexpected;
+
+  /* THIS MUST BE THE LAST STEP */
+  __w32_sharedptr = w32_sharedptr;
+}
+
+static ATOM __w32_sharedptr_set (W32_EH_SHARED *w32_sharedptr)
+{
+  int i;
+  int bit;
+  char s[SHARED_ATOM_NAME_LEN];
+  ATOM atom;
+
+  /* This should optimize out entirely by O2 */
+  if (sizeof(bit) != sizeof(w32_sharedptr))
+    abort ();
+
+  for (i = SHAREDPTR_BITS - 1, bit = 1; i >= 0; --i, bit <<= 1)
+    s[i] = ((int)w32_sharedptr) & bit ? SHAREDPTR_BIT1 :
+      SHAREDPTR_BIT0;
+
+  memcpy (&(s[SHAREDPTR_BITS]), w32_atom_suffix, sizeof(w32_atom_suffix));
+
+  atom = AddAtomA (s);
+  /* Sanity check to avoid race by concurrent initialization */
+  if (!atom || __w32_sharedptr_get (atom) != w32_sharedptr)
+    return 0;
+
+#ifdef DEBUG
+  printf ("%s: set sharedptr: (%p):%s\n",
+          __FUNCTION__,w32_sharedptr, s);
+#endif
+
+  return atom;
+}
+
+static W32_EH_SHARED *__w32_sharedptr_get (ATOM atom)
+{
+  W32_EH_SHARED *w32_sharedptr = NULL;
+  int i;
+  int bit;
+  char s[SHARED_ATOM_NAME_LEN];
+
+  /* If this fails something went wrong */
+  if (!GetAtomNameA (atom, s, sizeof(s)))
+    abort ();
+
+  for (i = SHAREDPTR_BITS - 1, bit = 1; i >= 0; --i, bit <<= 1)
+    (int)w32_sharedptr |= s[i] == SHAREDPTR_BIT1 ? bit : 0;
+
+  if (w32_sharedptr->size != sizeof(W32_EH_SHARED))
+    abort ();
+
+#ifdef DEBUG
+  printf ("%s: got sharedptr (%p): %s\n",
+          __FUNCTION__, w32_sharedptr, s);
+#endif
+  return w32_sharedptr;
+}
+
+#ifdef __CYGWIN__
+static void __w32_sharedptr_fixup_after_fork (void)
+{
+  if (!__w32_sharedptr_set (__w32_sharedptr))
+    abort ();
+}
+#endif
diff -Nbaur gcc-3.4.3/gcc/config/i386/w32-shared-ptr.h gcc-3.4.3-new/gcc/config/i386/w32-shared-ptr.h
--- gcc-3.4.3/gcc/config/i386/w32-shared-ptr.h	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/config/i386/w32-shared-ptr.h	Fri Jan 21 10:25:51 2005
@@ -0,0 +1,65 @@
+/*
+ * w32-shared-ptr.h
+ *
+ * Contributors:
+ *  Created by Thomas Pfaff <tpfaff@gmx.net>
+ *
+ *  THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ *  This source code is offered for use in the public domain. You may
+ *  use, modify or distribute it freely.
+ *
+ *  This code is distributed in the hope that it will be useful but
+ *  WITHOUT ANY WARRANTY. ALL WARRENTIES, EXPRESS OR IMPLIED ARE HEREBY
+ *  DISCLAMED. This includes but is not limited to warrenties of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef GCC_W32_SHARED_PTR_H
+#define GCC_W32_SHARED_PTR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+  int size;
+  
+  void *terminate;
+  void *unexpected;
+
+  void *dw2_unseen_objects;
+  void *dw2_seen_objects;
+  __gthread_mutex_t dw2_object_mutex;
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+  __gthread_once_t dw2_once;
+#endif
+  const void *dw2_marker;
+
+#ifdef __USING_SJLJ_EXCEPTIONS__ 
+  void* sjlj_fc_static;
+#if __GTHREADS
+  __gthread_key_t sjlj_fc_key;
+  int sjlj_use_fc_key;
+  __gthread_once_t sjlj_once;
+#endif
+#endif
+
+} W32_EH_SHARED;
+
+extern W32_EH_SHARED *__w32_sharedptr;
+
+extern void ** __w32_sharedptr_terminate;
+extern void ** __w32_sharedptr_unexpected;
+
+extern void __w32_sharedptr_initialize (void);
+
+#define W32_SHAREDPTR_INITIALIZE()  if (!__w32_sharedptr) __w32_sharedptr_initialize ()
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nbaur gcc-3.4.3/gcc/config/i386/winnt.c gcc-3.4.3-new/gcc/config/i386/winnt.c
--- gcc-3.4.3/gcc/config/i386/winnt.c	Tue Mar 23 23:18:31 2004
+++ gcc-3.4.3-new/gcc/config/i386/winnt.c	Fri Jan 21 10:25:51 2005
@@ -262,7 +262,8 @@
 	}
 
       /*  Don't allow definitions of static data members in dllimport class,
-	  Just ignore attribute for vtable data.  */
+	  If vtable data is marked as DECL_EXTERNAL, import it; otherwise just
+          ignore the attribute.  */
       else if (TREE_CODE (decl) == VAR_DECL
 	       && TREE_STATIC (decl) && TREE_PUBLIC (decl)
 	       && !DECL_EXTERNAL (decl) && context_imp)
@@ -347,6 +348,13 @@
 
   XEXP (DECL_RTL (decl), 0) =
     gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));
+
+#if 0
+   /* If we are keeping inline functions, make sure we export
+      the function definition even if not used.  */
+  if (flag_keep_inline_functions && TREE_CODE (decl) == FUNCTION_DECL)
+    mark_referenced (DECL_ASSEMBLER_NAME (decl));
+#endif
 }
 
 /* Mark a DECL as being dllimport'd.  */
@@ -559,7 +567,7 @@
   return str;
 }
 
-/* Also strip the stdcall suffix.  */
+/* Also strip the fastcall prefix and stdcall suffix.  */
 
 const char *
 i386_pe_strip_name_encoding_full (const char *str)
@@ -567,6 +575,11 @@
   const char *p;
   const char *name = i386_pe_strip_name_encoding (str);
 
+  /* Strip leading '@' on fastcall symbols.  */
+  if (*name == '@')
+    name++;
+
+  /* Strip trailing '@n'.  */
   p = strchr (name, '@');
   if (p)
     return ggc_alloc_string (name, p - name);
@@ -598,9 +611,9 @@
         }
     }
   else if ((name[0] == FASTCALL_PREFIX)
-           || (strncmp (name, DLL_EXPORT_PREFIX, strlen (DLL_EXPORT_PREFIX)
+           || (strncmp (name, DLL_EXPORT_PREFIX, strlen (DLL_EXPORT_PREFIX))
 	       == 0
-	       && name[strlen (DLL_EXPORT_PREFIX)] == FASTCALL_PREFIX)))
+	       && name[strlen (DLL_EXPORT_PREFIX)] == FASTCALL_PREFIX))
     /* A fastcall symbol.  */
     {
       fprintf (stream, "%s",
@@ -828,7 +841,7 @@
   struct extern_list *p;
 
   ix86_file_end ();
-
+  if (write_symbols != SDB_DEBUG)
   for (p = extern_head; p != NULL; p = p->next)
     {
       tree decl;
diff -Nbaur gcc-3.4.3/gcc/config/i386/x-mingw32 gcc-3.4.3-new/gcc/config/i386/x-mingw32
--- gcc-3.4.3/gcc/config/i386/x-mingw32	Wed May 28 22:06:23 2003
+++ gcc-3.4.3-new/gcc/config/i386/x-mingw32	Fri Jan 21 10:25:51 2005
@@ -2,3 +2,26 @@
 # Make local_includedir relative to EXEC_PREFIX 
 #
 local_includedir=$(libsubdir)/$(unlibsubdir)/..`echo $(exec_prefix) | sed -e 's|^$(prefix)||' -e 's|/[^/]*|/..|g'`/include
+STMP_FIXINC=
+#
+# host runtime lib's printf uses 'I64' format specifier prefix instead
+# of 'll' for HOST_WIDEST_INT_PRINT_*. See hwint.h.
+# Avoid warnings while bootstrapping.
+#
+bt-load.o-warn = -Wno-format
+cfg.o-warn = -Wno-format
+gcov-dump.o-warn = -Wno-format
+gcov.o-warn = -Wno-format
+loop-unroll.o-warn = -Wno-format
+predict.o-warn = -Wno-format
+profile.o-warn = -Wno-format
+
+#
+# For HOST_FILE_ID_CMP for mingw32.
+#
+EXTRA_GCC_OBJS = mingw32-1.o
+
+mingw32-1.o: $(srcdir)/config/i386/mingw32-1.c \
+  $(srcdir)/config/i386/xm-mingw32.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/i386/mingw32-1.c
diff -Nbaur gcc-3.4.3/gcc/config/i386/x-mingw32.patch gcc-3.4.3-new/gcc/config/i386/x-mingw32.patch
--- gcc-3.4.3/gcc/config/i386/x-mingw32.patch	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/config/i386/x-mingw32.patch	Fri Jan 21 10:25:51 2005
@@ -0,0 +1,10 @@
+--- x-mingw32.orig	Sat May 15 18:33:41 2004
++++ x-mingw32	Tue May 11 13:17:28 2004
+@@ -2,6 +2,7 @@
+ # Make local_includedir relative to EXEC_PREFIX
+ #
+ local_includedir=$(libsubdir)/$(unlibsubdir)/..`echo $(exec_prefix) | sed -e 's|^$(prefix)||' -e 's|/[^/]*|/..|g'`/include
++STMP_FIXINC=
+ #
+ # host runtime lib's printf uses 'I64' format specifier prefix instead
+ # of 'll' for HOST_WIDEST_INT_PRINT_*. See hwint.h.
diff -Nbaur gcc-3.4.3/gcc/config/i386/xm-mingw32.h gcc-3.4.3-new/gcc/config/i386/xm-mingw32.h
--- gcc-3.4.3/gcc/config/i386/xm-mingw32.h	Sat Jan 31 06:18:23 2004
+++ gcc-3.4.3-new/gcc/config/i386/xm-mingw32.h	Fri Jan 21 10:25:51 2005
@@ -27,3 +27,18 @@
 
 /* This is the name of the null device on windows.  */
 #define HOST_BIT_BUCKET "nul"
+
+/* Windows way to build quoted strings for COLLECT_GCC_OPTIONS
+   environment variable.  */
+#define HOST_QUOTE_STR "\""
+#define HOST_QUOTE_CHAR '"'
+#define HOST_QUOTED_QUOTE_STR "\"\\\"\""
+
+/* Override the default of "ll" in hwint.t.  */
+#define HOST_LL_PREFIX "I64"
+
+/* This replaces the use of stat to determine if files are different
+   in gcc.c (do_spec_1) handling of --save-temps switch.  */
+extern int
+w32_file_id_cmp (const char *, const char *);
+#define HOST_FILE_ID_CMP(SRC,DST) w32_file_id_cmp (SRC, DST)
diff -Nbaur gcc-3.4.3/gcc/config/rs6000/rs6000.c gcc-3.4.3-new/gcc/config/rs6000/rs6000.c
--- gcc-3.4.3/gcc/config/rs6000/rs6000.c	Fri Oct 22 20:19:35 2004
+++ gcc-3.4.3-new/gcc/config/rs6000/rs6000.c	Fri Jan 21 10:57:02 2005
@@ -10526,19 +10526,24 @@
 			 : gen_adddi3 (breg, breg, delta_rtx));
 	      src = gen_rtx_MEM (mode, breg);
 	    }
-
-	  /* We have now address involving an base register only.
-	     If we use one of the registers to address memory, 
-	     we have change that register last.  */
-
-	  breg = (GET_CODE (XEXP (src, 0)) == PLUS
-		  ? XEXP (XEXP (src, 0), 0)
-		  : XEXP (src, 0));
-
-	  if (!REG_P (breg))
-	      abort();
-
-	  if (REGNO (breg) >= REGNO (dst) 
+	  else if (! offsettable_memref_p (src))
+	    {
+	      rtx newsrc, basereg;
+	      basereg = gen_rtx_REG (Pmode, reg);
+	      emit_insn (gen_rtx_SET (VOIDmode, basereg, XEXP (src, 0)));
+	      newsrc = gen_rtx_MEM (GET_MODE (src), basereg);
+	      MEM_COPY_ATTRIBUTES (newsrc, src);
+	      src = newsrc;
+	    }
+
+	  breg = XEXP (src, 0);
+	  if (GET_CODE (breg) == PLUS || GET_CODE (breg) == LO_SUM)
+	    breg = XEXP (breg, 0);
+
+	  /* If the base register we are using to address memory is
+	     also a destination reg, then change that register last.  */
+	  if (REG_P (breg)
+	      && REGNO (breg) >= REGNO (dst)
 	      && REGNO (breg) < REGNO (dst) + nregs)
 	    j = REGNO (breg) - REGNO (dst);
         }
@@ -10573,6 +10578,8 @@
 			   : gen_adddi3 (breg, breg, delta_rtx));
 	      dst = gen_rtx_MEM (mode, breg);
 	    }
+	  else if (! offsettable_memref_p (dst))
+	    abort ();
 	}
 
       for (i = 0; i < nregs; i++)
@@ -10582,7 +10589,7 @@
 	  if (j == nregs) 
 	    j = 0;
 
-	  /* If compiler already emited move of first word by 
+	  /* If compiler already emitted move of first word by 
 	     store with update, no need to do anything.  */
 	  if (j == 0 && used_update)
 	    continue;
@@ -15200,6 +15207,17 @@
 rs6000_elf_in_small_data_p (tree decl)
 {
   if (rs6000_sdata == SDATA_NONE)
+    return false;
+  /* We want to merge strings, so we never consider them small data.  */
+  if (TREE_CODE (decl) == STRING_CST)
+    return false;
+
+  /* Functions are never in the small data area.  */
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    return false;
+
+  /* Thread-local vars can't go in the small data area.  */
+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))
     return false;
 
   if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl))
diff -Nbaur gcc-3.4.3/gcc/config/rs6000/sysv4.h gcc-3.4.3-new/gcc/config/rs6000/sysv4.h
--- gcc-3.4.3/gcc/config/rs6000/sysv4.h	Mon Oct 18 03:24:20 2004
+++ gcc-3.4.3-new/gcc/config/rs6000/sysv4.h	Fri Jan 21 10:25:51 2005
@@ -444,7 +444,7 @@
   (TARGET_RELOCATABLE || (flag_pic && DEFAULT_ABI != ABI_AIX)		\
    ? "\t.section\t\".got2\",\"aw\"" : "\t.section\t\".got1\",\"aw\"")
 
-#define	SDATA_SECTION_ASM_OP "\t.section\t\".sdata\",\"aw\""
+#define	SDATA_SECTION_ASM_OP "\t.section\t\".sdata\",\"a\""
 #define	SDATA2_SECTION_ASM_OP "\t.section\t\".sdata2\",\"a\""
 #define	SBSS_SECTION_ASM_OP "\t.section\t\".sbss\",\"aw\",@nobits"
 
diff -Nbaur gcc-3.4.3/gcc/config.gcc gcc-3.4.3-new/gcc/config.gcc
--- gcc-3.4.3/gcc/config.gcc	Wed Sep  8 16:16:10 2004
+++ gcc-3.4.3-new/gcc/config.gcc	Fri Jan 21 10:25:51 2005
@@ -1163,6 +1163,8 @@
 	xm_file=i386/xm-mingw32.h
 	tmake_file="i386/t-cygming i386/t-mingw32"
 	extra_objs=winnt.o
+	extra_parts="crtbegin.o crtend.o"
+	target_cpu_default=TARGET_CPU_DEFAULT_pentiumpro
 	if test x$enable_threads = xyes; then
 		thread_file='win32'
 	fi
diff -Nbaur gcc-3.4.3/gcc/config.host gcc-3.4.3-new/gcc/config.host
--- gcc-3.4.3/gcc/config.host	Tue Oct 14 04:41:41 2003
+++ gcc-3.4.3-new/gcc/config.host	Fri Jan 21 10:25:51 2005
@@ -135,6 +135,8 @@
     host_xm_file=i386/xm-mingw32.h
     host_xmake_file=i386/x-mingw32
     host_exeext=.exe
+    host_extra_gcc_objs=mingw32-1.o
+    # host_extra_objs=w32_mmap_anon.o	
     ;;
   i[34567]86-*-uwin*)
     echo "*** UWIN may not be used as a host platform because"
diff -Nbaur gcc-3.4.3/gcc/cp/decl2.c gcc-3.4.3-new/gcc/cp/decl2.c
--- gcc-3.4.3/gcc/cp/decl2.c	Mon Oct 11 15:42:36 2004
+++ gcc-3.4.3-new/gcc/cp/decl2.c	Fri Jan 21 10:25:51 2005
@@ -1476,6 +1476,11 @@
 	{
 	  TREE_PUBLIC (decl) = 1;
 	  DECL_EXTERNAL (decl) = 1;
+	  /* If found and the class has dllimport attribute, commit to
+	     marking the vtable as dllimport, We don't want to change
+	     linkage when maybe_emit_vtable  calls this with final true. */
+	  if (lookup_attribute ("dllimport", TYPE_ATTRIBUTES (type))) 
+	    DECL_INTERFACE_KNOWN (decl) = 1;
 	}
     }
 }
diff -Nbaur gcc-3.4.3/gcc/cp/parser.c gcc-3.4.3-new/gcc/cp/parser.c
--- gcc-3.4.3/gcc/cp/parser.c	Thu Oct 28 06:28:20 2004
+++ gcc-3.4.3-new/gcc/cp/parser.c	Fri Jan 21 10:25:51 2005
@@ -9279,7 +9279,7 @@
 	     declaration context.  */
 
  	  /* Warn about attributes. They are ignored.  */
- 	  if (attributes)
+ 	  if (attributes && extra_warnings)
 	    warning ("type attributes are honored only at type definition");
 
 	  type = xref_tag (tag_type, identifier, 
diff -Nbaur gcc-3.4.3/gcc/cp/repo.c gcc-3.4.3-new/gcc/cp/repo.c
--- gcc-3.4.3/gcc/cp/repo.c	Fri Dec 19 23:28:09 2003
+++ gcc-3.4.3-new/gcc/cp/repo.c	Fri Jan 21 10:25:51 2005
@@ -1,5 +1,5 @@
 /* Code to maintain a C++ template repository.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004
    Free Software Foundation, Inc.
    Contributed by Jason Merrill (jason@cygnus.com)
 
@@ -53,8 +53,8 @@
 
 static struct obstack temporary_obstack;
 
-#define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))
-#define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_4 (NODE))
+#define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_5 (NODE))
+#define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_6 (NODE))
 
 #if 0
 /* Record the flags used to compile this translation unit.  */
@@ -223,7 +223,7 @@
 	break;
       else if (! inside && c == '\\')
 	backquote = 1;
-      else if (c == '\'')
+      else if (c == HOST_QUOTE_CHAR)
 	inside = !inside;
       else
 	obstack_1grow (&temporary_obstack, c);
diff -Nbaur gcc-3.4.3/gcc/crtstuff.c gcc-3.4.3-new/gcc/crtstuff.c
--- gcc-3.4.3/gcc/crtstuff.c	Thu Oct 14 00:29:04 2004
+++ gcc-3.4.3-new/gcc/crtstuff.c	Fri Jan 21 10:25:51 2005
@@ -134,6 +134,8 @@
 /* Likewise for _Jv_RegisterClasses.  */
 extern void _Jv_RegisterClasses (void *) TARGET_ATTRIBUTE_WEAK;
 
+#if !(defined (__MINGW32__) || defined (__CYGWIN__))
+
 #ifdef OBJECT_FORMAT_ELF
 
 /*  Declare a pointer to void function type.  */
@@ -542,3 +544,108 @@
 #else /* ! CRT_BEGIN && ! CRT_END */
 #error "One of CRT_BEGIN or CRT_END must be defined."
 #endif
+
+#else /*__MINGW32__ || __CYGWIN__ */
+
+/* Use  __main to run ctors and dtors. This code generates a
+label for beginning of .eh_frame section in crtbegin.o and terminates
+the section in crtend.o. Registration and deregistration is done by
+installing ctor and dtor functions to do the job.  */
+
+  
+#ifdef CRT_BEGIN
+
+extern  void __w32_sharedptr_initialize(void);
+
+/* Stick a label at the beginning of the frame unwind info so we can
+   register/deregister it with the exception handling library code.  */
+#if defined (USE_EH_FRAME_REGISTRY) \
+	     && !__USING_SJLJ_EXCEPTIONS__
+char __EH_FRAME_BEGIN__[]
+     __attribute__((section(EH_FRAME_SECTION_NAME), aligned(4)))
+     = { };
+
+static struct object obj;
+
+/* These will pull in references from libgcc.a(unwind-dw2-fde.o) */
+
+void __do_frame_init (void);
+void __do_frame_fini (void);
+
+void
+__do_frame_init (void)
+{
+  __w32_sharedptr_initialize();
+  __register_frame_info (__EH_FRAME_BEGIN__, &obj);
+}
+
+void
+__do_frame_fini (void)
+{
+  __deregister_frame_info (__EH_FRAME_BEGIN__);
+}
+#else /* USE_EH_FRAME_REGISTRY && !__USING_SJLJ__EXCEPTIONS__ */
+void __do_sjlj_init (void);
+
+void
+__do_sjlj_init (void)
+{
+  __w32_sharedptr_initialize();
+}
+#endif
+
+
+#elif defined CRT_END
+
+/* Terminate the frame unwind info section with a 0 as a sentinel;
+   this would be the 'length' field in a real FDE.  */
+#if defined (USE_EH_FRAME_REGISTRY) \
+	     && !__USING_SJLJ_EXCEPTIONS__
+static int __EH_FRAME_END__[]
+     __attribute__ ((unused, mode(SI), section(EH_FRAME_SECTION_NAME),
+		     aligned(4)))
+     = { 0 };
+static void __reg_frame_ctor (void) __attribute__ ((constructor));
+static void __dereg_frame_dtor (void) __attribute__ ((destructor));
+extern void __do_frame_init (void);
+extern void __do_frame_fini (void);
+
+
+/* Register the eh_frame. This has to be the first ctor to
+   be invoked so we put it in last. Since we're last, we can't
+   reference __register_frame_info in libgcc.a directly (if eh_frame
+   code has been referenced than it will have been pulled in but
+   we can't count on it) so we  call a thunk in crtbegin.o.  */
+
+static void
+__reg_frame_ctor (void)
+{
+  __do_frame_init ();
+}
+
+/* Deregister the eh_frame. This has to be the last dtor. The
+   call to __register_frame_info in crtbegin.o will have pulled in
+   libgcc.a(unwind-dw2-fde.o) if libgcc.a is static lib but not if
+   dll, so we use a thunk again to be sure.  */
+
+static void
+__dereg_frame_dtor (void)
+{
+  __do_frame_fini ();
+}
+#else
+static void __sjlj_init_ctor (void) __attribute__ ((constructor));
+void __do_sjlj_init (void);
+static void
+__sjlj_init_ctor (void)
+{
+  __do_sjlj_init ();
+}
+
+#endif /* USE_EH_FRAME_REGISTRY && !__USING_SJLJ__EXCEPTIONS__ */
+
+#else /* ! CRT_BEGIN && ! CRT_END */
+#error "One of CRT_BEGIN or CRT_END must be defined."
+#endif
+
+#endif /* __MINGW32__ || __CYGWIN__ */
diff -Nbaur gcc-3.4.3/gcc/doc/extend.texi gcc-3.4.3-new/gcc/doc/extend.texi
--- gcc-3.4.3/gcc/doc/extend.texi	Mon Aug 23 19:02:58 2004
+++ gcc-3.4.3-new/gcc/doc/extend.texi	Fri Jan 21 10:25:51 2005
@@ -3383,7 +3383,7 @@
 @item dllimport
 The @code{dllimport} attribute is described in @xref{Function Attributes}.
 
-@item dlexport
+@item dllexport
 The @code{dllexport} attribute is described in @xref{Function Attributes}.
 
 @end table
diff -Nbaur gcc-3.4.3/gcc/doc/hostconfig.texi gcc-3.4.3-new/gcc/doc/hostconfig.texi
--- gcc-3.4.3/gcc/doc/hostconfig.texi	Wed Jul 30 00:36:47 2003
+++ gcc-3.4.3-new/gcc/doc/hostconfig.texi	Fri Jan 21 10:25:51 2005
@@ -196,7 +196,15 @@
 Define this macro if the host system has a small limit on the total
 size of an argument vector.  This causes the driver to take more care
 not to pass unnecessary arguments to subprocesses.
+
+@item HOST_LL_PREFIX
+Define this macro to be a C string representing the printf format prefix
+to specify output of long long types on your host machine. Hosts using
+the MS C runtime libs use the non-standard @samp{I64} prefix. If you do
+not define this macro, GCC will use the standard @samp{ll} prefix to
+format the printing of long long types.
 @end ftable
+
 
 In addition, if @command{configure} generates an incorrect definition of
 any of the macros in @file{auto-host.h}, you can override that
diff -Nbaur gcc-3.4.3/gcc/doc/invoke.texi gcc-3.4.3-new/gcc/doc/invoke.texi
--- gcc-3.4.3/gcc/doc/invoke.texi	Wed Oct  6 21:15:08 2004
+++ gcc-3.4.3-new/gcc/doc/invoke.texi	Fri Jan 21 10:25:51 2005
@@ -497,7 +497,7 @@
 -m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer @gol
 -mno-red-zone -mno-tls-direct-seg-refs @gol
 -mcmodel=@var{code-model} @gol
--m32  -m64}
+-m32  -m64 -mstack-arg-probe}
 
 @emph{HPPA Options}
 @gccoptlist{-march=@var{architecture-type} @gol
@@ -5992,9 +5992,10 @@
 saves one instruction in the caller since there is no need to pop
 the arguments there.
 
-This calling convention is incompatible with the one normally
-used on Unix, so you cannot use it if you need to call libraries
-compiled with the Unix compiler.
+@strong{Warning:} this calling convention is incompatible with the
+one normally used on Unix or with GCC, so you cannot use it if you
+need to call libraries compiled with the Unix compiler or with GCC
+without the switch.
 
 Also, you must provide function prototypes for all functions that
 take variable numbers of arguments (including @code{printf});
@@ -8554,6 +8555,16 @@
 Generate code for the large model: This model makes no assumptions
 about addresses and sizes of sections.  Currently GCC does not implement
 this model.
+
+@item -mstack-arg-probe
+@opindex mstack-arg-probe
+Emit code in function prologue to probe the stack when allocating more
+than CHECK_STACK_LIMIT bytes in one go. 
+
+Currently, this is the default on windows systems (cygwin and mingw32),
+which define CHECK_STACK_LIMIT as 4000. On these systems, touching the
+stack at 4K increments is necessary to ensure that the guard pages used
+by the OS virtual memory manger are allocated in correct sequence.
 @end table
 
 @node HPPA Options
diff -Nbaur gcc-3.4.3/gcc/gcc.c gcc-3.4.3-new/gcc/gcc.c
--- gcc-3.4.3/gcc/gcc.c	Wed Sep  8 16:16:11 2004
+++ gcc-3.4.3-new/gcc/gcc.c	Fri Jan 21 10:25:51 2005
@@ -88,7 +88,7 @@
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
-#if defined (HAVE_DECL_GETRUSAGE) && !HAVE_DECL_GETRUSAGE
+#if defined (HAVE_GETRUSAGE) && defined (HAVE_DECL_GETRUSAGE) && !HAVE_DECL_GETRUSAGE
 extern int getrusage (int, struct rusage *);
 #endif
 
@@ -3169,7 +3169,7 @@
 			  (argc + 1) * sizeof (argv[0]));
       new_argv[0] = new_argv0;
 
-      execvp (new_argv0, new_argv);
+      execvp (new_argv0, (const char *const *)new_argv);
       fatal ("couldn't run `%s': %s", new_argv0, xstrerror (errno));
     }
 
@@ -4105,29 +4105,31 @@
       if (switches[i].live_cond == SWITCH_IGNORE)
 	continue;
 
-      obstack_grow (&collect_obstack, "'-", 2);
+      obstack_grow (&collect_obstack, HOST_QUOTE_STR "-", 2);
       q = switches[i].part1;
-      while ((p = strchr (q, '\'')))
+      while ((p = strchr (q, HOST_QUOTE_CHAR)))
 	{
 	  obstack_grow (&collect_obstack, q, p - q);
-	  obstack_grow (&collect_obstack, "'\\''", 4);
+	  obstack_grow (&collect_obstack, HOST_QUOTED_QUOTE_STR,
+			strlen (HOST_QUOTED_QUOTE_STR));
 	  q = ++p;
 	}
       obstack_grow (&collect_obstack, q, strlen (q));
-      obstack_grow (&collect_obstack, "'", 1);
+      obstack_grow (&collect_obstack, HOST_QUOTE_STR, 1);
 
       for (args = switches[i].args; args && *args; args++)
 	{
-	  obstack_grow (&collect_obstack, " '", 2);
+	  obstack_grow (&collect_obstack, " " HOST_QUOTE_STR, 2);
 	  q = *args;
-	  while ((p = strchr (q, '\'')))
+	  while ((p = strchr (q, HOST_QUOTE_CHAR)))
 	    {
 	      obstack_grow (&collect_obstack, q, p - q);
-	      obstack_grow (&collect_obstack, "'\\''", 4);
+	      obstack_grow (&collect_obstack, HOST_QUOTED_QUOTE_STR,
+			    strlen (HOST_QUOTED_QUOTE_STR));
 	      q = ++p;
 	    }
 	  obstack_grow (&collect_obstack, q, strlen (q));
-	  obstack_grow (&collect_obstack, "'", 1);
+	  obstack_grow (&collect_obstack, HOST_QUOTE_STR, 1);
 	}
     }
   obstack_grow (&collect_obstack, "\0", 1);
@@ -4150,7 +4152,9 @@
 static int suffixed_basename_length;
 static const char *input_basename;
 static const char *input_suffix;
+#ifndef HOST_FILE_ID_CMP
 static struct stat input_stat;
+#endif
 static int input_stat_set;
 
 /* The compiler used to process the current input file.  */
@@ -4701,6 +4705,9 @@
 		    *((char *) temp_filename + temp_filename_length) = '\0';
 		    if (strcmp (temp_filename, input_filename) != 0)
 		      {
+#if defined HOST_FILE_ID_CMP
+			if (HOST_FILE_ID_CMP(input_filename, temp_filename) != 0)
+#else
 			struct stat st_temp;
 
 			/* Note, set_input() resets input_stat_set to 0.  */
@@ -4720,6 +4727,7 @@
 			    || stat (temp_filename, &st_temp) < 0
 			    || input_stat.st_dev != st_temp.st_dev
 			    || input_stat.st_ino != st_temp.st_ino)
+#endif
 			  {
 			    temp_filename = save_string (temp_filename,
 							 temp_filename_length + 1);
diff -Nbaur gcc-3.4.3/gcc/ggc.h gcc-3.4.3-new/gcc/ggc.h
--- gcc-3.4.3/gcc/ggc.h	Sun Dec 21 14:08:33 2003
+++ gcc-3.4.3-new/gcc/ggc.h	Fri Jan 21 10:25:51 2005
@@ -287,4 +287,8 @@
 extern int ggc_min_heapsize_heuristic (void);
 extern void init_ggc_heuristics (void);
 
+#if defined(_WIN32) && ! defined(__CYGWIN__) && ! defined (_UWIN)
+#define getpagesize() 4096
+#endif
+
 #endif
diff -Nbaur gcc-3.4.3/gcc/ginclude/stdarg.h gcc-3.4.3-new/gcc/ginclude/stdarg.h
--- gcc-3.4.3/gcc/ginclude/stdarg.h	Thu Mar 13 02:58:40 2003
+++ gcc-3.4.3-new/gcc/ginclude/stdarg.h	Fri Jan 21 10:25:51 2005
@@ -30,6 +30,7 @@
 
 #ifndef _STDARG_H
 #ifndef _ANSI_STDARG_H_
+#ifndef RC_INVOKED
 #ifndef __need___va_list
 #define _STDARG_H
 #define _ANSI_STDARG_H_
@@ -129,5 +130,6 @@
 
 #endif /* _STDARG_H */
 
+#endif /* not RC_INVOKED */
 #endif /* not _ANSI_STDARG_H_ */
 #endif /* not _STDARG_H */
diff -Nbaur gcc-3.4.3/gcc/hwint.h gcc-3.4.3-new/gcc/hwint.h
--- gcc-3.4.3/gcc/hwint.h	Wed Jun 25 20:33:08 2003
+++ gcc-3.4.3-new/gcc/hwint.h	Fri Jan 21 10:25:51 2005
@@ -15,6 +15,12 @@
 #define HOST_BITS_PER_INT   (CHAR_BIT * SIZEOF_INT)
 #define HOST_BITS_PER_LONG  (CHAR_BIT * SIZEOF_LONG)
 
+/* On some hosts, runtime printf does not use standard long long prefix.
+   This default can be overriden in host config file.  */
+#ifndef HOST_LL_PREFIX
+# define HOST_LL_PREFIX "ll"
+#endif
+
 /* If HAVE_LONG_LONG and SIZEOF_LONG_LONG aren't defined, but
    GCC_VERSION >= 3000, assume this is the second or later stage of a
    bootstrap, we do have long long, and it's 64 bits.  (This is
@@ -74,10 +80,10 @@
 #  define HOST_WIDE_INT_PRINT_DOUBLE_HEX "0x%lx%08lx"
 # endif
 #else
-# define HOST_WIDE_INT_PRINT "ll"
+# define HOST_WIDE_INT_PRINT HOST_LL_PREFIX
 # define HOST_WIDE_INT_PRINT_C "LL"
   /* We can assume that 'long long' is at least 64 bits.  */
-# define HOST_WIDE_INT_PRINT_DOUBLE_HEX "0x%llx%016llx"
+# define HOST_WIDE_INT_PRINT_DOUBLE_HEX "0x%" HOST_LL_PREFIX "x%016" HOST_LL_PREFIX "x"
 #endif /* HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG */
 
 #define HOST_WIDE_INT_PRINT_DEC "%" HOST_WIDE_INT_PRINT "d"
@@ -109,11 +115,11 @@
     #error "This line should be impossible to reach"
 #  endif
 # endif
-# define HOST_WIDEST_INT_PRINT_DEC	      "%lld"
-# define HOST_WIDEST_INT_PRINT_DEC_C	      "%lldLL"
-# define HOST_WIDEST_INT_PRINT_UNSIGNED	      "%llu"
-# define HOST_WIDEST_INT_PRINT_HEX	      "0x%llx"
-# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     "0x%llx%016llx"
+# define HOST_WIDEST_INT_PRINT_DEC	      "%" HOST_LL_PREFIX "d"
+# define HOST_WIDEST_INT_PRINT_DEC_C	      "%" HOST_LL_PREFIX "dLL"
+# define HOST_WIDEST_INT_PRINT_UNSIGNED	      "%" HOST_LL_PREFIX "u"
+# define HOST_WIDEST_INT_PRINT_HEX	      "0x%" HOST_LL_PREFIX "x"
+# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     "0x%" HOST_LL_PREFIX "x%016" HOST_LL_PREFIX "x"
 #endif
 
 #endif /* ! GCC_HWINT_H */
diff -Nbaur gcc-3.4.3/gcc/libgcc2.c gcc-3.4.3-new/gcc/libgcc2.c
--- gcc-3.4.3/gcc/libgcc2.c	Sun Sep 26 21:47:14 2004
+++ gcc-3.4.3-new/gcc/libgcc2.c	Fri Jan 21 10:25:51 2005
@@ -1504,7 +1504,7 @@
 
 /* Jump to a trampoline, loading the static chain address.  */
 
-#if defined(WINNT) && ! defined(__CYGWIN__) && ! defined (_UWIN)
+#if defined(_WIN32) && ! defined(__CYGWIN__) && ! defined (_UWIN)
 
 long
 getpagesize (void)
diff -Nbaur gcc-3.4.3/gcc/mklibgcc.in gcc-3.4.3-new/gcc/mklibgcc.in
--- gcc-3.4.3/gcc/mklibgcc.in	Mon Oct 18 17:00:43 2004
+++ gcc-3.4.3-new/gcc/mklibgcc.in	Fri Jan 21 10:25:51 2005
@@ -45,6 +45,7 @@
 echo 'srcdir = @srcdir@'
 echo 'VPATH = @srcdir@'
 echo 'EQ = ='
+echo 'INCLUDES += -I@srcdir@'
 echo
 echo 'force:'
 echo
diff -Nbaur gcc-3.4.3/gcc/mklibgcc.in.patch gcc-3.4.3-new/gcc/mklibgcc.in.patch
--- gcc-3.4.3/gcc/mklibgcc.in.patch	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/mklibgcc.in.patch	Fri Jan 21 10:25:51 2005
@@ -0,0 +1,10 @@
+--- mklibgcc.in.orig	Sat May 15 18:33:35 2004
++++ mklibgcc.in	Tue May 11 12:54:15 2004
+@@ -39,6 +39,7 @@
+ echo 'srcdir = @srcdir@'
+ echo 'VPATH = @srcdir@'
+ echo 'EQ = ='
++echo 'INCLUDES += -I@srcdir@'
+ echo
+ echo 'force:'
+ echo
diff -Nbaur gcc-3.4.3/gcc/stor-layout.c gcc-3.4.3-new/gcc/stor-layout.c
--- gcc-3.4.3/gcc/stor-layout.c	Sat May 29 00:16:00 2004
+++ gcc-3.4.3-new/gcc/stor-layout.c	Fri Jan 21 10:25:51 2005
@@ -1,6 +1,6 @@
 /* C-compiler utilities for types and variables storage layout
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1996, 1998,
-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003. 2004  Free Software Foundation, Inc.
 
 This file is part of GCC.
 
diff -Nbaur gcc-3.4.3/gcc/system.h gcc-3.4.3-new/gcc/system.h
--- gcc-3.4.3/gcc/system.h	Mon Mar 15 23:22:47 2004
+++ gcc-3.4.3-new/gcc/system.h	Fri Jan 21 10:25:51 2005
@@ -486,6 +486,19 @@
 #define HOST_BIT_BUCKET "/dev/null"
 #endif
 
+/* Defaults for building quoted strings for COLLECT_GCC_OPTIONS
+   environment variable.  These work for POSIX-like hosts. */
+
+#ifndef HOST_QUOTE_STR
+#define HOST_QUOTE_STR "\'"
+#endif
+#ifndef HOST_QUOTE_CHAR
+#define HOST_QUOTE_CHAR '\''
+#endif
+#ifndef HOST_QUOTED_QUOTE_STR
+#define HOST_QUOTED_QUOTE_STR "'\\''"
+#endif
+
 /* Be conservative and only use enum bitfields with GCC.
    FIXME: provide a complete autoconf test for buggy enum bitfields.  */
 
diff -Nbaur gcc-3.4.3/gcc/tlink.c gcc-3.4.3-new/gcc/tlink.c
--- gcc-3.4.3/gcc/tlink.c	Sat Jul 19 15:47:14 2003
+++ gcc-3.4.3-new/gcc/tlink.c	Fri Jan 21 10:25:51 2005
@@ -463,11 +463,20 @@
 	}
       fclose (stream);
       fclose (output);
-      rename (outname, f->key);
+      /* On Windows "rename" returns -1 and sets ERRNO to EACCESS if
+	 the new file name already exists.  Therefore, we explicitly
+	 remove the old file first.  */
+      if (remove (f->key) == -1)
+	fatal_perror ("removing .rpo file");
+      if (rename (outname, f->key) == -1)
+	fatal_perror ("renaming .rpo file");
 
       obstack_grow (&temporary_obstack, "cd ", 3);
       obstack_grow (&temporary_obstack, f->dir, strlen (f->dir));
-      obstack_grow (&temporary_obstack, "; ", 2);
+      /* Using ";" as a separator between commands does not work with
+	 the Windows command shell.  Therefore, we use "&&" which
+	 should work everywhere.  */
+      obstack_grow (&temporary_obstack, " && ", 4);
       obstack_grow (&temporary_obstack, c_file_name, strlen (c_file_name));
       obstack_1grow (&temporary_obstack, ' ');
       obstack_grow (&temporary_obstack, f->args, strlen (f->args));
diff -Nbaur gcc-3.4.3/gcc/unwind-dw2-fde.c gcc-3.4.3-new/gcc/unwind-dw2-fde.c
--- gcc-3.4.3/gcc/unwind-dw2-fde.c	Fri Oct 31 20:46:26 2003
+++ gcc-3.4.3-new/gcc/unwind-dw2-fde.c	Fri Jan 21 10:25:51 2005
@@ -41,18 +41,32 @@
 #include "gthr.h"
 #endif
 
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+#include "config/i386/w32-shared-ptr.h"
+#endif
+
 /* The unseen_objects list contains objects that have been registered
    but not yet categorized in any way.  The seen_objects list has had
    it's pc_begin and count fields initialized at minimum, and is sorted
    by decreasing value of pc_begin.  */
+
+#if ! (defined (__MINGW32__ ) || defined (__CYGWIN__))
 static struct object *unseen_objects;
 static struct object *seen_objects;
+#else
+#define unseen_objects  (*(struct object**)(&__w32_sharedptr->dw2_unseen_objects))
+#define seen_objects    (*(struct object**)(&__w32_sharedptr->dw2_seen_objects))
+#endif
 
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
 #ifdef __GTHREAD_MUTEX_INIT
 static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;
 #else
 static __gthread_mutex_t object_mutex;
 #endif
+#else
+#define object_mutex  (__w32_sharedptr->dw2_object_mutex)
+#endif
 
 #ifdef __GTHREAD_MUTEX_INIT_FUNCTION
 static void
@@ -64,8 +78,15 @@
 static void
 init_object_mutex_once (void)
 {
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
   static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+#else
+#define once  (__w32_sharedptr->dw2_once)
+#endif
   __gthread_once (&once, init_object_mutex);
+#if (defined (__MINGW32__ ) || defined (__CYGWIN__))
+#undef once
+#endif
 }
 #else
 #define init_object_mutex_once()
@@ -429,9 +450,13 @@
 fde_split (struct object *ob, fde_compare_t fde_compare,
 	   struct fde_vector *linear, struct fde_vector *erratic)
 {
-  static const fde *marker;
-  size_t count = linear->count;
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
+  static fde *marker;
+#else
+#define marker  (*(const fde **)&__w32_sharedptr->dw2_marker)
+#endif
   const fde **chain_end = &marker;
+  size_t count = linear->count;
   size_t i, j, k;
 
   /* This should optimize out, but it is wise to make sure this assumption
@@ -465,6 +490,9 @@
       erratic->array[k++] = linear->array[i];
   linear->count = j;
   erratic->count = k;
+#if (defined (__MINGW32__ ) || defined (__CYGWIN__))
+#undef marker
+#endif
 }
 
 #define SWAP(x,y) do { const fde * tmp = x; x = y; y = tmp; } while (0)
diff -Nbaur gcc-3.4.3/gcc/unwind-sjlj.c gcc-3.4.3-new/gcc/unwind-sjlj.c
--- gcc-3.4.3/gcc/unwind-sjlj.c	Sun Nov  2 00:00:08 2003
+++ gcc-3.4.3-new/gcc/unwind-sjlj.c	Fri Jan 21 10:25:51 2005
@@ -35,6 +35,10 @@
 #include "unwind.h"
 #include "gthr.h"
 
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+#include "config/i386/w32-shared-ptr.h"
+#endif
+
 #ifdef __USING_SJLJ_EXCEPTIONS__
 
 #ifdef DONT_USE_BUILTIN_SETJMP
@@ -95,12 +99,21 @@
 
 /* Manage the chain of registered function contexts.  */
 
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
 /* Single threaded fallback chain.  */
 static struct SjLj_Function_Context *fc_static;
+#else
+#define fc_static  (*(struct SjLj_Function_Context**)&__w32_sharedptr->sjlj_fc_static)
+#endif
 
 #if __GTHREADS
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
 static __gthread_key_t fc_key;
 static int use_fc_key = -1;
+#else
+#define fc_key      (__w32_sharedptr->sjlj_fc_key)
+#define use_fc_key  (__w32_sharedptr->sjlj_use_fc_key)
+#endif
 
 static void
 fc_key_init (void)
@@ -111,15 +124,26 @@
 static void
 fc_key_init_once (void)
 {
+#if !(defined (__MINGW32__ ) || defined (__CYGWIN__))
   static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+#else
+#define once (__w32_sharedptr->sjlj_once)
+#endif
   if (__gthread_once (&once, fc_key_init) != 0 || use_fc_key < 0)
     use_fc_key = 0;
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+#undef once
+#endif
 }
 #endif
 
 void
 _Unwind_SjLj_Register (struct SjLj_Function_Context *fc)
 {
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+  W32_SHAREDPTR_INITIALIZE ();
+#endif
+
 #if __GTHREADS
   if (use_fc_key < 0)
     fc_key_init_once ();
@@ -140,6 +164,10 @@
 static inline struct SjLj_Function_Context *
 _Unwind_SjLj_GetContext (void)
 {
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+  W32_SHAREDPTR_INITIALIZE ();
+#endif
+
 #if __GTHREADS
   if (use_fc_key < 0)
     fc_key_init_once ();
@@ -153,6 +181,10 @@
 static inline void
 _Unwind_SjLj_SetContext (struct SjLj_Function_Context *fc)
 {
+#if defined (__MINGW32__ ) || defined (__CYGWIN__)
+  W32_SHAREDPTR_INITIALIZE ();
+#endif
+
 #if __GTHREADS
   if (use_fc_key < 0)
     fc_key_init_once ();
diff -Nbaur gcc-3.4.3/gcc/varasm.c gcc-3.4.3-new/gcc/varasm.c
--- gcc-3.4.3/gcc/varasm.c	Sun Oct 31 09:10:03 2004
+++ gcc-3.4.3-new/gcc/varasm.c	Tue Jan 25 10:34:15 2005
@@ -4915,6 +4915,7 @@
 default_elf_select_section_1 (tree decl, int reloc,
 			      unsigned HOST_WIDE_INT align, int shlib)
 {
+  const char *sname;
   switch (categorize_decl_for_section (decl, reloc, shlib))
     {
     case SECCAT_TEXT:
@@ -4922,56 +4923,61 @@
       abort ();
     case SECCAT_RODATA:
       readonly_data_section ();
-      break;
+      return;
     case SECCAT_RODATA_MERGE_STR:
       mergeable_string_section (decl, align, 0);
-      break;
+      return;
     case SECCAT_RODATA_MERGE_STR_INIT:
       mergeable_string_section (DECL_INITIAL (decl), align, 0);
-      break;
+      return;
     case SECCAT_RODATA_MERGE_CONST:
       mergeable_constant_section (DECL_MODE (decl), align, 0);
-      break;
+      return;
     case SECCAT_SRODATA:
-      named_section (NULL_TREE, ".sdata2", reloc);
+      sname = ".sdata2";
       break;
     case SECCAT_DATA:
       data_section ();
-      break;
+      return;
     case SECCAT_DATA_REL:
-      named_section (NULL_TREE, ".data.rel", reloc);
+      sname = ".data.rel";
       break;
     case SECCAT_DATA_REL_LOCAL:
-      named_section (NULL_TREE, ".data.rel.local", reloc);
+      sname = ".data.rel.local";
       break;
     case SECCAT_DATA_REL_RO:
-      named_section (NULL_TREE, ".data.rel.ro", reloc);
+      sname = ".data.rel.ro";
       break;
     case SECCAT_DATA_REL_RO_LOCAL:
-      named_section (NULL_TREE, ".data.rel.ro.local", reloc);
+      sname = ".data.rel.ro.local";
       break;
     case SECCAT_SDATA:
-      named_section (NULL_TREE, ".sdata", reloc);
+      sname = ".sdata";
       break;
     case SECCAT_TDATA:
-      named_section (NULL_TREE, ".tdata", reloc);
+      sname = ".tdata";
       break;
     case SECCAT_BSS:
 #ifdef BSS_SECTION_ASM_OP
       bss_section ();
+      return;
 #else
-      named_section (NULL_TREE, ".bss", reloc);
-#endif
+      sname = ".bss";
       break;
+#endif
     case SECCAT_SBSS:
-      named_section (NULL_TREE, ".sbss", reloc);
+      sname = ".sbss";
       break;
     case SECCAT_TBSS:
-      named_section (NULL_TREE, ".tbss", reloc);
+      sname = ".tbss";
       break;
     default:
       abort ();
     }
+
+  if (!DECL_P (decl))
+    decl = NULL_TREE;
+  named_section (decl, sname, reloc);
 }
 
 /* Construct a unique section name based on the decl name and the
diff -Nbaur gcc-3.4.3/gcc/varasm.c.orig gcc-3.4.3-new/gcc/varasm.c.orig
--- gcc-3.4.3/gcc/varasm.c.orig	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/gcc/varasm.c.orig	Tue Jan 25 10:34:10 2005
@@ -0,0 +1,5240 @@
+/* Output variables, constants and external declarations, for GNU compiler.
+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
+   1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+
+/* This file handles generation of all the assembler code
+   *except* the instructions of a function.
+   This includes declarations of variables and their initial values.
+
+   We also output the assembler code for constants stored in memory
+   and are responsible for combining constants with the same value.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "flags.h"
+#include "function.h"
+#include "expr.h"
+#include "hard-reg-set.h"
+#include "regs.h"
+#include "real.h"
+#include "output.h"
+#include "toplev.h"
+#include "hashtab.h"
+#include "c-pragma.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "tm_p.h"
+#include "debug.h"
+#include "target.h"
+#include "cgraph.h"
+
+#ifdef XCOFF_DEBUGGING_INFO
+#include "xcoffout.h"		/* Needed for external data
+				   declarations for e.g. AIX 4.x.  */
+#endif
+
+#ifndef TRAMPOLINE_ALIGNMENT
+#define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
+#endif
+
+#ifndef ASM_STABS_OP
+#define ASM_STABS_OP "\t.stabs\t"
+#endif
+
+/* The (assembler) name of the first globally-visible object output.  */
+const char *first_global_object_name;
+const char *weak_global_object_name;
+
+struct addr_const;
+struct constant_descriptor_rtx;
+struct rtx_const;
+struct pool_constant;
+
+#define MAX_RTX_HASH_TABLE 61
+
+struct varasm_status GTY(())
+{
+  /* Hash facility for making memory-constants
+     from constant rtl-expressions.  It is used on RISC machines
+     where immediate integer arguments and constant addresses are restricted
+     so that such constants must be stored in memory.
+
+     This pool of constants is reinitialized for each function
+     so each function gets its own constants-pool that comes right before
+     it.  */
+  struct constant_descriptor_rtx ** GTY ((length ("MAX_RTX_HASH_TABLE")))
+    x_const_rtx_hash_table;
+  struct pool_constant ** GTY ((length ("MAX_RTX_HASH_TABLE")))
+    x_const_rtx_sym_hash_table;
+
+  /* Pointers to first and last constant in pool.  */
+  struct pool_constant *x_first_pool;
+  struct pool_constant *x_last_pool;
+
+  /* Current offset in constant pool (does not include any machine-specific
+     header).  */
+  HOST_WIDE_INT x_pool_offset;
+
+  /* Number of tree-constants deferred during the expansion of this
+     function.  */
+  unsigned int deferred_constants;
+};
+
+#define const_rtx_hash_table (cfun->varasm->x_const_rtx_hash_table)
+#define const_rtx_sym_hash_table (cfun->varasm->x_const_rtx_sym_hash_table)
+#define first_pool (cfun->varasm->x_first_pool)
+#define last_pool (cfun->varasm->x_last_pool)
+#define pool_offset (cfun->varasm->x_pool_offset)
+#define n_deferred_constants (cfun->varasm->deferred_constants)
+
+/* Number for making the label on the next
+   constant that is stored in memory.  */
+
+static GTY(()) int const_labelno;
+
+/* Carry information from ASM_DECLARE_OBJECT_NAME
+   to ASM_FINISH_DECLARE_OBJECT.  */
+
+int size_directive_output;
+
+/* The last decl for which assemble_variable was called,
+   if it did ASM_DECLARE_OBJECT_NAME.
+   If the last call to assemble_variable didn't do that,
+   this holds 0.  */
+
+tree last_assemble_variable_decl;
+
+/* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.
+   So giving constant the alias set for the type will allow such
+   initializations to appear to conflict with the load of the constant.  We
+   avoid this by giving all constants an alias set for just constants.
+   Since there will be no stores to that alias set, nothing will ever
+   conflict with them.  */
+
+static HOST_WIDE_INT const_alias_set;
+
+static const char *strip_reg_name (const char *);
+static int contains_pointers_p (tree);
+#ifdef ASM_OUTPUT_EXTERNAL
+static bool incorporeal_function_p (tree);
+#endif
+static void decode_addr_const (tree, struct addr_const *);
+static hashval_t const_desc_hash (const void *);
+static int const_desc_eq (const void *, const void *);
+static hashval_t const_hash_1 (const tree);
+static int compare_constant (const tree, const tree);
+static tree copy_constant (tree);
+static void output_constant_def_contents (rtx);
+static void decode_rtx_const (enum machine_mode, rtx, struct rtx_const *);
+static unsigned int const_hash_rtx (enum machine_mode, rtx);
+static int compare_constant_rtx (enum machine_mode, rtx,
+				 struct constant_descriptor_rtx *);
+static struct constant_descriptor_rtx * record_constant_rtx
+  (enum machine_mode, rtx);
+static struct pool_constant *find_pool_constant (struct function *, rtx);
+static void mark_constant_pool (void);
+static void mark_constants (rtx);
+static int mark_constant (rtx *current_rtx, void *data);
+static void output_addressed_constants (tree);
+static unsigned HOST_WIDE_INT array_size_for_constructor (tree);
+static unsigned min_align (unsigned, unsigned);
+static void output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int);
+static void globalize_decl (tree);
+static void maybe_assemble_visibility (tree);
+static int in_named_entry_eq (const void *, const void *);
+static hashval_t in_named_entry_hash (const void *);
+#ifdef ASM_OUTPUT_BSS
+static void asm_output_bss (FILE *, tree, const char *,
+			    unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);
+#endif
+#ifdef BSS_SECTION_ASM_OP
+#ifdef ASM_OUTPUT_ALIGNED_BSS
+static void asm_output_aligned_bss (FILE *, tree, const char *,
+				    unsigned HOST_WIDE_INT, int)
+     ATTRIBUTE_UNUSED;
+#endif
+#endif /* BSS_SECTION_ASM_OP */
+static bool asm_emit_uninitialised (tree, const char*,
+				    unsigned HOST_WIDE_INT,
+				    unsigned HOST_WIDE_INT);
+static void mark_weak (tree);
+
+enum in_section { no_section, in_text, in_data, in_named
+#ifdef BSS_SECTION_ASM_OP
+  , in_bss
+#endif
+#ifdef CTORS_SECTION_ASM_OP
+  , in_ctors
+#endif
+#ifdef DTORS_SECTION_ASM_OP
+  , in_dtors
+#endif
+#ifdef READONLY_DATA_SECTION_ASM_OP
+  , in_readonly_data
+#endif
+#ifdef EXTRA_SECTIONS
+  , EXTRA_SECTIONS
+#endif
+};
+static GTY(()) enum in_section in_section = no_section;
+
+/* Return a nonzero value if DECL has a section attribute.  */
+#ifndef IN_NAMED_SECTION
+#define IN_NAMED_SECTION(DECL) \
+  ((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \
+   && DECL_SECTION_NAME (DECL) != NULL_TREE)
+#endif
+
+/* Text of section name when in_section == in_named.  */
+static GTY(()) const char *in_named_name;
+
+/* Hash table of flags that have been used for a particular named section.  */
+
+struct in_named_entry GTY(())
+{
+  const char *name;
+  unsigned int flags;
+  bool declared;
+};
+
+static GTY((param_is (struct in_named_entry))) htab_t in_named_htab;
+
+/* Define functions like text_section for any extra sections.  */
+#ifdef EXTRA_SECTION_FUNCTIONS
+EXTRA_SECTION_FUNCTIONS
+#endif
+
+/* Tell assembler to switch to text section.  */
+
+void
+text_section (void)
+{
+  if (in_section != in_text)
+    {
+      in_section = in_text;
+      fprintf (asm_out_file, "%s\n", TEXT_SECTION_ASM_OP);
+    }
+}
+
+/* Tell assembler to switch to data section.  */
+
+void
+data_section (void)
+{
+  if (in_section != in_data)
+    {
+      in_section = in_data;
+      if (flag_shared_data)
+	{
+#ifdef SHARED_SECTION_ASM_OP
+	  fprintf (asm_out_file, "%s\n", SHARED_SECTION_ASM_OP);
+#else
+	  fprintf (asm_out_file, "%s\n", DATA_SECTION_ASM_OP);
+#endif
+	}
+      else
+	fprintf (asm_out_file, "%s\n", DATA_SECTION_ASM_OP);
+    }
+}
+
+/* Tell assembler to switch to read-only data section.  This is normally
+   the text section.  */
+
+void
+readonly_data_section (void)
+{
+#ifdef READONLY_DATA_SECTION
+  READONLY_DATA_SECTION ();  /* Note this can call data_section.  */
+#else
+#ifdef READONLY_DATA_SECTION_ASM_OP
+  if (in_section != in_readonly_data)
+    {
+      in_section = in_readonly_data;
+      fputs (READONLY_DATA_SECTION_ASM_OP, asm_out_file);
+      fputc ('\n', asm_out_file);
+    }
+#else
+  text_section ();
+#endif
+#endif
+}
+
+/* Determine if we're in the text section.  */
+
+int
+in_text_section (void)
+{
+  return in_section == in_text;
+}
+
+/* Determine if we're in the data section.  */
+
+int
+in_data_section (void)
+{
+  return in_section == in_data;
+}
+
+/* Helper routines for maintaining in_named_htab.  */
+
+static int
+in_named_entry_eq (const void *p1, const void *p2)
+{
+  const struct in_named_entry *old = p1;
+  const char *new = p2;
+
+  return strcmp (old->name, new) == 0;
+}
+
+static hashval_t
+in_named_entry_hash (const void *p)
+{
+  const struct in_named_entry *old = p;
+  return htab_hash_string (old->name);
+}
+
+/* If SECTION has been seen before as a named section, return the flags
+   that were used.  Otherwise, return 0.  Note, that 0 is a perfectly valid
+   set of flags for a section to have, so 0 does not mean that the section
+   has not been seen.  */
+
+unsigned int
+get_named_section_flags (const char *section)
+{
+  struct in_named_entry **slot;
+
+  slot = (struct in_named_entry **)
+    htab_find_slot_with_hash (in_named_htab, section,
+			      htab_hash_string (section), NO_INSERT);
+
+  return slot ? (*slot)->flags : 0;
+}
+
+/* Returns true if the section has been declared before.   Sets internal
+   flag on this section in in_named_hash so subsequent calls on this
+   section will return false.  */
+
+bool
+named_section_first_declaration (const char *name)
+{
+  struct in_named_entry **slot;
+
+  slot = (struct in_named_entry **)
+    htab_find_slot_with_hash (in_named_htab, name,
+			      htab_hash_string (name), NO_INSERT);
+  if (! (*slot)->declared)
+    {
+      (*slot)->declared = true;
+      return true;
+    }
+  else
+    {
+      return false;
+    }
+}
+
+
+/* Record FLAGS for SECTION.  If SECTION was previously recorded with a
+   different set of flags, return false.  */
+
+bool
+set_named_section_flags (const char *section, unsigned int flags)
+{
+  struct in_named_entry **slot, *entry;
+
+  slot = (struct in_named_entry **)
+    htab_find_slot_with_hash (in_named_htab, section,
+			      htab_hash_string (section), INSERT);
+  entry = *slot;
+
+  if (!entry)
+    {
+      entry = ggc_alloc (sizeof (*entry));
+      *slot = entry;
+      entry->name = ggc_strdup (section);
+      entry->flags = flags;
+      entry->declared = false;
+    }
+  else if (entry->flags != flags)
+    return false;
+
+  return true;
+}
+
+/* Tell assembler to change to section NAME with attributes FLAGS.  */
+
+void
+named_section_flags (const char *name, unsigned int flags)
+{
+  if (in_section != in_named || strcmp (name, in_named_name) != 0)
+    {
+      if (! set_named_section_flags (name, flags))
+	abort ();
+
+      (*targetm.asm_out.named_section) (name, flags);
+
+      if (flags & SECTION_FORGET)
+	in_section = no_section;
+      else
+	{
+	  in_named_name = ggc_strdup (name);
+	  in_section = in_named;
+	}
+    }
+}
+
+/* Tell assembler to change to section NAME for DECL.
+   If DECL is NULL, just switch to section NAME.
+   If NAME is NULL, get the name from DECL.
+   If RELOC is 1, the initializer for DECL contains relocs.  */
+
+void
+named_section (tree decl, const char *name, int reloc)
+{
+  unsigned int flags;
+
+  if (decl != NULL_TREE && !DECL_P (decl))
+    abort ();
+  if (name == NULL)
+    name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+
+  flags = (* targetm.section_type_flags) (decl, name, reloc);
+
+  /* Sanity check user variables for flag changes.  Non-user
+     section flag changes will abort in named_section_flags.
+     However, don't complain if SECTION_OVERRIDE is set.
+     We trust that the setter knows that it is safe to ignore
+     the default flags for this decl.  */
+  if (decl && ! set_named_section_flags (name, flags))
+    {
+      flags = get_named_section_flags (name);
+      if ((flags & SECTION_OVERRIDE) == 0)
+	error ("%J%D causes a section type conflict", decl, decl);
+    }
+
+  named_section_flags (name, flags);
+}
+
+/* If required, set DECL_SECTION_NAME to a unique name.  */
+
+void
+resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,
+			int flag_function_or_data_sections)
+{
+  if (DECL_SECTION_NAME (decl) == NULL_TREE
+      && targetm.have_named_sections
+      && (flag_function_or_data_sections
+	  || DECL_ONE_ONLY (decl)))
+    (*targetm.asm_out.unique_section) (decl, reloc);
+}
+
+#ifdef BSS_SECTION_ASM_OP
+
+/* Tell the assembler to switch to the bss section.  */
+
+void
+bss_section (void)
+{
+  if (in_section != in_bss)
+    {
+      fprintf (asm_out_file, "%s\n", BSS_SECTION_ASM_OP);
+      in_section = in_bss;
+    }
+}
+
+#ifdef ASM_OUTPUT_BSS
+
+/* Utility function for ASM_OUTPUT_BSS for targets to use if
+   they don't support alignments in .bss.
+   ??? It is believed that this function will work in most cases so such
+   support is localized here.  */
+
+static void
+asm_output_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,
+		const char *name,
+		unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,
+		unsigned HOST_WIDE_INT rounded)
+{
+  (*targetm.asm_out.globalize_label) (file, name);
+  bss_section ();
+#ifdef ASM_DECLARE_OBJECT_NAME
+  last_assemble_variable_decl = decl;
+  ASM_DECLARE_OBJECT_NAME (file, name, decl);
+#else
+  /* Standard thing is just output label for the object.  */
+  ASM_OUTPUT_LABEL (file, name);
+#endif /* ASM_DECLARE_OBJECT_NAME */
+  ASM_OUTPUT_SKIP (file, rounded ? rounded : 1);
+}
+
+#endif
+
+#ifdef ASM_OUTPUT_ALIGNED_BSS
+
+/* Utility function for targets to use in implementing
+   ASM_OUTPUT_ALIGNED_BSS.
+   ??? It is believed that this function will work in most cases so such
+   support is localized here.  */
+
+static void
+asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,
+			const char *name, unsigned HOST_WIDE_INT size,
+			int align)
+{
+  bss_section ();
+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
+#ifdef ASM_DECLARE_OBJECT_NAME
+  last_assemble_variable_decl = decl;
+  ASM_DECLARE_OBJECT_NAME (file, name, decl);
+#else
+  /* Standard thing is just output label for the object.  */
+  ASM_OUTPUT_LABEL (file, name);
+#endif /* ASM_DECLARE_OBJECT_NAME */
+  ASM_OUTPUT_SKIP (file, size ? size : 1);
+}
+
+#endif
+
+#endif /* BSS_SECTION_ASM_OP */
+
+/* Switch to the section for function DECL.
+
+   If DECL is NULL_TREE, switch to the text section.
+   ??? It's not clear that we will ever be passed NULL_TREE, but it's
+   safer to handle it.  */
+
+void
+function_section (tree decl)
+{
+  if (decl != NULL_TREE
+      && DECL_SECTION_NAME (decl) != NULL_TREE)
+    named_section (decl, (char *) 0, 0);
+  else
+    text_section ();
+}
+
+/* Switch to section for variable DECL.  RELOC is the same as the
+   argument to SELECT_SECTION.  */
+
+void
+variable_section (tree decl, int reloc)
+{
+  if (IN_NAMED_SECTION (decl))
+    named_section (decl, NULL, reloc);
+  else
+    (*targetm.asm_out.select_section) (decl, reloc, DECL_ALIGN (decl));
+}
+
+/* Tell assembler to switch to the section for string merging.  */
+
+void
+mergeable_string_section (tree decl ATTRIBUTE_UNUSED,
+			  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED,
+			  unsigned int flags ATTRIBUTE_UNUSED)
+{
+  if (HAVE_GAS_SHF_MERGE && flag_merge_constants
+      && TREE_CODE (decl) == STRING_CST
+      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE
+      && align <= 256
+      && TREE_STRING_LENGTH (decl) >= int_size_in_bytes (TREE_TYPE (decl)))
+    {
+      enum machine_mode mode;
+      unsigned int modesize;
+      const char *str;
+      int i, j, len, unit;
+      char name[30];
+
+      mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (decl)));
+      modesize = GET_MODE_BITSIZE (mode);
+      if (modesize >= 8 && modesize <= 256
+	  && (modesize & (modesize - 1)) == 0)
+	{
+	  if (align < modesize)
+	    align = modesize;
+
+	  str = TREE_STRING_POINTER (decl);
+	  len = TREE_STRING_LENGTH (decl);
+	  unit = GET_MODE_SIZE (mode);
+
+	  /* Check for embedded NUL characters.  */
+	  for (i = 0; i < len; i += unit)
+	    {
+	      for (j = 0; j < unit; j++)
+		if (str[i + j] != '\0')
+		  break;
+	      if (j == unit)
+		break;
+	    }
+	  if (i == len - unit)
+	    {
+	      sprintf (name, ".rodata.str%d.%d", modesize / 8,
+		       (int) (align / 8));
+	      flags |= (modesize / 8) | SECTION_MERGE | SECTION_STRINGS;
+	      if (!i && modesize < align)
+		{
+		  /* A "" string with requested alignment greater than
+		     character size might cause a problem:
+		     if some other string required even bigger
+		     alignment than "", then linker might think the
+		     "" is just part of padding after some other string
+		     and not put it into the hash table initially.
+		     But this means "" could have smaller alignment
+		     than requested.  */
+#ifdef ASM_OUTPUT_SECTION_START
+		  named_section_flags (name, flags);
+		  ASM_OUTPUT_SECTION_START (asm_out_file);
+#else
+		  readonly_data_section ();
+#endif
+		  return;
+		}
+
+	      named_section_flags (name, flags);
+	      return;
+	    }
+	}
+    }
+
+  readonly_data_section ();
+}
+
+/* Tell assembler to switch to the section for constant merging.  */
+
+void
+mergeable_constant_section (enum machine_mode mode ATTRIBUTE_UNUSED,
+			    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED,
+			    unsigned int flags ATTRIBUTE_UNUSED)
+{
+  unsigned int modesize = GET_MODE_BITSIZE (mode);
+
+  if (HAVE_GAS_SHF_MERGE && flag_merge_constants
+      && mode != VOIDmode
+      && mode != BLKmode
+      && modesize <= align
+      && align >= 8
+      && align <= 256
+      && (align & (align - 1)) == 0)
+    {
+      char name[24];
+
+      sprintf (name, ".rodata.cst%d", (int) (align / 8));
+      flags |= (align / 8) | SECTION_MERGE;
+      named_section_flags (name, flags);
+      return;
+    }
+
+  readonly_data_section ();
+}
+
+/* Given NAME, a putative register name, discard any customary prefixes.  */
+
+static const char *
+strip_reg_name (const char *name)
+{
+#ifdef REGISTER_PREFIX
+  if (!strncmp (name, REGISTER_PREFIX, strlen (REGISTER_PREFIX)))
+    name += strlen (REGISTER_PREFIX);
+#endif
+  if (name[0] == '%' || name[0] == '#')
+    name++;
+  return name;
+}
+
+/* Decode an `asm' spec for a declaration as a register name.
+   Return the register number, or -1 if nothing specified,
+   or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,
+   or -3 if ASMSPEC is `cc' and is not recognized,
+   or -4 if ASMSPEC is `memory' and is not recognized.
+   Accept an exact spelling or a decimal number.
+   Prefixes such as % are optional.  */
+
+int
+decode_reg_name (const char *asmspec)
+{
+  if (asmspec != 0)
+    {
+      int i;
+
+      /* Get rid of confusing prefixes.  */
+      asmspec = strip_reg_name (asmspec);
+
+      /* Allow a decimal number as a "register name".  */
+      for (i = strlen (asmspec) - 1; i >= 0; i--)
+	if (! ISDIGIT (asmspec[i]))
+	  break;
+      if (asmspec[0] != 0 && i < 0)
+	{
+	  i = atoi (asmspec);
+	  if (i < FIRST_PSEUDO_REGISTER && i >= 0)
+	    return i;
+	  else
+	    return -2;
+	}
+
+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+	if (reg_names[i][0]
+	    && ! strcmp (asmspec, strip_reg_name (reg_names[i])))
+	  return i;
+
+#ifdef ADDITIONAL_REGISTER_NAMES
+      {
+	static const struct { const char *const name; const int number; } table[]
+	  = ADDITIONAL_REGISTER_NAMES;
+
+	for (i = 0; i < (int) ARRAY_SIZE (table); i++)
+	  if (! strcmp (asmspec, table[i].name))
+	    return table[i].number;
+      }
+#endif /* ADDITIONAL_REGISTER_NAMES */
+
+      if (!strcmp (asmspec, "memory"))
+	return -4;
+
+      if (!strcmp (asmspec, "cc"))
+	return -3;
+
+      return -2;
+    }
+
+  return -1;
+}
+
+/* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should
+   have static storage duration.  In other words, it should not be an
+   automatic variable, including PARM_DECLs.
+
+   There is, however, one exception: this function handles variables
+   explicitly placed in a particular register by the user.
+
+   ASMSPEC, if not 0, is the string which the user specified as the
+   assembler symbol name.
+
+   This is never called for PARM_DECL nodes.  */
+
+void
+make_decl_rtl (tree decl, const char *asmspec)
+{
+  const char *name = 0;
+  int reg_number;
+  rtx x;
+
+  /* Check that we are not being given an automatic variable.  */
+  /* A weak alias has TREE_PUBLIC set but not the other bits.  */
+  if (TREE_CODE (decl) == PARM_DECL
+      || TREE_CODE (decl) == RESULT_DECL
+      || (TREE_CODE (decl) == VAR_DECL
+	  && !TREE_STATIC (decl)
+	  && !TREE_PUBLIC (decl)
+	  && !DECL_EXTERNAL (decl)
+	  && !DECL_REGISTER (decl)))
+    abort ();
+  /* And that we were not given a type or a label.  */
+  else if (TREE_CODE (decl) == TYPE_DECL
+	   || TREE_CODE (decl) == LABEL_DECL)
+    abort ();
+
+  /* For a duplicate declaration, we can be called twice on the
+     same DECL node.  Don't discard the RTL already made.  */
+  if (DECL_RTL_SET_P (decl))
+    {
+      /* If the old RTL had the wrong mode, fix the mode.  */
+      if (GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))
+	SET_DECL_RTL (decl, adjust_address_nv (DECL_RTL (decl),
+					       DECL_MODE (decl), 0));
+
+      /* ??? Another way to do this would be to maintain a hashed
+	 table of such critters.  Instead of adding stuff to a DECL
+	 to give certain attributes to it, we could use an external
+	 hash map from DECL to set of attributes.  */
+
+      /* Let the target reassign the RTL if it wants.
+	 This is necessary, for example, when one machine specific
+	 decl attribute overrides another.  */
+      (* targetm.encode_section_info) (decl, DECL_RTL (decl), false);
+      return;
+    }
+
+  reg_number = decode_reg_name (asmspec);
+  if (reg_number == -2)
+    {
+      /* ASMSPEC is given, and not the name of a register.  Mark the
+	 name with a star so assemble_name won't munge it.  */
+      char *starred = alloca (strlen (asmspec) + 2);
+      starred[0] = '*';
+      strcpy (starred + 1, asmspec);
+      change_decl_assembler_name (decl, get_identifier (starred));
+    }
+
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+
+  if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))
+    {
+      /* First detect errors in declaring global registers.  */
+      if (reg_number == -1)
+	error ("%Jregister name not specified for '%D'", decl, decl);
+      else if (reg_number < 0)
+	error ("%Jinvalid register name for '%D'", decl, decl);
+      else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)
+	error ("%Jdata type of '%D' isn't suitable for a register",
+	       decl, decl);
+      else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))
+	error ("%Jregister specified for '%D' isn't suitable for data type",
+               decl, decl);
+      /* Now handle properly declared static register variables.  */
+      else
+	{
+	  int nregs;
+
+	  if (DECL_INITIAL (decl) != 0 && TREE_STATIC (decl))
+	    {
+	      DECL_INITIAL (decl) = 0;
+	      error ("global register variable has initial value");
+	    }
+	  if (TREE_THIS_VOLATILE (decl))
+	    warning ("volatile register variables don't work as you might wish");
+
+	  /* If the user specified one of the eliminables registers here,
+	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable
+	     confused with that register and be eliminated.  This usage is
+	     somewhat suspect...  */
+
+	  SET_DECL_RTL (decl, gen_rtx_raw_REG (DECL_MODE (decl), reg_number));
+	  ORIGINAL_REGNO (DECL_RTL (decl)) = reg_number;
+	  REG_USERVAR_P (DECL_RTL (decl)) = 1;
+
+	  if (TREE_STATIC (decl))
+	    {
+	      /* Make this register global, so not usable for anything
+		 else.  */
+#ifdef ASM_DECLARE_REGISTER_GLOBAL
+	      ASM_DECLARE_REGISTER_GLOBAL (asm_out_file, decl, reg_number, name);
+#endif
+	      nregs = HARD_REGNO_NREGS (reg_number, DECL_MODE (decl));
+	      while (nregs > 0)
+		globalize_reg (reg_number + --nregs);
+	    }
+
+	  /* As a register variable, it has no section.  */
+	  return;
+	}
+    }
+
+  /* Now handle ordinary static variables and functions (in memory).
+     Also handle vars declared register invalidly.  */
+
+  if (reg_number >= 0 || reg_number == -3)
+    error ("%Jregister name given for non-register variable '%D'", decl, decl);
+
+  /* Specifying a section attribute on a variable forces it into a
+     non-.bss section, and thus it cannot be common.  */
+  if (TREE_CODE (decl) == VAR_DECL
+      && DECL_SECTION_NAME (decl) != NULL_TREE
+      && DECL_INITIAL (decl) == NULL_TREE
+      && DECL_COMMON (decl))
+    DECL_COMMON (decl) = 0;
+
+  /* Variables can't be both common and weak.  */
+  if (TREE_CODE (decl) == VAR_DECL && DECL_WEAK (decl))
+    DECL_COMMON (decl) = 0;
+
+  x = gen_rtx_SYMBOL_REF (Pmode, name);
+  SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);
+  SYMBOL_REF_DECL (x) = decl;
+
+  x = gen_rtx_MEM (DECL_MODE (decl), x);
+  if (TREE_CODE (decl) != FUNCTION_DECL)
+    set_mem_attributes (x, decl, 1);
+  SET_DECL_RTL (decl, x);
+
+  /* Optionally set flags or add text to the name to record information
+     such as that it is a function name.
+     If the name is changed, the macro ASM_OUTPUT_LABELREF
+     will have to know how to strip this information.  */
+  (* targetm.encode_section_info) (decl, DECL_RTL (decl), true);
+}
+
+/* Make the rtl for variable VAR be volatile.
+   Use this only for static variables.  */
+
+void
+make_var_volatile (tree var)
+{
+  if (GET_CODE (DECL_RTL (var)) != MEM)
+    abort ();
+
+  MEM_VOLATILE_P (DECL_RTL (var)) = 1;
+}
+
+/* Output a string of literal assembler code
+   for an `asm' keyword used between functions.  */
+
+void
+assemble_asm (tree string)
+{
+  app_enable ();
+
+  if (TREE_CODE (string) == ADDR_EXPR)
+    string = TREE_OPERAND (string, 0);
+
+  fprintf (asm_out_file, "\t%s\n", TREE_STRING_POINTER (string));
+}
+
+/* Record an element in the table of global destructors.  SYMBOL is
+   a SYMBOL_REF of the function to be called; PRIORITY is a number
+   between 0 and MAX_INIT_PRIORITY.  */
+
+void
+default_stabs_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)
+{
+  /* Tell GNU LD that this is part of the static destructor set.
+     This will work for any system that uses stabs, most usefully
+     aout systems.  */
+  fprintf (asm_out_file, "%s\"___DTOR_LIST__\",22,0,0,", ASM_STABS_OP);
+  assemble_name (asm_out_file, XSTR (symbol, 0));
+  fputc ('\n', asm_out_file);
+}
+
+void
+default_named_section_asm_out_destructor (rtx symbol, int priority)
+{
+  const char *section = ".dtors";
+  char buf[16];
+
+  /* ??? This only works reliably with the GNU linker.  */
+  if (priority != DEFAULT_INIT_PRIORITY)
+    {
+      sprintf (buf, ".dtors.%.5u",
+	       /* Invert the numbering so the linker puts us in the proper
+		  order; constructors are run from right to left, and the
+		  linker sorts in increasing order.  */
+	       MAX_INIT_PRIORITY - priority);
+      section = buf;
+    }
+
+  named_section_flags (section, SECTION_WRITE);
+  assemble_align (POINTER_SIZE);
+  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+}
+
+#ifdef DTORS_SECTION_ASM_OP
+void
+dtors_section (void)
+{
+  if (in_section != in_dtors)
+    {
+      in_section = in_dtors;
+      fputs (DTORS_SECTION_ASM_OP, asm_out_file);
+      fputc ('\n', asm_out_file);
+    }
+}
+
+void
+default_dtor_section_asm_out_destructor (rtx symbol,
+					 int priority ATTRIBUTE_UNUSED)
+{
+  dtors_section ();
+  assemble_align (POINTER_SIZE);
+  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+}
+#endif
+
+/* Likewise for global constructors.  */
+
+void
+default_stabs_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)
+{
+  /* Tell GNU LD that this is part of the static destructor set.
+     This will work for any system that uses stabs, most usefully
+     aout systems.  */
+  fprintf (asm_out_file, "%s\"___CTOR_LIST__\",22,0,0,", ASM_STABS_OP);
+  assemble_name (asm_out_file, XSTR (symbol, 0));
+  fputc ('\n', asm_out_file);
+}
+
+void
+default_named_section_asm_out_constructor (rtx symbol, int priority)
+{
+  const char *section = ".ctors";
+  char buf[16];
+
+  /* ??? This only works reliably with the GNU linker.  */
+  if (priority != DEFAULT_INIT_PRIORITY)
+    {
+      sprintf (buf, ".ctors.%.5u",
+	       /* Invert the numbering so the linker puts us in the proper
+		  order; constructors are run from right to left, and the
+		  linker sorts in increasing order.  */
+	       MAX_INIT_PRIORITY - priority);
+      section = buf;
+    }
+
+  named_section_flags (section, SECTION_WRITE);
+  assemble_align (POINTER_SIZE);
+  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+}
+
+#ifdef CTORS_SECTION_ASM_OP
+void
+ctors_section (void)
+{
+  if (in_section != in_ctors)
+    {
+      in_section = in_ctors;
+      fputs (CTORS_SECTION_ASM_OP, asm_out_file);
+      fputc ('\n', asm_out_file);
+    }
+}
+
+void
+default_ctor_section_asm_out_constructor (rtx symbol,
+					  int priority ATTRIBUTE_UNUSED)
+{
+  ctors_section ();
+  assemble_align (POINTER_SIZE);
+  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);
+}
+#endif
+
+/* CONSTANT_POOL_BEFORE_FUNCTION may be defined as an expression with
+   a nonzero value if the constant pool should be output before the
+   start of the function, or a zero value if the pool should output
+   after the end of the function.  The default is to put it before the
+   start.  */
+
+#ifndef CONSTANT_POOL_BEFORE_FUNCTION
+#define CONSTANT_POOL_BEFORE_FUNCTION 1
+#endif
+
+/* DECL is an object (either VAR_DECL or FUNCTION_DECL) which is going
+   to be output to assembler.
+   Set first_global_object_name and weak_global_object_name as appropriate.  */
+
+void
+notice_global_symbol (tree decl)
+{
+  const char **type = &first_global_object_name;
+
+  if (first_global_object_name
+      || !TREE_PUBLIC (decl) || DECL_EXTERNAL (decl)
+      || !DECL_NAME (decl)
+      || (TREE_CODE (decl) != FUNCTION_DECL
+	  && (TREE_CODE (decl) != VAR_DECL
+	      || (DECL_COMMON (decl)
+		  && (DECL_INITIAL (decl) == 0
+		      || DECL_INITIAL (decl) == error_mark_node))))
+      || GET_CODE (DECL_RTL (decl)) != MEM)
+    return;
+
+  /* We win when global object is found, but it is usefull to know about weak
+     symbol as well so we can produce nicer unique names.  */
+  if (DECL_WEAK (decl) || DECL_ONE_ONLY (decl))
+    type = &weak_global_object_name;
+
+  if (!*type)
+    {
+      const char *p;
+      char *name;
+      rtx decl_rtl = DECL_RTL (decl);
+
+      p = (* targetm.strip_name_encoding) (XSTR (XEXP (decl_rtl, 0), 0));
+      name = xstrdup (p);
+
+      *type = name;
+    }
+}
+
+/* Output assembler code for the constant pool of a function and associated
+   with defining the name of the function.  DECL describes the function.
+   NAME is the function's name.  For the constant pool, we use the current
+   constant pool data.  */
+
+void
+assemble_start_function (tree decl, const char *fnname)
+{
+  int align;
+
+  /* The following code does not need preprocessing in the assembler.  */
+
+  app_disable ();
+
+  if (CONSTANT_POOL_BEFORE_FUNCTION)
+    output_constant_pool (fnname, decl);
+
+  resolve_unique_section (decl, 0, flag_function_sections);
+  function_section (decl);
+
+  /* Tell assembler to move to target machine's alignment for functions.  */
+  align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);
+  if (align < force_align_functions_log)
+    align = force_align_functions_log;
+  if (align > 0)
+    {
+      ASM_OUTPUT_ALIGN (asm_out_file, align);
+    }
+
+  /* Handle a user-specified function alignment.
+     Note that we still need to align to FUNCTION_BOUNDARY, as above,
+     because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */
+  if (align_functions_log > align
+      && cfun->function_frequency != FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)
+    {
+#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN
+      ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,
+				 align_functions_log, align_functions - 1);
+#else
+      ASM_OUTPUT_ALIGN (asm_out_file, align_functions_log);
+#endif
+    }
+
+#ifdef ASM_OUTPUT_FUNCTION_PREFIX
+  ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);
+#endif
+
+  (*debug_hooks->begin_function) (decl);
+
+  /* Make function name accessible from other files, if appropriate.  */
+
+  if (TREE_PUBLIC (decl))
+    {
+      notice_global_symbol (decl);
+
+      globalize_decl (decl);
+
+      maybe_assemble_visibility (decl);
+    }
+
+  /* Do any machine/system dependent processing of the function name.  */
+#ifdef ASM_DECLARE_FUNCTION_NAME
+  ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);
+#else
+  /* Standard thing is just output label for the function.  */
+  ASM_OUTPUT_LABEL (asm_out_file, fnname);
+#endif /* ASM_DECLARE_FUNCTION_NAME */
+}
+
+/* Output assembler code associated with defining the size of the
+   function.  DECL describes the function.  NAME is the function's name.  */
+
+void
+assemble_end_function (tree decl, const char *fnname)
+{
+#ifdef ASM_DECLARE_FUNCTION_SIZE
+  ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);
+#endif
+  if (! CONSTANT_POOL_BEFORE_FUNCTION)
+    {
+      output_constant_pool (fnname, decl);
+      function_section (decl);	/* need to switch back */
+    }
+}
+
+/* Assemble code to leave SIZE bytes of zeros.  */
+
+void
+assemble_zeros (unsigned HOST_WIDE_INT size)
+{
+  /* Do no output if -fsyntax-only.  */
+  if (flag_syntax_only)
+    return;
+
+#ifdef ASM_NO_SKIP_IN_TEXT
+  /* The `space' pseudo in the text section outputs nop insns rather than 0s,
+     so we must output 0s explicitly in the text section.  */
+  if (ASM_NO_SKIP_IN_TEXT && in_text_section ())
+    {
+      unsigned HOST_WIDE_INT i;
+      for (i = 0; i < size; i++)
+	assemble_integer (const0_rtx, 1, BITS_PER_UNIT, 1);
+    }
+  else
+#endif
+    if (size > 0)
+      ASM_OUTPUT_SKIP (asm_out_file, size);
+}
+
+/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
+
+void
+assemble_align (int align)
+{
+  if (align > BITS_PER_UNIT)
+    {
+      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));
+    }
+}
+
+/* Assemble a string constant with the specified C string as contents.  */
+
+void
+assemble_string (const char *p, int size)
+{
+  int pos = 0;
+  int maximum = 2000;
+
+  /* If the string is very long, split it up.  */
+
+  while (pos < size)
+    {
+      int thissize = size - pos;
+      if (thissize > maximum)
+	thissize = maximum;
+
+      ASM_OUTPUT_ASCII (asm_out_file, p, thissize);
+
+      pos += thissize;
+      p += thissize;
+    }
+}
+
+
+#if defined  ASM_OUTPUT_ALIGNED_DECL_LOCAL
+#define ASM_EMIT_LOCAL(decl, name, size, rounded) \
+  ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name, size, DECL_ALIGN (decl))
+#else
+#if defined  ASM_OUTPUT_ALIGNED_LOCAL
+#define ASM_EMIT_LOCAL(decl, name, size, rounded) \
+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl))
+#else
+#define ASM_EMIT_LOCAL(decl, name, size, rounded) \
+  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded)
+#endif
+#endif
+
+#if defined ASM_OUTPUT_ALIGNED_BSS
+#define ASM_EMIT_BSS(decl, name, size, rounded) \
+  ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl))
+#else
+#if defined ASM_OUTPUT_BSS
+#define ASM_EMIT_BSS(decl, name, size, rounded) \
+  ASM_OUTPUT_BSS (asm_out_file, decl, name, size, rounded)
+#else
+#undef  ASM_EMIT_BSS
+#endif
+#endif
+
+#if defined ASM_OUTPUT_ALIGNED_DECL_COMMON
+#define ASM_EMIT_COMMON(decl, name, size, rounded) \
+  ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name, size, DECL_ALIGN (decl))
+#else
+#if defined ASM_OUTPUT_ALIGNED_COMMON
+#define ASM_EMIT_COMMON(decl, name, size, rounded) \
+  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl))
+#else
+#define ASM_EMIT_COMMON(decl, name, size, rounded) \
+  ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded)
+#endif
+#endif
+
+static bool
+asm_emit_uninitialised (tree decl, const char *name,
+			unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,
+			unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)
+{
+  enum
+  {
+    asm_dest_common,
+    asm_dest_bss,
+    asm_dest_local
+  }
+  destination = asm_dest_local;
+
+  /* ??? We should handle .bss via select_section mechanisms rather than
+     via special target hooks.  That would eliminate this special case.  */
+  if (TREE_PUBLIC (decl))
+    {
+      if (!DECL_COMMON (decl))
+#ifdef ASM_EMIT_BSS
+	destination = asm_dest_bss;
+#else
+	return false;
+#endif
+      else
+	destination = asm_dest_common;
+    }
+
+  if (destination == asm_dest_bss)
+    globalize_decl (decl);
+  resolve_unique_section (decl, 0, flag_data_sections);
+
+  if (flag_shared_data)
+    {
+      switch (destination)
+	{
+#ifdef ASM_OUTPUT_SHARED_BSS
+	case asm_dest_bss:
+	  ASM_OUTPUT_SHARED_BSS (asm_out_file, decl, name, size, rounded);
+	  return;
+#endif
+#ifdef ASM_OUTPUT_SHARED_COMMON
+	case asm_dest_common:
+	  ASM_OUTPUT_SHARED_COMMON (asm_out_file, name, size, rounded);
+	  return;
+#endif
+#ifdef ASM_OUTPUT_SHARED_LOCAL
+	case asm_dest_local:
+	  ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);
+	  return;
+#endif
+	default:
+	  break;
+	}
+    }
+
+  switch (destination)
+    {
+#ifdef ASM_EMIT_BSS
+    case asm_dest_bss:
+      ASM_EMIT_BSS (decl, name, size, rounded);
+      break;
+#endif
+    case asm_dest_common:
+      ASM_EMIT_COMMON (decl, name, size, rounded);
+      break;
+    case asm_dest_local:
+      ASM_EMIT_LOCAL (decl, name, size, rounded);
+      break;
+    default:
+      abort ();
+    }
+
+  return true;
+}
+
+/* Assemble everything that is needed for a variable or function declaration.
+   Not used for automatic variables, and not used for function definitions.
+   Should not be called for variables of incomplete structure type.
+
+   TOP_LEVEL is nonzero if this variable has file scope.
+   AT_END is nonzero if this is the special handling, at end of compilation,
+   to define things that have had only tentative definitions.
+   DONT_OUTPUT_DATA if nonzero means don't actually output the
+   initial value (that will be done by the caller).  */
+
+void
+assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,
+		   int at_end ATTRIBUTE_UNUSED, int dont_output_data)
+{
+  const char *name;
+  unsigned int align;
+  int reloc = 0;
+  rtx decl_rtl;
+
+  if (lang_hooks.decls.prepare_assemble_variable)
+    (*lang_hooks.decls.prepare_assemble_variable) (decl);
+
+  last_assemble_variable_decl = 0;
+
+  /* Normally no need to say anything here for external references,
+     since assemble_external is called by the language-specific code
+     when a declaration is first seen.  */
+
+  if (DECL_EXTERNAL (decl))
+    return;
+
+  /* Output no assembler code for a function declaration.
+     Only definitions of functions output anything.  */
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    return;
+
+  /* Do nothing for global register variables.  */
+  if (DECL_RTL_SET_P (decl) && GET_CODE (DECL_RTL (decl)) == REG)
+    {
+      TREE_ASM_WRITTEN (decl) = 1;
+      return;
+    }
+
+  /* If type was incomplete when the variable was declared,
+     see if it is complete now.  */
+
+  if (DECL_SIZE (decl) == 0)
+    layout_decl (decl, 0);
+
+  /* Still incomplete => don't allocate it; treat the tentative defn
+     (which is what it must have been) as an `extern' reference.  */
+
+  if (!dont_output_data && DECL_SIZE (decl) == 0)
+    {
+      error ("%Jstorage size of `%D' isn't known", decl, decl);
+      TREE_ASM_WRITTEN (decl) = 1;
+      return;
+    }
+
+  /* The first declaration of a variable that comes through this function
+     decides whether it is global (in C, has external linkage)
+     or local (in C, has internal linkage).  So do nothing more
+     if this function has already run.  */
+
+  if (TREE_ASM_WRITTEN (decl))
+    return;
+
+  /* Make sure targetm.encode_section_info is invoked before we set
+     ASM_WRITTEN.  */
+  decl_rtl = DECL_RTL (decl);
+
+  TREE_ASM_WRITTEN (decl) = 1;
+
+  /* Do no output if -fsyntax-only.  */
+  if (flag_syntax_only)
+    return;
+
+  app_disable ();
+
+  if (! dont_output_data
+      && ! host_integerp (DECL_SIZE_UNIT (decl), 1))
+    {
+      error ("%Jsize of variable '%D' is too large", decl, decl);
+      return;
+    }
+
+  name = XSTR (XEXP (decl_rtl, 0), 0);
+  if (TREE_PUBLIC (decl) && DECL_NAME (decl))
+    notice_global_symbol (decl);
+
+  /* Compute the alignment of this data.  */
+
+  align = DECL_ALIGN (decl);
+
+  /* In the case for initialing an array whose length isn't specified,
+     where we have not yet been able to do the layout,
+     figure out the proper alignment now.  */
+  if (dont_output_data && DECL_SIZE (decl) == 0
+      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
+    align = MAX (align, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));
+
+  /* Some object file formats have a maximum alignment which they support.
+     In particular, a.out format supports a maximum alignment of 4.  */
+#ifndef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT
+#endif
+  if (align > MAX_OFILE_ALIGNMENT)
+    {
+      warning ("%Jalignment of '%D' is greater than maximum object "
+               "file alignment.  Using %d", decl, decl,
+	       MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);
+      align = MAX_OFILE_ALIGNMENT;
+    }
+
+  /* On some machines, it is good to increase alignment sometimes.  */
+  if (! DECL_USER_ALIGN (decl))
+    {
+#ifdef DATA_ALIGNMENT
+      align = DATA_ALIGNMENT (TREE_TYPE (decl), align);
+#endif
+#ifdef CONSTANT_ALIGNMENT
+      if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)
+	align = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);
+#endif
+    }
+
+  /* Reset the alignment in case we have made it tighter, so we can benefit
+     from it in get_pointer_alignment.  */
+  DECL_ALIGN (decl) = align;
+  set_mem_align (decl_rtl, align);
+
+  if (TREE_PUBLIC (decl))
+    maybe_assemble_visibility (decl);
+
+  /* Output any data that we will need to use the address of.  */
+  if (DECL_INITIAL (decl) == error_mark_node)
+    reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;
+  else if (DECL_INITIAL (decl))
+    {
+      reloc = compute_reloc_for_constant (DECL_INITIAL (decl));
+      output_addressed_constants (DECL_INITIAL (decl));
+    }
+  resolve_unique_section (decl, reloc, flag_data_sections);
+
+  /* Handle uninitialized definitions.  */
+
+  /* If the decl has been given an explicit section name, then it
+     isn't common, and shouldn't be handled as such.  */
+  if (DECL_SECTION_NAME (decl) || dont_output_data)
+    ;
+  /* We don't implement common thread-local data at present.  */
+  else if (DECL_THREAD_LOCAL (decl))
+    {
+      if (DECL_COMMON (decl))
+	sorry ("thread-local COMMON data not implemented");
+    }
+  else if (DECL_INITIAL (decl) == 0
+	   || DECL_INITIAL (decl) == error_mark_node
+	   || (flag_zero_initialized_in_bss
+	       /* Leave constant zeroes in .rodata so they can be shared.  */
+	       && !TREE_READONLY (decl)
+	       && initializer_zerop (DECL_INITIAL (decl))))
+    {
+      unsigned HOST_WIDE_INT size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);
+      unsigned HOST_WIDE_INT rounded = size;
+
+      /* Don't allocate zero bytes of common,
+	 since that means "undefined external" in the linker.  */
+      if (size == 0)
+	rounded = 1;
+
+      /* Round size up to multiple of BIGGEST_ALIGNMENT bits
+	 so that each uninitialized object starts on such a boundary.  */
+      rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;
+      rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)
+		 * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));
+
+#if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)
+      if ((unsigned HOST_WIDE_INT) DECL_ALIGN (decl) / BITS_PER_UNIT > rounded)
+	warning ("%Jrequested alignment for '%D' is greater than "
+                 "implemented alignment of %d", decl, decl, rounded);
+#endif
+
+      /* If the target cannot output uninitialized but not common global data
+	 in .bss, then we have to use .data, so fall through.  */
+      if (asm_emit_uninitialised (decl, name, size, rounded))
+	return;
+    }
+
+  /* Handle initialized definitions.
+     Also handle uninitialized global definitions if -fno-common and the
+     target doesn't support ASM_OUTPUT_BSS.  */
+
+  /* First make the assembler name(s) global if appropriate.  */
+  if (TREE_PUBLIC (decl) && DECL_NAME (decl))
+    globalize_decl (decl);
+
+  /* Switch to the appropriate section.  */
+  variable_section (decl, reloc);
+
+  /* dbxout.c needs to know this.  */
+  if (in_text_section ())
+    DECL_IN_TEXT_SECTION (decl) = 1;
+
+  /* Output the alignment of this data.  */
+  if (align > BITS_PER_UNIT)
+    {
+      ASM_OUTPUT_ALIGN (asm_out_file,
+			floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT));
+    }
+
+  /* Do any machine/system dependent processing of the object.  */
+#ifdef ASM_DECLARE_OBJECT_NAME
+  last_assemble_variable_decl = decl;
+  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);
+#else
+  /* Standard thing is just output label for the object.  */
+  ASM_OUTPUT_LABEL (asm_out_file, name);
+#endif /* ASM_DECLARE_OBJECT_NAME */
+
+  if (!dont_output_data)
+    {
+      if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node)
+	/* Output the actual data.  */
+	output_constant (DECL_INITIAL (decl),
+			 tree_low_cst (DECL_SIZE_UNIT (decl), 1),
+			 align);
+      else
+	/* Leave space for it.  */
+	assemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));
+    }
+}
+
+/* Return 1 if type TYPE contains any pointers.  */
+
+static int
+contains_pointers_p (tree type)
+{
+  switch (TREE_CODE (type))
+    {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+      /* I'm not sure whether OFFSET_TYPE needs this treatment,
+	 so I'll play safe and return 1.  */
+    case OFFSET_TYPE:
+      return 1;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      {
+	tree fields;
+	/* For a type that has fields, see if the fields have pointers.  */
+	for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))
+	  if (TREE_CODE (fields) == FIELD_DECL
+	      && contains_pointers_p (TREE_TYPE (fields)))
+	    return 1;
+	return 0;
+      }
+
+    case ARRAY_TYPE:
+      /* An array type contains pointers if its element type does.  */
+      return contains_pointers_p (TREE_TYPE (type));
+
+    default:
+      return 0;
+    }
+}
+
+#ifdef ASM_OUTPUT_EXTERNAL
+/* True if DECL is a function decl for which no out-of-line copy exists.
+   It is assumed that DECL's assembler name has been set.  */
+
+static bool
+incorporeal_function_p (tree decl)
+{
+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))
+    {
+      const char *name;
+
+      if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL
+	  && DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA)
+	return true;
+
+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+      if (strncmp (name, "__builtin_", strlen ("__builtin_")) == 0)
+	return true;
+    }
+  return false;
+}
+#endif
+
+/* Output something to declare an external symbol to the assembler.
+   (Most assemblers don't need this, so we normally output nothing.)
+   Do nothing if DECL is not external.  */
+
+void
+assemble_external (tree decl ATTRIBUTE_UNUSED)
+{
+  /* Because most platforms do not define ASM_OUTPUT_EXTERNAL, the
+     main body of this code is only rarely exercised.  To provide some
+     testing, on all platforms, we make sure that the ASM_OUT_FILE is
+     open.  If it's not, we should not be calling this function.  */
+  if (!asm_out_file)
+    abort ();
+
+#ifdef ASM_OUTPUT_EXTERNAL
+  if (DECL_P (decl) && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))
+    {
+      rtx rtl = DECL_RTL (decl);
+
+      if (GET_CODE (rtl) == MEM && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF
+	  && !SYMBOL_REF_USED (XEXP (rtl, 0))
+	  && !incorporeal_function_p (decl))
+	{
+	  /* Some systems do require some output.  */
+	  SYMBOL_REF_USED (XEXP (rtl, 0)) = 1;
+	  ASM_OUTPUT_EXTERNAL (asm_out_file, decl, XSTR (XEXP (rtl, 0), 0));
+	}
+    }
+#endif
+}
+
+/* Similar, for calling a library function FUN.  */
+
+void
+assemble_external_libcall (rtx fun)
+{
+  /* Declare library function name external when first used, if nec.  */
+  if (! SYMBOL_REF_USED (fun))
+    {
+      SYMBOL_REF_USED (fun) = 1;
+      (*targetm.asm_out.external_libcall) (fun);
+    }
+}
+
+/* Assemble a label named NAME.  */
+
+void
+assemble_label (const char *name)
+{
+  ASM_OUTPUT_LABEL (asm_out_file, name);
+}
+
+/* Set the symbol_referenced flag for ID and notify callgraph code.  */
+void
+mark_referenced (tree id)
+{
+  if (!TREE_SYMBOL_REFERENCED (id))
+    {
+      struct cgraph_node *node;
+      struct cgraph_varpool_node *vnode;
+
+      if (!cgraph_global_info_ready)
+	{
+	  node = cgraph_node_for_identifier (id);
+	  if (node)
+	    cgraph_mark_needed_node (node);
+	}
+
+      vnode = cgraph_varpool_node_for_identifier (id);
+      if (vnode)
+	cgraph_varpool_mark_needed_node (vnode);
+    }
+  TREE_SYMBOL_REFERENCED (id) = 1;
+}
+
+/* Output to FILE a reference to the assembler name of a C-level name NAME.
+   If NAME starts with a *, the rest of NAME is output verbatim.
+   Otherwise NAME is transformed in an implementation-defined way
+   (usually by the addition of an underscore).
+   Many macros in the tm file are defined to call this function.  */
+
+void
+assemble_name (FILE *file, const char *name)
+{
+  const char *real_name;
+  tree id;
+
+  real_name = (* targetm.strip_name_encoding) (name);
+
+  id = maybe_get_identifier (real_name);
+  if (id)
+    mark_referenced (id);
+
+  if (name[0] == '*')
+    fputs (&name[1], file);
+  else
+    ASM_OUTPUT_LABELREF (file, name);
+}
+
+/* Allocate SIZE bytes writable static space with a gensym name
+   and return an RTX to refer to its address.  */
+
+rtx
+assemble_static_space (unsigned HOST_WIDE_INT size)
+{
+  char name[12];
+  const char *namestring;
+  rtx x;
+
+#if 0
+  if (flag_shared_data)
+    data_section ();
+#endif
+
+  ASM_GENERATE_INTERNAL_LABEL (name, "LF", const_labelno);
+  ++const_labelno;
+  namestring = ggc_strdup (name);
+
+  x = gen_rtx_SYMBOL_REF (Pmode, namestring);
+  SYMBOL_REF_FLAGS (x) = SYMBOL_FLAG_LOCAL;
+
+#ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL
+  ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name, size,
+				 BIGGEST_ALIGNMENT);
+#else
+#ifdef ASM_OUTPUT_ALIGNED_LOCAL
+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);
+#else
+  {
+    /* Round size up to multiple of BIGGEST_ALIGNMENT bits
+       so that each uninitialized object starts on such a boundary.  */
+    /* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL.  */
+    unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED
+      = ((size + (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1)
+	 / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)
+	 * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));
+    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);
+  }
+#endif
+#endif
+  return x;
+}
+
+/* Assemble the static constant template for function entry trampolines.
+   This is done at most once per compilation.
+   Returns an RTX for the address of the template.  */
+
+#ifdef TRAMPOLINE_TEMPLATE
+rtx
+assemble_trampoline_template (void)
+{
+  char label[256];
+  const char *name;
+  int align;
+  rtx symbol;
+
+  /* By default, put trampoline templates in read-only data section.  */
+
+#ifdef TRAMPOLINE_SECTION
+  TRAMPOLINE_SECTION ();
+#else
+  readonly_data_section ();
+#endif
+
+  /* Write the assembler code to define one.  */
+  align = floor_log2 (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT);
+  if (align > 0)
+    {
+      ASM_OUTPUT_ALIGN (asm_out_file, align);
+    }
+
+  (*targetm.asm_out.internal_label) (asm_out_file, "LTRAMP", 0);
+  TRAMPOLINE_TEMPLATE (asm_out_file);
+
+  /* Record the rtl to refer to it.  */
+  ASM_GENERATE_INTERNAL_LABEL (label, "LTRAMP", 0);
+  name = ggc_strdup (label);
+  symbol = gen_rtx_SYMBOL_REF (Pmode, name);
+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;
+
+  return symbol;
+}
+#endif
+
+/* A and B are either alignments or offsets.  Return the minimum alignment
+   that may be assumed after adding the two together.  */
+
+static inline unsigned
+min_align (unsigned int a, unsigned int b)
+{
+  return (a | b) & -(a | b);
+}
+
+/* Return the assembler directive for creating a given kind of integer
+   object.  SIZE is the number of bytes in the object and ALIGNED_P
+   indicates whether it is known to be aligned.  Return NULL if the
+   assembly dialect has no such directive.
+
+   The returned string should be printed at the start of a new line and
+   be followed immediately by the object's initial value.  */
+
+const char *
+integer_asm_op (int size, int aligned_p)
+{
+  struct asm_int_op *ops;
+
+  if (aligned_p)
+    ops = &targetm.asm_out.aligned_op;
+  else
+    ops = &targetm.asm_out.unaligned_op;
+
+  switch (size)
+    {
+    case 1:
+      return targetm.asm_out.byte_op;
+    case 2:
+      return ops->hi;
+    case 4:
+      return ops->si;
+    case 8:
+      return ops->di;
+    case 16:
+      return ops->ti;
+    default:
+      return NULL;
+    }
+}
+
+/* Use directive OP to assemble an integer object X.  Print OP at the
+   start of the line, followed immediately by the value of X.  */
+
+void
+assemble_integer_with_op (const char *op, rtx x)
+{
+  fputs (op, asm_out_file);
+  output_addr_const (asm_out_file, x);
+  fputc ('\n', asm_out_file);
+}
+
+/* The default implementation of the asm_out.integer target hook.  */
+
+bool
+default_assemble_integer (rtx x ATTRIBUTE_UNUSED,
+			  unsigned int size ATTRIBUTE_UNUSED,
+			  int aligned_p ATTRIBUTE_UNUSED)
+{
+  const char *op = integer_asm_op (size, aligned_p);
+  return op && (assemble_integer_with_op (op, x), true);
+}
+
+/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is
+   the alignment of the integer in bits.  Return 1 if we were able to output
+   the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output
+   the constant.  */
+
+bool
+assemble_integer (rtx x, unsigned int size, unsigned int align, int force)
+{
+  int aligned_p;
+
+  aligned_p = (align >= MIN (size * BITS_PER_UNIT, BIGGEST_ALIGNMENT));
+
+  /* See if the target hook can handle this kind of object.  */
+  if ((*targetm.asm_out.integer) (x, size, aligned_p))
+    return true;
+
+  /* If the object is a multi-byte one, try splitting it up.  Split
+     it into words it if is multi-word, otherwise split it into bytes.  */
+  if (size > 1)
+    {
+      enum machine_mode omode, imode;
+      unsigned int subalign;
+      unsigned int subsize, i;
+
+      subsize = size > UNITS_PER_WORD? UNITS_PER_WORD : 1;
+      subalign = MIN (align, subsize * BITS_PER_UNIT);
+      omode = mode_for_size (subsize * BITS_PER_UNIT, MODE_INT, 0);
+      imode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);
+
+      for (i = 0; i < size; i += subsize)
+	{
+	  rtx partial = simplify_subreg (omode, x, imode, i);
+	  if (!partial || !assemble_integer (partial, subsize, subalign, 0))
+	    break;
+	}
+      if (i == size)
+	return true;
+
+      /* If we've printed some of it, but not all of it, there's no going
+	 back now.  */
+      if (i > 0)
+	abort ();
+    }
+
+  if (force)
+    abort ();
+
+  return false;
+}
+
+void
+assemble_real (REAL_VALUE_TYPE d, enum machine_mode mode, unsigned int align)
+{
+  long data[4];
+  int i;
+  int bitsize, nelts, nunits, units_per;
+
+  /* This is hairy.  We have a quantity of known size.  real_to_target
+     will put it into an array of *host* longs, 32 bits per element
+     (even if long is more than 32 bits).  We need to determine the
+     number of array elements that are occupied (nelts) and the number
+     of *target* min-addressable units that will be occupied in the
+     object file (nunits).  We cannot assume that 32 divides the
+     mode's bitsize (size * BITS_PER_UNIT) evenly.
+
+     size * BITS_PER_UNIT is used here to make sure that padding bits
+     (which might appear at either end of the value; real_to_target
+     will include the padding bits in its output array) are included.  */
+
+  nunits = GET_MODE_SIZE (mode);
+  bitsize = nunits * BITS_PER_UNIT;
+  nelts = CEIL (bitsize, 32);
+  units_per = 32 / BITS_PER_UNIT;
+
+  real_to_target (data, &d, mode);
+
+  /* Put out the first word with the specified alignment.  */
+  assemble_integer (GEN_INT (data[0]), MIN (nunits, units_per), align, 1);
+  nunits -= units_per;
+
+  /* Subsequent words need only 32-bit alignment.  */
+  align = min_align (align, 32);
+
+  for (i = 1; i < nelts; i++)
+    {
+      assemble_integer (GEN_INT (data[i]), MIN (nunits, units_per), align, 1);
+      nunits -= units_per;
+    }
+}
+
+/* Given an expression EXP with a constant value,
+   reduce it to the sum of an assembler symbol and an integer.
+   Store them both in the structure *VALUE.
+   Abort if EXP does not reduce.  */
+
+struct addr_const GTY(())
+{
+  rtx base;
+  HOST_WIDE_INT offset;
+};
+
+static void
+decode_addr_const (tree exp, struct addr_const *value)
+{
+  tree target = TREE_OPERAND (exp, 0);
+  int offset = 0;
+  rtx x;
+
+  while (1)
+    {
+      if (TREE_CODE (target) == COMPONENT_REF
+	  && host_integerp (byte_position (TREE_OPERAND (target, 1)), 0))
+
+	{
+	  offset += int_byte_position (TREE_OPERAND (target, 1));
+	  target = TREE_OPERAND (target, 0);
+	}
+      else if (TREE_CODE (target) == ARRAY_REF
+	       || TREE_CODE (target) == ARRAY_RANGE_REF)
+	{
+	  offset += (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (target)), 1)
+		     * tree_low_cst (TREE_OPERAND (target, 1), 0));
+	  target = TREE_OPERAND (target, 0);
+	}
+      else
+	break;
+    }
+
+  switch (TREE_CODE (target))
+    {
+    case VAR_DECL:
+    case FUNCTION_DECL:
+      x = DECL_RTL (target);
+      break;
+
+    case LABEL_DECL:
+      x = gen_rtx_MEM (FUNCTION_MODE,
+		       gen_rtx_LABEL_REF (VOIDmode, force_label_rtx (target)));
+      break;
+
+    case REAL_CST:
+    case STRING_CST:
+    case COMPLEX_CST:
+    case CONSTRUCTOR:
+    case INTEGER_CST:
+      x = output_constant_def (target, 1);
+      break;
+
+    default:
+      abort ();
+    }
+
+  if (GET_CODE (x) != MEM)
+    abort ();
+  x = XEXP (x, 0);
+
+  value->base = x;
+  value->offset = offset;
+}
+
+/* We do RTX_UNSPEC + XINT (blah), so nothing can go after RTX_UNSPEC.  */
+enum kind { RTX_UNKNOWN, RTX_DOUBLE, RTX_VECTOR, RTX_INT, RTX_UNSPEC };
+struct rtx_const GTY(())
+{
+  ENUM_BITFIELD(kind) kind : 16;
+  ENUM_BITFIELD(machine_mode) mode : 16;
+  union rtx_const_un {
+    REAL_VALUE_TYPE GTY ((tag ("4"))) du;
+    struct rtx_const_u_addr {
+      rtx base;
+      const char *symbol;
+      HOST_WIDE_INT offset;
+    } GTY ((tag ("1"))) addr;
+    struct rtx_const_u_di {
+      HOST_WIDE_INT high;
+      HOST_WIDE_INT low;
+    } GTY ((tag ("0"))) di;
+
+    /* The max vector size we have is 16 wide; two variants for
+       integral and floating point vectors.  */
+    struct rtx_const_int_vec {
+      HOST_WIDE_INT high;
+      HOST_WIDE_INT low;
+    } GTY ((tag ("2"))) int_vec[16];
+
+    REAL_VALUE_TYPE GTY ((tag ("3"))) fp_vec[8];
+
+  } GTY ((desc ("%1.kind >= RTX_INT"), descbits ("1"))) un;
+};
+
+/* Uniquize all constants that appear in memory.
+   Each constant in memory thus far output is recorded
+   in `const_desc_table'.  */
+
+struct constant_descriptor_tree GTY(())
+{
+  /* A MEM for the constant.  */
+  rtx rtl;
+
+  /* The value of the constant.  */
+  tree value;
+};
+
+static GTY((param_is (struct constant_descriptor_tree)))
+     htab_t const_desc_htab;
+
+static struct constant_descriptor_tree * build_constant_desc (tree);
+static void maybe_output_constant_def_contents (struct constant_descriptor_tree *, int);
+
+/* Compute a hash code for a constant expression.  */
+
+static hashval_t
+const_desc_hash (const void *ptr)
+{
+  return const_hash_1 (((struct constant_descriptor_tree *)ptr)->value);
+}
+
+static hashval_t
+const_hash_1 (const tree exp)
+{
+  const char *p;
+  hashval_t hi;
+  int len, i;
+  enum tree_code code = TREE_CODE (exp);
+
+  /* Either set P and LEN to the address and len of something to hash and
+     exit the switch or return a value.  */
+
+  switch (code)
+    {
+    case INTEGER_CST:
+      p = (char *) &TREE_INT_CST (exp);
+      len = sizeof TREE_INT_CST (exp);
+      break;
+
+    case REAL_CST:
+      return real_hash (TREE_REAL_CST_PTR (exp));
+
+    case STRING_CST:
+      if (flag_writable_strings)
+	{
+	  p = (char *) &exp;
+	  len = sizeof exp;
+	}
+      else
+	{
+	  p = TREE_STRING_POINTER (exp);
+	  len = TREE_STRING_LENGTH (exp);
+	}
+      break;
+
+    case COMPLEX_CST:
+      return (const_hash_1 (TREE_REALPART (exp)) * 5
+	      + const_hash_1 (TREE_IMAGPART (exp)));
+
+    case CONSTRUCTOR:
+      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+	{
+	  char *tmp;
+
+	  len = int_size_in_bytes (TREE_TYPE (exp));
+	  tmp = alloca (len);
+	  get_set_constructor_bytes (exp, (unsigned char *) tmp, len);
+	  p = tmp;
+	  break;
+	}
+      else
+	{
+	  tree link;
+
+	  hi = 5 + int_size_in_bytes (TREE_TYPE (exp));
+
+	  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))
+	    if (TREE_VALUE (link))
+	      hi = hi * 603 + const_hash_1 (TREE_VALUE (link));
+
+	  return hi;
+	}
+
+    case ADDR_EXPR:
+    case FDESC_EXPR:
+      {
+	struct addr_const value;
+
+	decode_addr_const (exp, &value);
+	if (GET_CODE (value.base) == SYMBOL_REF)
+	  {
+	    /* Don't hash the address of the SYMBOL_REF;
+	       only use the offset and the symbol name.  */
+	    hi = value.offset;
+	    p = XSTR (value.base, 0);
+	    for (i = 0; p[i] != 0; i++)
+	      hi = ((hi * 613) + (unsigned) (p[i]));
+	  }
+	else if (GET_CODE (value.base) == LABEL_REF)
+	  hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;
+	else
+	  abort ();
+      }
+      return hi;
+
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+      return (const_hash_1 (TREE_OPERAND (exp, 0)) * 9
+	      + const_hash_1 (TREE_OPERAND (exp, 1)));
+
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      return const_hash_1 (TREE_OPERAND (exp, 0)) * 7 + 2;
+
+    default:
+      /* A language specific constant. Just hash the code.  */
+      return code;
+    }
+
+  /* Compute hashing function.  */
+  hi = len;
+  for (i = 0; i < len; i++)
+    hi = ((hi * 613) + (unsigned) (p[i]));
+
+  return hi;
+}
+
+/* Wrapper of compare_constant, for the htab interface.  */
+static int
+const_desc_eq (const void *p1, const void *p2)
+{
+  return compare_constant (((struct constant_descriptor_tree *)p1)->value,
+			   ((struct constant_descriptor_tree *)p2)->value);
+}
+
+/* Compare t1 and t2, and return 1 only if they are known to result in
+   the same bit pattern on output.  */
+
+static int
+compare_constant (const tree t1, const tree t2)
+{
+  enum tree_code typecode;
+
+  if (t1 == NULL_TREE)
+    return t2 == NULL_TREE;
+  if (t2 == NULL_TREE)
+    return 0;
+
+  if (TREE_CODE (t1) != TREE_CODE (t2))
+    return 0;
+
+  switch (TREE_CODE (t1))
+    {
+    case INTEGER_CST:
+      /* Integer constants are the same only if the same width of type.  */
+      if (TYPE_PRECISION (TREE_TYPE (t1)) != TYPE_PRECISION (TREE_TYPE (t2)))
+	return 0;
+      return tree_int_cst_equal (t1, t2);
+
+    case REAL_CST:
+      /* Real constants are the same only if the same width of type.  */
+      if (TYPE_PRECISION (TREE_TYPE (t1)) != TYPE_PRECISION (TREE_TYPE (t2)))
+	return 0;
+
+      return REAL_VALUES_IDENTICAL (TREE_REAL_CST (t1), TREE_REAL_CST (t2));
+
+    case STRING_CST:
+      if (flag_writable_strings)
+	return t1 == t2;
+
+      if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2)))
+	return 0;
+
+      return (TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)
+	      && ! memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),
+			 TREE_STRING_LENGTH (t1)));
+
+    case COMPLEX_CST:
+      return (compare_constant (TREE_REALPART (t1), TREE_REALPART (t2))
+	      && compare_constant (TREE_IMAGPART (t1), TREE_IMAGPART (t2)));
+
+    case CONSTRUCTOR:
+      typecode = TREE_CODE (TREE_TYPE (t1));
+      if (typecode != TREE_CODE (TREE_TYPE (t2)))
+	return 0;
+
+      if (typecode == SET_TYPE)
+	{
+	  int len = int_size_in_bytes (TREE_TYPE (t2));
+	  unsigned char *tmp1, *tmp2;
+
+	  if (int_size_in_bytes (TREE_TYPE (t1)) != len)
+	    return 0;
+
+	  tmp1 = alloca (len);
+	  tmp2 = alloca (len);
+
+	  if (get_set_constructor_bytes (t1, tmp1, len) != NULL_TREE)
+	    return 0;
+	  if (get_set_constructor_bytes (t2, tmp2, len) != NULL_TREE)
+	    return 0;
+
+	  return memcmp (tmp1, tmp2, len) == 0;
+	}
+      else
+	{
+	  tree l1, l2;
+
+	  if (typecode == ARRAY_TYPE)
+	    {
+	      HOST_WIDE_INT size_1 = int_size_in_bytes (TREE_TYPE (t1));
+	      /* For arrays, check that the sizes all match.  */
+	      if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2))
+		  || size_1 == -1
+		  || size_1 != int_size_in_bytes (TREE_TYPE (t2)))
+		return 0;
+	    }
+	  else
+	    {
+	      /* For record and union constructors, require exact type
+                 equality.  */
+	      if (TREE_TYPE (t1) != TREE_TYPE (t2))
+		return 0;
+	    }
+
+	  for (l1 = CONSTRUCTOR_ELTS (t1), l2 = CONSTRUCTOR_ELTS (t2);
+	       l1 && l2;
+	       l1 = TREE_CHAIN (l1), l2 = TREE_CHAIN (l2))
+	    {
+	      /* Check that each value is the same...  */
+	      if (! compare_constant (TREE_VALUE (l1), TREE_VALUE (l2)))
+		return 0;
+	      /* ... and that they apply to the same fields!  */
+	      if (typecode == ARRAY_TYPE)
+		{
+		  if (! compare_constant (TREE_PURPOSE (l1),
+					  TREE_PURPOSE (l2)))
+		    return 0;
+		}
+	      else
+		{
+		  if (TREE_PURPOSE (l1) != TREE_PURPOSE (l2))
+		    return 0;
+		}
+	    }
+
+	  return l1 == NULL_TREE && l2 == NULL_TREE;
+	}
+
+    case ADDR_EXPR:
+    case FDESC_EXPR:
+      {
+	struct addr_const value1, value2;
+
+	decode_addr_const (t1, &value1);
+	decode_addr_const (t2, &value2);
+	return (value1.offset == value2.offset
+		&& strcmp (XSTR (value1.base, 0), XSTR (value2.base, 0)) == 0);
+      }
+
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+    case RANGE_EXPR:
+      return (compare_constant (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0))
+	      && compare_constant(TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1)));
+
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      return compare_constant (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));
+
+    default:
+      {
+	tree nt1, nt2;
+	nt1 = (*lang_hooks.expand_constant) (t1);
+	nt2 = (*lang_hooks.expand_constant) (t2);
+	if (nt1 != t1 || nt2 != t2)
+	  return compare_constant (nt1, nt2);
+	else
+	  return 0;
+      }
+    }
+
+  /* Should not get here.  */
+  abort ();
+}
+
+/* Make a copy of the whole tree structure for a constant.  This
+   handles the same types of nodes that compare_constant handles.
+   Writable string constants are never copied.  */
+
+static tree
+copy_constant (tree exp)
+{
+  switch (TREE_CODE (exp))
+    {
+    case ADDR_EXPR:
+      /* For ADDR_EXPR, we do not want to copy the decl whose address
+	 is requested.  We do want to copy constants though.  */
+      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == 'c')
+	return build1 (TREE_CODE (exp), TREE_TYPE (exp),
+		       copy_constant (TREE_OPERAND (exp, 0)));
+      else
+	return copy_node (exp);
+
+    case STRING_CST:
+      if (flag_writable_strings)
+	return exp;
+      /* FALLTHROUGH */
+    case INTEGER_CST:
+    case REAL_CST:
+      return copy_node (exp);
+
+    case COMPLEX_CST:
+      return build_complex (TREE_TYPE (exp),
+			    copy_constant (TREE_REALPART (exp)),
+			    copy_constant (TREE_IMAGPART (exp)));
+
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+      return build (TREE_CODE (exp), TREE_TYPE (exp),
+		    copy_constant (TREE_OPERAND (exp, 0)),
+		    copy_constant (TREE_OPERAND (exp, 1)));
+
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+    case VIEW_CONVERT_EXPR:
+      return build1 (TREE_CODE (exp), TREE_TYPE (exp),
+		     copy_constant (TREE_OPERAND (exp, 0)));
+
+    case CONSTRUCTOR:
+      {
+	tree copy = copy_node (exp);
+	tree list = copy_list (CONSTRUCTOR_ELTS (exp));
+	tree tail;
+
+	CONSTRUCTOR_ELTS (copy) = list;
+	for (tail = list; tail; tail = TREE_CHAIN (tail))
+	  TREE_VALUE (tail) = copy_constant (TREE_VALUE (tail));
+	if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+	  for (tail = list; tail; tail = TREE_CHAIN (tail))
+	    TREE_PURPOSE (tail) = copy_constant (TREE_PURPOSE (tail));
+
+	return copy;
+      }
+
+    default:
+      {
+	tree t;
+	t = (*lang_hooks.expand_constant) (exp);
+	if (t != exp)
+	  return copy_constant (t);
+	else
+	  abort ();
+      }
+    }
+}
+
+/* Subroutine of output_constant_def:
+   No constant equal to EXP is known to have been output.
+   Make a constant descriptor to enter EXP in the hash table.
+   Assign the label number and construct RTL to refer to the
+   constant's location in memory.
+   Caller is responsible for updating the hash table.  */
+
+static struct constant_descriptor_tree *
+build_constant_desc (tree exp)
+{
+  rtx symbol;
+  rtx rtl;
+  char label[256];
+  int labelno;
+  struct constant_descriptor_tree *desc;
+
+  desc = ggc_alloc (sizeof (*desc));
+  desc->value = copy_constant (exp);
+
+  /* Create a string containing the label name, in LABEL.  */
+  labelno = const_labelno++;
+  ASM_GENERATE_INTERNAL_LABEL (label, "LC", labelno);
+
+  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
+  symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));
+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;
+  SYMBOL_REF_DECL (symbol) = desc->value;
+  TREE_CONSTANT_POOL_ADDRESS_P (symbol) = 1;
+
+  rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), symbol);
+  set_mem_attributes (rtl, exp, 1);
+  set_mem_alias_set (rtl, 0);
+  set_mem_alias_set (rtl, const_alias_set);
+
+  /* Set flags or add text to the name to record information, such as
+     that it is a local symbol.  If the name is changed, the macro
+     ASM_OUTPUT_LABELREF will have to know how to strip this
+     information.  This call might invalidate our local variable
+     SYMBOL; we can't use it afterward.  */
+
+  (*targetm.encode_section_info) (exp, rtl, true);
+
+  desc->rtl = rtl;
+
+  return desc;
+}
+
+/* Return an rtx representing a reference to constant data in memory
+   for the constant expression EXP.
+
+   If assembler code for such a constant has already been output,
+   return an rtx to refer to it.
+   Otherwise, output such a constant in memory
+   and generate an rtx for it.
+
+   If DEFER is nonzero, this constant can be deferred and output only
+   if referenced in the function after all optimizations.
+
+   `const_desc_table' records which constants already have label strings.  */
+
+rtx
+output_constant_def (tree exp, int defer)
+{
+  struct constant_descriptor_tree *desc;
+  struct constant_descriptor_tree key;
+  void **loc;
+
+  /* Look up EXP in the table of constant descriptors.  If we didn't find
+     it, create a new one.  */
+  key.value = exp;
+  loc = htab_find_slot (const_desc_htab, &key, INSERT);
+
+  desc = *loc;
+  if (desc == 0)
+    {
+      desc = build_constant_desc (exp);
+      *loc = desc;
+    }
+
+  maybe_output_constant_def_contents (desc, defer);
+  return desc->rtl;
+}
+
+/* Subroutine of output_constant_def: Decide whether or not we need to
+   output the constant DESC now, and if so, do it.  */
+static void
+maybe_output_constant_def_contents (struct constant_descriptor_tree *desc,
+				    int defer)
+{
+  rtx symbol = XEXP (desc->rtl, 0);
+  tree exp = desc->value;
+
+  if (flag_syntax_only)
+    return;
+
+  if (TREE_ASM_WRITTEN (exp))
+    /* Already output; don't do it again.  */
+    return;
+
+  /* The only constants that cannot safely be deferred, assuming the
+     context allows it, are strings under flag_writable_strings.  */
+  if (defer && (TREE_CODE (exp) != STRING_CST || !flag_writable_strings))
+    {
+      /* Increment n_deferred_constants if it exists.  It needs to be at
+	 least as large as the number of constants actually referred to
+	 by the function.  If it's too small we'll stop looking too early
+	 and fail to emit constants; if it's too large we'll only look
+	 through the entire function when we could have stopped earlier.  */
+      if (cfun)
+	n_deferred_constants++;
+      return;
+    }
+
+  output_constant_def_contents (symbol);
+}
+
+/* We must output the constant data referred to by SYMBOL; do so.  */
+
+static void
+output_constant_def_contents (rtx symbol)
+{
+  tree exp = SYMBOL_REF_DECL (symbol);
+  const char *label = XSTR (symbol, 0);
+  HOST_WIDE_INT size;
+
+  /* Make sure any other constants whose addresses appear in EXP
+     are assigned label numbers.  */
+  int reloc = compute_reloc_for_constant (exp);
+
+  /* Align the location counter as required by EXP's data type.  */
+  int align = TYPE_ALIGN (TREE_TYPE (exp));
+#ifdef CONSTANT_ALIGNMENT
+  align = CONSTANT_ALIGNMENT (exp, align);
+#endif
+
+  output_addressed_constants (exp);
+
+  /* We are no longer deferring this constant.  */
+  TREE_ASM_WRITTEN (exp) = 1;
+
+  if (IN_NAMED_SECTION (exp))
+    named_section (exp, NULL, reloc);
+  else
+    (*targetm.asm_out.select_section) (exp, reloc, align);
+
+  if (align > BITS_PER_UNIT)
+    {
+      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));
+    }
+
+  size = int_size_in_bytes (TREE_TYPE (exp));
+  if (TREE_CODE (exp) == STRING_CST)
+    size = MAX (TREE_STRING_LENGTH (exp), size);
+
+  /* Do any machine/system dependent processing of the constant.  */
+#ifdef ASM_DECLARE_CONSTANT_NAME
+  ASM_DECLARE_CONSTANT_NAME (asm_out_file, label, exp, size);
+#else
+  /* Standard thing is just output label for the constant.  */
+  ASM_OUTPUT_LABEL (asm_out_file, label);
+#endif /* ASM_DECLARE_CONSTANT_NAME */
+
+  /* Output the value of EXP.  */
+  output_constant (exp, size, align);
+}
+
+/* A constant which was deferred in its original location has been
+   inserted by the RTL inliner into a different function.  The
+   current function's deferred constant count must be incremented.  */
+void
+notice_rtl_inlining_of_deferred_constant (void)
+{
+  n_deferred_constants++;
+}
+
+/* Look up EXP in the table of constant descriptors.  Return the rtl
+   if it has been emitted, else null.  */
+
+rtx
+lookup_constant_def (tree exp)
+{
+  struct constant_descriptor_tree *desc;
+  struct constant_descriptor_tree key;
+
+  key.value = exp;
+  desc = htab_find (const_desc_htab, &key);
+
+  return (desc ? desc->rtl : NULL_RTX);
+}
+
+/* Used in the hash tables to avoid outputting the same constant
+   twice.  Unlike 'struct constant_descriptor_tree', RTX constants
+   are output once per function, not once per file; there seems
+   to be no reason for the difference.  */
+
+struct constant_descriptor_rtx GTY(())
+{
+  /* More constant_descriptors with the same hash code.  */
+  struct constant_descriptor_rtx *next;
+
+  /* A MEM for the constant.  */
+  rtx rtl;
+
+  /* The value of the constant.  */
+  struct rtx_const value;
+};
+
+/* Structure to represent sufficient information about a constant so that
+   it can be output when the constant pool is output, so that function
+   integration can be done, and to simplify handling on machines that reference
+   constant pool as base+displacement.  */
+
+struct pool_constant GTY(())
+{
+  struct constant_descriptor_rtx *desc;
+  struct pool_constant *next;
+  struct pool_constant *next_sym;
+  rtx constant;
+  enum machine_mode mode;
+  int labelno;
+  unsigned int align;
+  HOST_WIDE_INT offset;
+  int mark;
+};
+
+/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.
+   The argument is XSTR (... , 0)  */
+
+#define SYMHASH(LABEL)	(((unsigned long) (LABEL)) % MAX_RTX_HASH_TABLE)
+
+/* Initialize constant pool hashing for a new function.  */
+
+void
+init_varasm_status (struct function *f)
+{
+  struct varasm_status *p;
+  p = ggc_alloc (sizeof (struct varasm_status));
+  f->varasm = p;
+  p->x_const_rtx_hash_table
+    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE
+			 * sizeof (struct constant_descriptor_rtx *));
+  p->x_const_rtx_sym_hash_table
+    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE
+			 * sizeof (struct pool_constant *));
+
+  p->x_first_pool = p->x_last_pool = 0;
+  p->x_pool_offset = 0;
+  p->deferred_constants = 0;
+}
+
+
+/* Express an rtx for a constant integer (perhaps symbolic)
+   as the sum of a symbol or label plus an explicit integer.
+   They are stored into VALUE.  */
+
+static void
+decode_rtx_const (enum machine_mode mode, rtx x, struct rtx_const *value)
+{
+  /* Clear the whole structure, including any gaps.  */
+  memset (value, 0, sizeof (struct rtx_const));
+
+  value->kind = RTX_INT;	/* Most usual kind.  */
+  value->mode = mode;
+
+  switch (GET_CODE (x))
+    {
+    case CONST_DOUBLE:
+      value->kind = RTX_DOUBLE;
+      if (GET_MODE (x) != VOIDmode)
+	{
+	  const REAL_VALUE_TYPE *r = CONST_DOUBLE_REAL_VALUE (x);
+
+	  value->mode = GET_MODE (x);
+
+	  /* Copy the REAL_VALUE_TYPE by members so that we don't
+	     copy garbage from the original structure into our
+	     carefully cleaned hashing structure.  */
+	  value->un.du.class = r->class;
+	  value->un.du.sign = r->sign;
+	  switch (r->class)
+	    {
+	    case rvc_zero:
+	    case rvc_inf:
+	      break;
+	    case rvc_normal:
+	      value->un.du.exp = r->exp;
+	      /* Fall through.  */
+	    case rvc_nan:
+	      memcpy (value->un.du.sig, r->sig, sizeof (r->sig));
+	      break;
+	    default:
+	      abort ();
+	    }
+	}
+      else
+	{
+	  value->un.di.low = CONST_DOUBLE_LOW (x);
+	  value->un.di.high = CONST_DOUBLE_HIGH (x);
+	}
+      break;
+
+    case CONST_VECTOR:
+      {
+	int units, i;
+
+	units = CONST_VECTOR_NUNITS (x);
+	value->kind = RTX_VECTOR;
+	value->mode = mode;
+
+	if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	  {
+	    for (i = 0; i < units; ++i)
+	      {
+	        rtx elt = CONST_VECTOR_ELT (x, i);
+	        if (GET_CODE (elt) == CONST_INT)
+	          {
+		    value->un.int_vec[i].low = INTVAL (elt);
+		    value->un.int_vec[i].high = 0;
+	          }
+		else
+	          {
+		    value->un.int_vec[i].low = CONST_DOUBLE_LOW (elt);
+		    value->un.int_vec[i].high = CONST_DOUBLE_HIGH (elt);
+		  }
+	      }
+	  }
+	else if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
+	  {
+	    for (i = 0; i < units; ++i)
+	      {
+		const REAL_VALUE_TYPE *r
+		  = CONST_DOUBLE_REAL_VALUE (CONST_VECTOR_ELT (x, i));
+		REAL_VALUE_TYPE *d = &value->un.fp_vec[i];
+
+	        /* Copy the REAL_VALUE_TYPE by members so that we don't
+	           copy garbage from the original structure into our
+	           carefully cleaned hashing structure.  */
+	        d->class = r->class;
+	        d->sign = r->sign;
+	        switch (r->class)
+	          {
+	          case rvc_zero:
+	          case rvc_inf:
+	            break;
+	          case rvc_normal:
+	            d->exp = r->exp;
+	            /* Fall through.  */
+	          case rvc_nan:
+	            memcpy (d->sig, r->sig, sizeof (r->sig));
+	            break;
+	          default:
+	            abort ();
+	          }
+	      }
+	  }
+	else
+	  abort ();
+      }
+      break;
+
+    case CONST_INT:
+      value->un.addr.offset = INTVAL (x);
+      break;
+
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case PC:
+      value->un.addr.base = x;
+      break;
+
+    case CONST:
+      x = XEXP (x, 0);
+      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  value->un.addr.base = XEXP (x, 0);
+	  value->un.addr.offset = INTVAL (XEXP (x, 1));
+	}
+      else if (GET_CODE (x) == MINUS && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  value->un.addr.base = XEXP (x, 0);
+	  value->un.addr.offset = - INTVAL (XEXP (x, 1));
+	}
+      else
+	{
+	  value->un.addr.base = x;
+	  value->un.addr.offset = 0;
+	}
+      break;
+
+    default:
+      value->kind = RTX_UNKNOWN;
+      break;
+    }
+
+  if (value->kind == RTX_INT && value->un.addr.base != 0
+      && GET_CODE (value->un.addr.base) == UNSPEC)
+    {
+      /* For a simple UNSPEC, the base is set to the
+	 operand, the kind field is set to the index of
+	 the unspec expression.
+	 Together with the code below, in case that
+	 the operand is a SYMBOL_REF or LABEL_REF,
+	 the address of the string or the code_label
+	 is taken as base.  */
+      if (XVECLEN (value->un.addr.base, 0) == 1)
+	{
+	  value->kind = RTX_UNSPEC + XINT (value->un.addr.base, 1);
+	  value->un.addr.base = XVECEXP (value->un.addr.base, 0, 0);
+	}
+    }
+
+  if (value->kind >= RTX_INT && value->un.addr.base != 0)
+    switch (GET_CODE (value->un.addr.base))
+      {
+      case SYMBOL_REF:
+	/* Use the string's address, not the SYMBOL_REF's address,
+	   for the sake of addresses of library routines.  */
+	value->un.addr.symbol = XSTR (value->un.addr.base, 0);
+	value->un.addr.base = NULL_RTX;
+	break;
+
+      case LABEL_REF:
+	/* For a LABEL_REF, compare labels.  */
+	value->un.addr.base = XEXP (value->un.addr.base, 0);
+
+      default:
+	break;
+      }
+}
+
+/* Given a MINUS expression, simplify it if both sides
+   include the same symbol.  */
+
+rtx
+simplify_subtraction (rtx x)
+{
+  struct rtx_const val0, val1;
+
+  decode_rtx_const (GET_MODE (x), XEXP (x, 0), &val0);
+  decode_rtx_const (GET_MODE (x), XEXP (x, 1), &val1);
+
+  if (val0.kind >= RTX_INT
+      && val0.kind == val1.kind
+      && val0.un.addr.base == val1.un.addr.base
+      && val0.un.addr.symbol == val1.un.addr.symbol)
+    return GEN_INT (val0.un.addr.offset - val1.un.addr.offset);
+
+  return x;
+}
+
+/* Compute a hash code for a constant RTL expression.  */
+
+static unsigned int
+const_hash_rtx (enum machine_mode mode, rtx x)
+{
+  union {
+    struct rtx_const value;
+    unsigned int data[sizeof(struct rtx_const) / sizeof (unsigned int)];
+  } u;
+
+  unsigned int hi;
+  size_t i;
+
+  decode_rtx_const (mode, x, &u.value);
+
+  /* Compute hashing function.  */
+  hi = 0;
+  for (i = 0; i < ARRAY_SIZE (u.data); i++)
+    hi = hi * 613 + u.data[i];
+
+  return hi % MAX_RTX_HASH_TABLE;
+}
+
+/* Compare a constant rtl object X with a constant-descriptor DESC.
+   Return 1 if DESC describes a constant with the same value as X.  */
+
+static int
+compare_constant_rtx (enum machine_mode mode, rtx x,
+		      struct constant_descriptor_rtx *desc)
+{
+  struct rtx_const value;
+
+  decode_rtx_const (mode, x, &value);
+
+  /* Compare constant contents.  */
+  return memcmp (&value, &desc->value, sizeof (struct rtx_const)) == 0;
+}
+
+/* Construct a constant descriptor for the rtl-expression X.
+   It is up to the caller to enter the descriptor in the hash table.  */
+
+static struct constant_descriptor_rtx *
+record_constant_rtx (enum machine_mode mode, rtx x)
+{
+  struct constant_descriptor_rtx *ptr;
+
+  ptr = ggc_alloc (sizeof (*ptr));
+  decode_rtx_const (mode, x, &ptr->value);
+
+  return ptr;
+}
+
+/* Given a constant rtx X, make (or find) a memory constant for its value
+   and return a MEM rtx to refer to it in memory.  */
+
+rtx
+force_const_mem (enum machine_mode mode, rtx x)
+{
+  int hash;
+  struct constant_descriptor_rtx *desc;
+  char label[256];
+  rtx def, symbol;
+  struct pool_constant *pool;
+  unsigned int align;
+
+  /* If we're not allowed to drop X into the constant pool, don't.  */
+  if ((*targetm.cannot_force_const_mem) (x))
+    return NULL_RTX;
+
+  /* Compute hash code of X.  Search the descriptors for that hash code
+     to see if any of them describes X.  If yes, we have an rtx to use.  */
+  hash = const_hash_rtx (mode, x);
+  for (desc = const_rtx_hash_table[hash]; desc; desc = desc->next)
+    if (compare_constant_rtx (mode, x, desc))
+      return copy_rtx (desc->rtl);
+
+  /* No constant equal to X is known to have been output.
+     Make a constant descriptor to enter X in the hash table
+     and make a MEM for it.  */
+  desc = record_constant_rtx (mode, x);
+  desc->next = const_rtx_hash_table[hash];
+  const_rtx_hash_table[hash] = desc;
+
+  /* Align the location counter as required by EXP's data type.  */
+  align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);
+#ifdef CONSTANT_ALIGNMENT
+  {
+    tree type = (*lang_hooks.types.type_for_mode) (mode, 0);
+    if (type != NULL_TREE)
+      align = CONSTANT_ALIGNMENT (make_tree (type, x), align);
+  }
+#endif
+
+  pool_offset += (align / BITS_PER_UNIT) - 1;
+  pool_offset &= ~ ((align / BITS_PER_UNIT) - 1);
+
+  if (GET_CODE (x) == LABEL_REF)
+    LABEL_PRESERVE_P (XEXP (x, 0)) = 1;
+
+  /* Allocate a pool constant descriptor, fill it in, and chain it in.  */
+  pool = ggc_alloc (sizeof (struct pool_constant));
+  pool->desc = desc;
+  pool->constant = x;
+  pool->mode = mode;
+  pool->labelno = const_labelno;
+  pool->align = align;
+  pool->offset = pool_offset;
+  pool->mark = 1;
+  pool->next = 0;
+
+  if (last_pool == 0)
+    first_pool = pool;
+  else
+    last_pool->next = pool;
+
+  last_pool = pool;
+  pool_offset += GET_MODE_SIZE (mode);
+
+  /* Create a string containing the label name, in LABEL.  */
+  ASM_GENERATE_INTERNAL_LABEL (label, "LC", const_labelno);
+
+  ++const_labelno;
+
+  /* Construct the SYMBOL_REF and the MEM.  */
+
+  symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));
+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;
+
+  pool->desc->rtl = def = gen_rtx_MEM (mode, symbol);
+  set_mem_attributes (def, (*lang_hooks.types.type_for_mode) (mode, 0), 1);
+  RTX_UNCHANGING_P (def) = 1;
+
+  /* Add label to symbol hash table.  */
+  hash = SYMHASH (XSTR (symbol, 0));
+  pool->next_sym = const_rtx_sym_hash_table[hash];
+  const_rtx_sym_hash_table[hash] = pool;
+
+  /* Mark the symbol_ref as belonging to this constants pool.  */
+  CONSTANT_POOL_ADDRESS_P (symbol) = 1;
+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;
+  current_function_uses_const_pool = 1;
+
+  return copy_rtx (def);
+}
+
+/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to
+   the corresponding pool_constant structure.  */
+
+static struct pool_constant *
+find_pool_constant (struct function *f, rtx addr)
+{
+  struct pool_constant *pool;
+  const char *label = XSTR (addr, 0);
+
+  for (pool = f->varasm->x_const_rtx_sym_hash_table[SYMHASH (label)]; pool;
+       pool = pool->next_sym)
+    if (XSTR (XEXP (pool->desc->rtl, 0), 0) == label)
+      return pool;
+
+  abort ();
+}
+
+/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
+
+rtx
+get_pool_constant (rtx addr)
+{
+  return (find_pool_constant (cfun, addr))->constant;
+}
+
+/* Given a constant pool SYMBOL_REF, return the corresponding constant
+   and whether it has been output or not.  */
+
+rtx
+get_pool_constant_mark (rtx addr, bool *pmarked)
+{
+  struct pool_constant *pool = find_pool_constant (cfun, addr);
+  *pmarked = (pool->mark != 0);
+  return pool->constant;
+}
+
+/* Likewise, but for the constant pool of a specific function.  */
+
+rtx
+get_pool_constant_for_function (struct function *f, rtx addr)
+{
+  return (find_pool_constant (f, addr))->constant;
+}
+
+/* Similar, return the mode.  */
+
+enum machine_mode
+get_pool_mode (rtx addr)
+{
+  return (find_pool_constant (cfun, addr))->mode;
+}
+
+enum machine_mode
+get_pool_mode_for_function (struct function *f, rtx addr)
+{
+  return (find_pool_constant (f, addr))->mode;
+}
+
+/* Similar, return the offset in the constant pool.  */
+
+int
+get_pool_offset (rtx addr)
+{
+  return (find_pool_constant (cfun, addr))->offset;
+}
+
+/* Return the size of the constant pool.  */
+
+int
+get_pool_size (void)
+{
+  return pool_offset;
+}
+
+/* Write all the constants in the constant pool.  */
+
+void
+output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,
+		      tree fndecl ATTRIBUTE_UNUSED)
+{
+  struct pool_constant *pool;
+  rtx x;
+  REAL_VALUE_TYPE r;
+
+  /* It is possible for gcc to call force_const_mem and then to later
+     discard the instructions which refer to the constant.  In such a
+     case we do not need to output the constant.  */
+  mark_constant_pool ();
+
+#ifdef ASM_OUTPUT_POOL_PROLOGUE
+  ASM_OUTPUT_POOL_PROLOGUE (asm_out_file, fnname, fndecl, pool_offset);
+#endif
+
+  for (pool = first_pool; pool; pool = pool->next)
+    {
+      rtx tmp;
+
+      x = pool->constant;
+
+      if (! pool->mark)
+	continue;
+
+      /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)
+	 whose CODE_LABEL has been deleted.  This can occur if a jump table
+	 is eliminated by optimization.  If so, write a constant of zero
+	 instead.  Note that this can also happen by turning the
+	 CODE_LABEL into a NOTE.  */
+      /* ??? This seems completely and utterly wrong.  Certainly it's
+	 not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper
+	 functioning even with INSN_DELETED_P and friends.  */
+
+      tmp = x;
+      switch (GET_CODE (x))
+	{
+	case CONST:
+	  if (GET_CODE (XEXP (x, 0)) != PLUS
+	      || GET_CODE (XEXP (XEXP (x, 0), 0)) != LABEL_REF)
+	    break;
+	  tmp = XEXP (XEXP (x, 0), 0);
+	  /* Fall through.  */
+
+	case LABEL_REF:
+	  tmp = XEXP (x, 0);
+	  if (INSN_DELETED_P (tmp)
+	      || (GET_CODE (tmp) == NOTE
+		  && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_DELETED))
+	    {
+	      abort ();
+	      x = const0_rtx;
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* First switch to correct section.  */
+      (*targetm.asm_out.select_rtx_section) (pool->mode, x, pool->align);
+
+#ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY
+      ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, pool->mode,
+				     pool->align, pool->labelno, done);
+#endif
+
+      assemble_align (pool->align);
+
+      /* Output the label.  */
+      (*targetm.asm_out.internal_label) (asm_out_file, "LC", pool->labelno);
+
+      /* Output the value of the constant itself.  */
+      switch (GET_MODE_CLASS (pool->mode))
+	{
+	case MODE_FLOAT:
+	  if (GET_CODE (x) != CONST_DOUBLE)
+	    abort ();
+
+	  REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	  assemble_real (r, pool->mode, pool->align);
+	  break;
+
+	case MODE_INT:
+	case MODE_PARTIAL_INT:
+	  assemble_integer (x, GET_MODE_SIZE (pool->mode), pool->align, 1);
+	  break;
+
+	case MODE_VECTOR_FLOAT:
+	  {
+	    int i, units;
+	    rtx elt;
+
+	    if (GET_CODE (x) != CONST_VECTOR)
+	      abort ();
+
+	    units = CONST_VECTOR_NUNITS (x);
+
+	    for (i = 0; i < units; i++)
+	      {
+		elt = CONST_VECTOR_ELT (x, i);
+		REAL_VALUE_FROM_CONST_DOUBLE (r, elt);
+		assemble_real (r, GET_MODE_INNER (pool->mode), pool->align);
+	      }
+	  }
+	  break;
+
+	case MODE_VECTOR_INT:
+	  {
+	    int i, units;
+	    rtx elt;
+
+	    if (GET_CODE (x) != CONST_VECTOR)
+	      abort ();
+
+	    units = CONST_VECTOR_NUNITS (x);
+
+	    for (i = 0; i < units; i++)
+	      {
+		elt = CONST_VECTOR_ELT (x, i);
+		assemble_integer (elt, GET_MODE_UNIT_SIZE (pool->mode),
+				  pool->align, 1);
+	      }
+	  }
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      /* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS
+	 sections have proper size.  */
+      if (pool->align > GET_MODE_BITSIZE (pool->mode)
+	  && in_section == in_named
+	  && get_named_section_flags (in_named_name) & SECTION_MERGE)
+	assemble_align (pool->align);
+
+#ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY
+    done: ;
+#endif
+    }
+
+#ifdef ASM_OUTPUT_POOL_EPILOGUE
+  ASM_OUTPUT_POOL_EPILOGUE (asm_out_file, fnname, fndecl, pool_offset);
+#endif
+
+  /* Done with this pool.  */
+  first_pool = last_pool = 0;
+}
+
+/* Look through the instructions for this function, and mark all the
+   entries in the constant pool which are actually being used.  Emit
+   deferred constants which have indeed been used.  */
+
+static void
+mark_constant_pool (void)
+{
+  rtx insn;
+  rtx link;
+  struct pool_constant *pool;
+
+  if (first_pool == 0 && n_deferred_constants == 0)
+    return;
+
+  for (pool = first_pool; pool; pool = pool->next)
+    pool->mark = 0;
+
+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    if (INSN_P (insn))
+      mark_constants (PATTERN (insn));
+
+  for (link = current_function_epilogue_delay_list;
+       link;
+       link = XEXP (link, 1))
+    {
+      insn = XEXP (link, 0);
+
+      if (INSN_P (insn))
+	mark_constants (PATTERN (insn));
+    }
+}
+
+/* Look through appropriate parts of X, marking all entries in the
+   constant pool which are actually being used.  Entries that are only
+   referenced by other constants are also marked as used.  Emit
+   deferred strings that are used.  */
+
+static void
+mark_constants (rtx x)
+{
+  int i;
+  const char *format_ptr;
+
+  if (x == 0)
+    return;
+
+  if (GET_CODE (x) == SYMBOL_REF)
+    {
+      mark_constant (&x, NULL);
+      return;
+    }
+
+  /* Insns may appear inside a SEQUENCE.  Only check the patterns of
+     insns, not any notes that may be attached.  We don't want to mark
+     a constant just because it happens to appear in a REG_EQUIV note.  */
+  if (INSN_P (x))
+    {
+      mark_constants (PATTERN (x));
+      return;
+    }
+
+  format_ptr = GET_RTX_FORMAT (GET_CODE (x));
+
+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)
+    {
+      switch (*format_ptr++)
+	{
+	case 'e':
+	  mark_constants (XEXP (x, i));
+	  break;
+
+	case 'E':
+	  if (XVEC (x, i) != 0)
+	    {
+	      int j;
+
+	      for (j = 0; j < XVECLEN (x, i); j++)
+		mark_constants (XVECEXP (x, i, j));
+	    }
+	  break;
+
+	case 'S':
+	case 's':
+	case '0':
+	case 'i':
+	case 'w':
+	case 'n':
+	case 'u':
+	case 'B':
+	  break;
+
+	default:
+	  abort ();
+	}
+    }
+}
+
+/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers
+   to as used.  Emit referenced deferred strings.  This function can
+   be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */
+
+static int
+mark_constant (rtx *current_rtx, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x = *current_rtx;
+
+  if (x == NULL_RTX)
+    return 0;
+
+  else if (GET_CODE (x) == SYMBOL_REF)
+    {
+      if (CONSTANT_POOL_ADDRESS_P (x))
+	{
+	  struct pool_constant *pool = find_pool_constant (cfun, x);
+	  if (pool->mark == 0)
+	    {
+	      pool->mark = 1;
+	      for_each_rtx (&(pool->constant), &mark_constant, NULL);
+	    }
+	  else
+	    return -1;
+	}
+      else if (TREE_CONSTANT_POOL_ADDRESS_P (x))
+	{
+	  tree exp = SYMBOL_REF_DECL (x);
+	  if (!TREE_ASM_WRITTEN (exp))
+	    {
+	      n_deferred_constants--;
+	      output_constant_def_contents (x);
+	    }
+	}
+    }
+  return 0;
+}
+
+/* Determine what kind of relocations EXP may need.  */
+
+int
+compute_reloc_for_constant (tree exp)
+{
+  int reloc = 0, reloc2;
+  tree tem;
+
+  /* Give the front-end a chance to convert VALUE to something that
+     looks more like a constant to the back-end.  */
+  exp = (*lang_hooks.expand_constant) (exp);
+
+  switch (TREE_CODE (exp))
+    {
+    case ADDR_EXPR:
+    case FDESC_EXPR:
+      /* Go inside any operations that get_inner_reference can handle and see
+	 if what's inside is a constant: no need to do anything here for
+	 addresses of variables or functions.  */
+      for (tem = TREE_OPERAND (exp, 0); handled_component_p (tem);
+	   tem = TREE_OPERAND (tem, 0))
+	;
+
+      if (TREE_PUBLIC (tem))
+	reloc |= 2;
+      else
+	reloc |= 1;
+      break;
+
+    case PLUS_EXPR:
+      reloc = compute_reloc_for_constant (TREE_OPERAND (exp, 0));
+      reloc |= compute_reloc_for_constant (TREE_OPERAND (exp, 1));
+      break;
+
+    case MINUS_EXPR:
+      reloc = compute_reloc_for_constant (TREE_OPERAND (exp, 0));
+      reloc2 = compute_reloc_for_constant (TREE_OPERAND (exp, 1));
+      /* The difference of two local labels is computable at link time.  */
+      if (reloc == 1 && reloc2 == 1)
+	reloc = 0;
+      else
+	reloc |= reloc2;
+      break;
+
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      reloc = compute_reloc_for_constant (TREE_OPERAND (exp, 0));
+      break;
+
+    case CONSTRUCTOR:
+      for (tem = CONSTRUCTOR_ELTS (exp); tem; tem = TREE_CHAIN (tem))
+	if (TREE_VALUE (tem) != 0)
+	  reloc |= compute_reloc_for_constant (TREE_VALUE (tem));
+
+      break;
+
+    default:
+      break;
+    }
+  return reloc;
+}
+
+/* Find all the constants whose addresses are referenced inside of EXP,
+   and make sure assembler code with a label has been output for each one.
+   Indicate whether an ADDR_EXPR has been encountered.  */
+
+static void
+output_addressed_constants (tree exp)
+{
+  tree tem;
+
+  /* Give the front-end a chance to convert VALUE to something that
+     looks more like a constant to the back-end.  */
+  exp = (*lang_hooks.expand_constant) (exp);
+
+  switch (TREE_CODE (exp))
+    {
+    case ADDR_EXPR:
+    case FDESC_EXPR:
+      /* Go inside any operations that get_inner_reference can handle and see
+	 if what's inside is a constant: no need to do anything here for
+	 addresses of variables or functions.  */
+      for (tem = TREE_OPERAND (exp, 0); handled_component_p (tem);
+	   tem = TREE_OPERAND (tem, 0))
+	;
+
+      if (TREE_CODE_CLASS (TREE_CODE (tem)) == 'c'
+	  || TREE_CODE (tem) == CONSTRUCTOR)
+	output_constant_def (tem, 0);
+      break;
+
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+      output_addressed_constants (TREE_OPERAND (exp, 1));
+      /* Fall through.  */
+
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      output_addressed_constants (TREE_OPERAND (exp, 0));
+      break;
+
+    case CONSTRUCTOR:
+      for (tem = CONSTRUCTOR_ELTS (exp); tem; tem = TREE_CHAIN (tem))
+	if (TREE_VALUE (tem) != 0)
+	  output_addressed_constants (TREE_VALUE (tem));
+
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Return nonzero if VALUE is a valid constant-valued expression
+   for use in initializing a static variable; one that can be an
+   element of a "constant" initializer.
+
+   Return null_pointer_node if the value is absolute;
+   if it is relocatable, return the variable that determines the relocation.
+   We assume that VALUE has been folded as much as possible;
+   therefore, we do not need to check for such things as
+   arithmetic-combinations of integers.  */
+
+tree
+initializer_constant_valid_p (tree value, tree endtype)
+{
+  /* Give the front-end a chance to convert VALUE to something that
+     looks more like a constant to the back-end.  */
+  value = (*lang_hooks.expand_constant) (value);
+
+  switch (TREE_CODE (value))
+    {
+    case CONSTRUCTOR:
+      if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE
+	   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)
+	  && TREE_CONSTANT (value)
+	  && CONSTRUCTOR_ELTS (value))
+	{
+	  tree elt;
+	  bool absolute = true;
+
+	  for (elt = CONSTRUCTOR_ELTS (value); elt; elt = TREE_CHAIN (elt))
+	    {
+	      tree reloc;
+	      value = TREE_VALUE (elt);
+	      reloc = initializer_constant_valid_p (value, TREE_TYPE (value));
+	      if (!reloc)
+		return NULL_TREE;
+	      if (reloc != null_pointer_node)
+		absolute = false;
+	    }
+	  /* For a non-absolute relocation, there is no single
+	     variable that can be "the variable that determines the
+	     relocation."  */
+	  return absolute ? null_pointer_node : error_mark_node;
+	}
+
+      return TREE_STATIC (value) ? null_pointer_node : NULL_TREE;
+
+    case INTEGER_CST:
+    case VECTOR_CST:
+    case REAL_CST:
+    case STRING_CST:
+    case COMPLEX_CST:
+      return null_pointer_node;
+
+    case ADDR_EXPR:
+    case FDESC_EXPR:
+      return staticp (TREE_OPERAND (value, 0)) ? TREE_OPERAND (value, 0) : 0;
+
+    case VIEW_CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
+
+    case CONVERT_EXPR:
+    case NOP_EXPR:
+      /* Allow conversions between pointer types.  */
+      if (POINTER_TYPE_P (TREE_TYPE (value))
+	  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))
+	return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
+
+      /* Allow conversions between real types.  */
+      if (FLOAT_TYPE_P (TREE_TYPE (value))
+	  && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))
+	return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
+
+      /* Allow length-preserving conversions between integer types.  */
+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))
+	  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))
+	  && (TYPE_PRECISION (TREE_TYPE (value))
+	      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))
+	return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
+
+      /* Allow conversions between other integer types only if
+	 explicit value.  */
+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))
+	  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))
+	{
+	  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),
+						     endtype);
+	  if (inner == null_pointer_node)
+	    return null_pointer_node;
+	  break;
+	}
+
+      /* Allow (int) &foo provided int is as wide as a pointer.  */
+      if (INTEGRAL_TYPE_P (TREE_TYPE (value))
+	  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0)))
+	  && (TYPE_PRECISION (TREE_TYPE (value))
+	      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))
+	return initializer_constant_valid_p (TREE_OPERAND (value, 0),
+					     endtype);
+
+      /* Likewise conversions from int to pointers, but also allow
+	 conversions from 0.  */
+      if ((POINTER_TYPE_P (TREE_TYPE (value))
+	   || TREE_CODE (TREE_TYPE (value)) == OFFSET_TYPE)
+	  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))
+	{
+	  if (integer_zerop (TREE_OPERAND (value, 0)))
+	    return null_pointer_node;
+	  else if (TYPE_PRECISION (TREE_TYPE (value))
+		   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))
+	    return initializer_constant_valid_p (TREE_OPERAND (value, 0),
+						 endtype);
+	}
+
+      /* Allow conversions to struct or union types if the value
+	 inside is okay.  */
+      if (TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE
+	  || TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)
+	return initializer_constant_valid_p (TREE_OPERAND (value, 0),
+					     endtype);
+      break;
+
+    case PLUS_EXPR:
+      if (! INTEGRAL_TYPE_P (endtype)
+	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
+	{
+	  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),
+						      endtype);
+	  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),
+						      endtype);
+	  /* If either term is absolute, use the other terms relocation.  */
+	  if (valid0 == null_pointer_node)
+	    return valid1;
+	  if (valid1 == null_pointer_node)
+	    return valid0;
+	}
+      break;
+
+    case MINUS_EXPR:
+      if (! INTEGRAL_TYPE_P (endtype)
+	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
+	{
+	  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),
+						      endtype);
+	  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),
+						      endtype);
+	  /* Win if second argument is absolute.  */
+	  if (valid1 == null_pointer_node)
+	    return valid0;
+	  /* Win if both arguments have the same relocation.
+	     Then the value is absolute.  */
+	  if (valid0 == valid1 && valid0 != 0)
+	    return null_pointer_node;
+
+	  /* Since GCC guarantees that string constants are unique in the
+	     generated code, a subtraction between two copies of the same
+	     constant string is absolute.  */
+	  if (valid0 && TREE_CODE (valid0) == STRING_CST &&
+	      valid1 && TREE_CODE (valid1) == STRING_CST &&
+	      TREE_STRING_POINTER (valid0) == TREE_STRING_POINTER (valid1))
+	    return null_pointer_node;
+	}
+
+      /* Support differences between labels.  */
+      if (INTEGRAL_TYPE_P (endtype))
+	{
+	  tree op0, op1;
+	  op0 = TREE_OPERAND (value, 0);
+	  op1 = TREE_OPERAND (value, 1);
+
+	  /* Like STRIP_NOPS except allow the operand mode to widen.
+	     This works around a feature of fold that simplifies
+	     (int)(p1 - p2) to ((int)p1 - (int)p2) under the theory
+	     that the narrower operation is cheaper.  */
+
+	  while (TREE_CODE (op0) == NOP_EXPR
+		 || TREE_CODE (op0) == CONVERT_EXPR
+		 || TREE_CODE (op0) == NON_LVALUE_EXPR)
+	    {
+	      tree inner = TREE_OPERAND (op0, 0);
+	      if (inner == error_mark_node
+	          || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+		  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))
+		      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))
+		break;
+	      op0 = inner;
+	    }
+
+	  while (TREE_CODE (op1) == NOP_EXPR
+		 || TREE_CODE (op1) == CONVERT_EXPR
+		 || TREE_CODE (op1) == NON_LVALUE_EXPR)
+	    {
+	      tree inner = TREE_OPERAND (op1, 0);
+	      if (inner == error_mark_node
+	          || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+		  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1)))
+		      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))
+		break;
+	      op1 = inner;
+	    }
+
+	  if (TREE_CODE (op0) == ADDR_EXPR
+	      && TREE_CODE (TREE_OPERAND (op0, 0)) == LABEL_DECL
+	      && TREE_CODE (op1) == ADDR_EXPR
+	      && TREE_CODE (TREE_OPERAND (op1, 0)) == LABEL_DECL)
+	    return null_pointer_node;
+	}
+      break;
+
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+/* Output assembler code for constant EXP to FILE, with no label.
+   This includes the pseudo-op such as ".int" or ".byte", and a newline.
+   Assumes output_addressed_constants has been done on EXP already.
+
+   Generate exactly SIZE bytes of assembler data, padding at the end
+   with zeros if necessary.  SIZE must always be specified.
+
+   SIZE is important for structure constructors,
+   since trailing members may have been omitted from the constructor.
+   It is also important for initialization of arrays from string constants
+   since the full length of the string constant might not be wanted.
+   It is also needed for initialization of unions, where the initializer's
+   type is just one member, and that may not be as long as the union.
+
+   There a case in which we would fail to output exactly SIZE bytes:
+   for a structure constructor that wants to produce more than SIZE bytes.
+   But such constructors will never be generated for any possible input.
+
+   ALIGN is the alignment of the data in bits.  */
+
+void
+output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)
+{
+  enum tree_code code;
+  unsigned HOST_WIDE_INT thissize;
+
+  /* Some front-ends use constants other than the standard language-independent
+     varieties, but which may still be output directly.  Give the front-end a
+     chance to convert EXP to a language-independent representation.  */
+  exp = (*lang_hooks.expand_constant) (exp);
+
+  if (size == 0 || flag_syntax_only)
+    return;
+
+  /* Eliminate any conversions since we'll be outputting the underlying
+     constant.  */
+  while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR
+	 || TREE_CODE (exp) == NON_LVALUE_EXPR
+	 || TREE_CODE (exp) == VIEW_CONVERT_EXPR)
+    exp = TREE_OPERAND (exp, 0);
+
+  code = TREE_CODE (TREE_TYPE (exp));
+  thissize = int_size_in_bytes (TREE_TYPE (exp));
+
+  /* Allow a constructor with no elements for any data type.
+     This means to fill the space with zeros.  */
+  if (TREE_CODE (exp) == CONSTRUCTOR && CONSTRUCTOR_ELTS (exp) == 0)
+    {
+      assemble_zeros (size);
+      return;
+    }
+
+  if (TREE_CODE (exp) == FDESC_EXPR)
+    {
+#ifdef ASM_OUTPUT_FDESC
+      HOST_WIDE_INT part = tree_low_cst (TREE_OPERAND (exp, 1), 0);
+      tree decl = TREE_OPERAND (exp, 0);
+      ASM_OUTPUT_FDESC (asm_out_file, decl, part);
+#else
+      abort ();
+#endif
+      return;
+    }
+
+  /* Now output the underlying data.  If we've handling the padding, return.
+     Otherwise, break and ensure THISSIZE is the size written.  */
+  switch (code)
+    {
+    case CHAR_TYPE:
+    case BOOLEAN_TYPE:
+    case INTEGER_TYPE:
+    case ENUMERAL_TYPE:
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+    case OFFSET_TYPE:
+      if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,
+					   EXPAND_INITIALIZER),
+			      size, align, 0))
+	error ("initializer for integer value is too complicated");
+      break;
+
+    case REAL_TYPE:
+      if (TREE_CODE (exp) != REAL_CST)
+	error ("initializer for floating value is not a floating constant");
+
+      assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);
+      break;
+
+    case COMPLEX_TYPE:
+      output_constant (TREE_REALPART (exp), thissize / 2, align);
+      output_constant (TREE_IMAGPART (exp), thissize / 2,
+		       min_align (align, BITS_PER_UNIT * (thissize / 2)));
+      break;
+
+    case ARRAY_TYPE:
+    case VECTOR_TYPE:
+      if (TREE_CODE (exp) == CONSTRUCTOR)
+	{
+	  output_constructor (exp, size, align);
+	  return;
+	}
+      else if (TREE_CODE (exp) == STRING_CST)
+	{
+	  thissize = MIN ((unsigned HOST_WIDE_INT)TREE_STRING_LENGTH (exp),
+			  size);
+	  assemble_string (TREE_STRING_POINTER (exp), thissize);
+	}
+      else if (TREE_CODE (exp) == VECTOR_CST)
+	{
+	  int elt_size;
+	  tree link;
+	  unsigned int nalign;
+	  enum machine_mode inner;
+
+	  inner = GET_MODE_INNER (TYPE_MODE (TREE_TYPE (exp)));
+	  nalign = MIN (align, GET_MODE_ALIGNMENT (inner));
+
+	  elt_size = GET_MODE_UNIT_SIZE (TYPE_MODE (TREE_TYPE (exp)));
+
+	  link = TREE_VECTOR_CST_ELTS (exp);
+	  output_constant (TREE_VALUE (link), elt_size, align);
+	  while ((link = TREE_CHAIN (link)) != NULL)
+	    output_constant (TREE_VALUE (link), elt_size, nalign);
+	}
+      else
+	abort ();
+      break;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+      if (TREE_CODE (exp) == CONSTRUCTOR)
+	output_constructor (exp, size, align);
+      else
+	abort ();
+      return;
+
+    case SET_TYPE:
+      if (TREE_CODE (exp) == INTEGER_CST)
+	assemble_integer (expand_expr (exp, NULL_RTX,
+				       VOIDmode, EXPAND_INITIALIZER),
+			  thissize, align, 1);
+      else if (TREE_CODE (exp) == CONSTRUCTOR)
+	{
+	  unsigned char *buffer = alloca (thissize);
+	  if (get_set_constructor_bytes (exp, buffer, thissize))
+	    abort ();
+	  assemble_string ((char *) buffer, thissize);
+	}
+      else
+	error ("unknown set constructor type");
+      return;
+
+    case ERROR_MARK:
+      return;
+
+    default:
+      abort ();
+    }
+
+  if (size > thissize)
+    assemble_zeros (size - thissize);
+}
+
+
+/* Subroutine of output_constructor, used for computing the size of
+   arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array
+   type with an unspecified upper bound.  */
+
+static unsigned HOST_WIDE_INT
+array_size_for_constructor (tree val)
+{
+  tree max_index, i;
+
+  /* This code used to attempt to handle string constants that are not
+     arrays of single-bytes, but nothing else does, so there's no point in
+     doing it here.  */
+  if (TREE_CODE (val) == STRING_CST)
+    return TREE_STRING_LENGTH (val);
+
+  max_index = NULL_TREE;
+  for (i = CONSTRUCTOR_ELTS (val); i; i = TREE_CHAIN (i))
+    {
+      tree index = TREE_PURPOSE (i);
+
+      if (TREE_CODE (index) == RANGE_EXPR)
+	index = TREE_OPERAND (index, 1);
+      if (max_index == NULL_TREE || tree_int_cst_lt (max_index, index))
+	max_index = index;
+    }
+
+  if (max_index == NULL_TREE)
+    return 0;
+
+  /* Compute the total number of array elements.  */
+  i = size_binop (MINUS_EXPR, convert (sizetype, max_index),
+		  convert (sizetype,
+			   TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val)))));
+  i = size_binop (PLUS_EXPR, i, convert (sizetype, integer_one_node));
+
+  /* Multiply by the array element unit size to find number of bytes.  */
+  i = size_binop (MULT_EXPR, i, TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (val))));
+
+  return tree_low_cst (i, 1);
+}
+
+/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).
+   Generate at least SIZE bytes, padding if necessary.  */
+
+static void
+output_constructor (tree exp, unsigned HOST_WIDE_INT size,
+		    unsigned int align)
+{
+  tree type = TREE_TYPE (exp);
+  tree link, field = 0;
+  tree min_index = 0;
+  /* Number of bytes output or skipped so far.
+     In other words, current position within the constructor.  */
+  HOST_WIDE_INT total_bytes = 0;
+  /* Nonzero means BYTE contains part of a byte, to be output.  */
+  int byte_buffer_in_use = 0;
+  int byte = 0;
+
+  if (HOST_BITS_PER_WIDE_INT < BITS_PER_UNIT)
+    abort ();
+
+  if (TREE_CODE (type) == RECORD_TYPE)
+    field = TYPE_FIELDS (type);
+
+  if (TREE_CODE (type) == ARRAY_TYPE
+      && TYPE_DOMAIN (type) != 0)
+    min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));
+
+  /* As LINK goes through the elements of the constant,
+     FIELD goes through the structure fields, if the constant is a structure.
+     if the constant is a union, then we override this,
+     by getting the field from the TREE_LIST element.
+     But the constant could also be an array.  Then FIELD is zero.
+
+     There is always a maximum of one element in the chain LINK for unions
+     (even if the initializer in a source program incorrectly contains
+     more one).  */
+  for (link = CONSTRUCTOR_ELTS (exp);
+       link;
+       link = TREE_CHAIN (link),
+       field = field ? TREE_CHAIN (field) : 0)
+    {
+      tree val = TREE_VALUE (link);
+      tree index = 0;
+
+      /* The element in a union constructor specifies the proper field
+	 or index.  */
+      if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE
+	   || TREE_CODE (type) == QUAL_UNION_TYPE)
+	  && TREE_PURPOSE (link) != 0)
+	field = TREE_PURPOSE (link);
+
+      else if (TREE_CODE (type) == ARRAY_TYPE)
+	index = TREE_PURPOSE (link);
+
+#ifdef ASM_COMMENT_START
+      if (field && flag_verbose_asm)
+	fprintf (asm_out_file, "%s %s:\n",
+		 ASM_COMMENT_START, 
+		 DECL_NAME (field) 
+		 ? IDENTIFIER_POINTER (DECL_NAME (field))
+		 : "<anonymous>");
+#endif
+
+      /* Eliminate the marker that makes a cast not be an lvalue.  */
+      if (val != 0)
+	STRIP_NOPS (val);
+
+      if (index && TREE_CODE (index) == RANGE_EXPR)
+	{
+	  unsigned HOST_WIDE_INT fieldsize
+	    = int_size_in_bytes (TREE_TYPE (type));
+	  HOST_WIDE_INT lo_index = tree_low_cst (TREE_OPERAND (index, 0), 0);
+	  HOST_WIDE_INT hi_index = tree_low_cst (TREE_OPERAND (index, 1), 0);
+	  HOST_WIDE_INT index;
+	  unsigned int align2 = min_align (align, fieldsize * BITS_PER_UNIT);
+
+	  for (index = lo_index; index <= hi_index; index++)
+	    {
+	      /* Output the element's initial value.  */
+	      if (val == 0)
+		assemble_zeros (fieldsize);
+	      else
+		output_constant (val, fieldsize, align2);
+
+	      /* Count its size.  */
+	      total_bytes += fieldsize;
+	    }
+	}
+      else if (field == 0 || !DECL_BIT_FIELD (field))
+	{
+	  /* An element that is not a bit-field.  */
+
+	  unsigned HOST_WIDE_INT fieldsize;
+	  /* Since this structure is static,
+	     we know the positions are constant.  */
+	  HOST_WIDE_INT pos = field ? int_byte_position (field) : 0;
+	  unsigned int align2;
+
+	  if (index != 0)
+	    pos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (val)), 1)
+		   * (tree_low_cst (index, 0) - tree_low_cst (min_index, 0)));
+
+	  /* Output any buffered-up bit-fields preceding this element.  */
+	  if (byte_buffer_in_use)
+	    {
+	      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
+	      total_bytes++;
+	      byte_buffer_in_use = 0;
+	    }
+
+	  /* Advance to offset of this element.
+	     Note no alignment needed in an array, since that is guaranteed
+	     if each element has the proper size.  */
+	  if ((field != 0 || index != 0) && pos != total_bytes)
+	    {
+	      assemble_zeros (pos - total_bytes);
+	      total_bytes = pos;
+	    }
+
+	  /* Find the alignment of this element.  */
+	  align2 = min_align (align, BITS_PER_UNIT * pos);
+
+	  /* Determine size this element should occupy.  */
+	  if (field)
+	    {
+	      fieldsize = 0;
+
+	      /* If this is an array with an unspecified upper bound,
+		 the initializer determines the size.  */
+	      /* ??? This ought to only checked if DECL_SIZE_UNIT is NULL,
+		 but we cannot do this until the deprecated support for
+		 initializing zero-length array members is removed.  */
+	      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE
+		  && TYPE_DOMAIN (TREE_TYPE (field))
+		  && ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))
+		{
+		  fieldsize = array_size_for_constructor (val);
+		  /* Given a non-empty initialization, this field had
+		     better be last.  */
+		  if (fieldsize != 0 && TREE_CHAIN (field) != NULL_TREE)
+		    abort ();
+		}
+	      else if (DECL_SIZE_UNIT (field))
+		{
+		  /* ??? This can't be right.  If the decl size overflows
+		     a host integer we will silently emit no data.  */
+		  if (host_integerp (DECL_SIZE_UNIT (field), 1))
+		    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);
+		}
+	    }
+	  else
+	    fieldsize = int_size_in_bytes (TREE_TYPE (type));
+
+	  /* Output the element's initial value.  */
+	  if (val == 0)
+	    assemble_zeros (fieldsize);
+	  else
+	    output_constant (val, fieldsize, align2);
+
+	  /* Count its size.  */
+	  total_bytes += fieldsize;
+	}
+      else if (val != 0 && TREE_CODE (val) != INTEGER_CST)
+	error ("invalid initial value for member `%s'",
+	       IDENTIFIER_POINTER (DECL_NAME (field)));
+      else
+	{
+	  /* Element that is a bit-field.  */
+
+	  HOST_WIDE_INT next_offset = int_bit_position (field);
+	  HOST_WIDE_INT end_offset
+	    = (next_offset + tree_low_cst (DECL_SIZE (field), 1));
+
+	  if (val == 0)
+	    val = integer_zero_node;
+
+	  /* If this field does not start in this (or, next) byte,
+	     skip some bytes.  */
+	  if (next_offset / BITS_PER_UNIT != total_bytes)
+	    {
+	      /* Output remnant of any bit field in previous bytes.  */
+	      if (byte_buffer_in_use)
+		{
+		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
+		  total_bytes++;
+		  byte_buffer_in_use = 0;
+		}
+
+	      /* If still not at proper byte, advance to there.  */
+	      if (next_offset / BITS_PER_UNIT != total_bytes)
+		{
+		  assemble_zeros (next_offset / BITS_PER_UNIT - total_bytes);
+		  total_bytes = next_offset / BITS_PER_UNIT;
+		}
+	    }
+
+	  if (! byte_buffer_in_use)
+	    byte = 0;
+
+	  /* We must split the element into pieces that fall within
+	     separate bytes, and combine each byte with previous or
+	     following bit-fields.  */
+
+	  /* next_offset is the offset n fbits from the beginning of
+	     the structure to the next bit of this element to be processed.
+	     end_offset is the offset of the first bit past the end of
+	     this element.  */
+	  while (next_offset < end_offset)
+	    {
+	      int this_time;
+	      int shift;
+	      HOST_WIDE_INT value;
+	      HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
+	      HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
+
+	      /* Advance from byte to byte
+		 within this element when necessary.  */
+	      while (next_byte != total_bytes)
+		{
+		  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
+		  total_bytes++;
+		  byte = 0;
+		}
+
+	      /* Number of bits we can process at once
+		 (all part of the same byte).  */
+	      this_time = MIN (end_offset - next_offset,
+			       BITS_PER_UNIT - next_bit);
+	      if (BYTES_BIG_ENDIAN)
+		{
+		  /* On big-endian machine, take the most significant bits
+		     first (of the bits that are significant)
+		     and put them into bytes from the most significant end.  */
+		  shift = end_offset - next_offset - this_time;
+
+		  /* Don't try to take a bunch of bits that cross
+		     the word boundary in the INTEGER_CST. We can
+		     only select bits from the LOW or HIGH part
+		     not from both.  */
+		  if (shift < HOST_BITS_PER_WIDE_INT
+		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
+		    {
+		      this_time = shift + this_time - HOST_BITS_PER_WIDE_INT;
+		      shift = HOST_BITS_PER_WIDE_INT;
+		    }
+
+		  /* Now get the bits from the appropriate constant word.  */
+		  if (shift < HOST_BITS_PER_WIDE_INT)
+		    value = TREE_INT_CST_LOW (val);
+		  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)
+		    {
+		      value = TREE_INT_CST_HIGH (val);
+		      shift -= HOST_BITS_PER_WIDE_INT;
+		    }
+		  else
+		    abort ();
+
+		  /* Get the result. This works only when:
+		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+		  byte |= (((value >> shift)
+			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+			   << (BITS_PER_UNIT - this_time - next_bit));
+		}
+	      else
+		{
+		  /* On little-endian machines,
+		     take first the least significant bits of the value
+		     and pack them starting at the least significant
+		     bits of the bytes.  */
+		  shift = next_offset - int_bit_position (field);
+
+		  /* Don't try to take a bunch of bits that cross
+		     the word boundary in the INTEGER_CST. We can
+		     only select bits from the LOW or HIGH part
+		     not from both.  */
+		  if (shift < HOST_BITS_PER_WIDE_INT
+		      && shift + this_time > HOST_BITS_PER_WIDE_INT)
+		    this_time = (HOST_BITS_PER_WIDE_INT - shift);
+
+		  /* Now get the bits from the appropriate constant word.  */
+		  if (shift < HOST_BITS_PER_WIDE_INT)
+		    value = TREE_INT_CST_LOW (val);
+		  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)
+		    {
+		      value = TREE_INT_CST_HIGH (val);
+		      shift -= HOST_BITS_PER_WIDE_INT;
+		    }
+		  else
+		    abort ();
+
+		  /* Get the result. This works only when:
+		     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
+		  byte |= (((value >> shift)
+			    & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
+			   << next_bit);
+		}
+
+	      next_offset += this_time;
+	      byte_buffer_in_use = 1;
+	    }
+	}
+    }
+
+  if (byte_buffer_in_use)
+    {
+      assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
+      total_bytes++;
+    }
+
+  if ((unsigned HOST_WIDE_INT)total_bytes < size)
+    assemble_zeros (size - total_bytes);
+}
+
+/* This TREE_LIST contains any weak symbol declarations waiting
+   to be emitted.  */
+static GTY(()) tree weak_decls;
+
+/* Mark DECL as weak.  */
+
+static void
+mark_weak (tree decl)
+{
+  DECL_WEAK (decl) = 1;
+
+  if (DECL_RTL_SET_P (decl)
+      && GET_CODE (DECL_RTL (decl)) == MEM
+      && XEXP (DECL_RTL (decl), 0)
+      && GET_CODE (XEXP (DECL_RTL (decl), 0)) == SYMBOL_REF)
+    SYMBOL_REF_WEAK (XEXP (DECL_RTL (decl), 0)) = 1;
+}
+
+/* Merge weak status between NEWDECL and OLDDECL.  */
+
+void
+merge_weak (tree newdecl, tree olddecl)
+{
+  if (DECL_WEAK (newdecl) == DECL_WEAK (olddecl))
+    return;
+
+  if (DECL_WEAK (newdecl))
+    {
+      tree wd;
+
+      /* NEWDECL is weak, but OLDDECL is not.  */
+
+      /* If we already output the OLDDECL, we're in trouble; we can't
+	 go back and make it weak.  This error cannot caught in
+	 declare_weak because the NEWDECL and OLDDECL was not yet
+	 been merged; therefore, TREE_ASM_WRITTEN was not set.  */
+      if (TREE_ASM_WRITTEN (olddecl))
+	error ("%Jweak declaration of '%D' must precede definition",
+	       newdecl, newdecl);
+
+      /* If we've already generated rtl referencing OLDDECL, we may
+	 have done so in a way that will not function properly with
+	 a weak symbol.  */
+      else if (TREE_USED (olddecl)
+	       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (olddecl)))
+	warning ("%Jweak declaration of '%D' after first use results "
+                 "in unspecified behavior", newdecl, newdecl);
+
+      if (SUPPORTS_WEAK)
+	{
+	  /* We put the NEWDECL on the weak_decls list at some point.
+	     Replace it with the OLDDECL.  */
+	  for (wd = weak_decls; wd; wd = TREE_CHAIN (wd))
+	    if (TREE_VALUE (wd) == newdecl)
+	      {
+		TREE_VALUE (wd) = olddecl;
+		break;
+	      }
+	  /* We may not find the entry on the list.  If NEWDECL is a
+	     weak alias, then we will have already called
+	     globalize_decl to remove the entry; in that case, we do
+	     not need to do anything.  */
+	}
+
+      /* Make the OLDDECL weak; it's OLDDECL that we'll be keeping.  */
+      mark_weak (olddecl);
+    }
+  else
+    /* OLDDECL was weak, but NEWDECL was not explicitly marked as
+       weak.  Just update NEWDECL to indicate that it's weak too.  */
+    mark_weak (newdecl);
+}
+
+/* Declare DECL to be a weak symbol.  */
+
+void
+declare_weak (tree decl)
+{
+  if (! TREE_PUBLIC (decl))
+    error ("%Jweak declaration of '%D' must be public", decl, decl);
+  else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))
+    error ("%Jweak declaration of '%D' must precede definition", decl, decl);
+  else if (SUPPORTS_WEAK)
+    {
+      if (! DECL_WEAK (decl))
+	weak_decls = tree_cons (NULL, decl, weak_decls);
+    }
+  else
+    warning ("%Jweak declaration of '%D' not supported", decl, decl);
+
+  mark_weak (decl);
+}
+
+/* Emit any pending weak declarations.  */
+
+void
+weak_finish (void)
+{
+  tree t;
+
+  for (t = weak_decls; t; t = TREE_CHAIN (t))
+    {
+      tree decl = TREE_VALUE (t);
+#if defined (ASM_WEAKEN_DECL) || defined (ASM_WEAKEN_LABEL)
+      const char *const name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+#endif
+
+      if (! TREE_USED (decl))
+	continue;
+
+#ifdef ASM_WEAKEN_DECL
+      ASM_WEAKEN_DECL (asm_out_file, decl, name, NULL);
+#else
+#ifdef ASM_WEAKEN_LABEL
+      ASM_WEAKEN_LABEL (asm_out_file, name);
+#else
+#ifdef ASM_OUTPUT_WEAK_ALIAS
+      warning ("only weak aliases are supported in this configuration");
+      return;
+#endif
+#endif
+#endif
+    }
+}
+
+/* Emit the assembly bits to indicate that DECL is globally visible.  */
+
+static void
+globalize_decl (tree decl)
+{
+  const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);
+
+#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)
+  if (DECL_WEAK (decl))
+    {
+      tree *p, t;
+
+#ifdef ASM_WEAKEN_DECL
+      ASM_WEAKEN_DECL (asm_out_file, decl, name, 0);
+#else
+      ASM_WEAKEN_LABEL (asm_out_file, name);
+#endif
+
+      /* Remove this function from the pending weak list so that
+	 we do not emit multiple .weak directives for it.  */
+      for (p = &weak_decls; (t = *p) ; )
+	{
+	  if (DECL_ASSEMBLER_NAME (decl) == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))
+	    *p = TREE_CHAIN (t);
+	  else
+	    p = &TREE_CHAIN (t);
+	}
+      return;
+    }
+#endif
+
+  (*targetm.asm_out.globalize_label) (asm_out_file, name);
+}
+
+/* Emit an assembler directive to make the symbol for DECL an alias to
+   the symbol for TARGET.  */
+
+void
+assemble_alias (tree decl, tree target ATTRIBUTE_UNUSED)
+{
+  const char *name;
+
+  /* We must force creation of DECL_RTL for debug info generation, even though
+     we don't use it here.  */
+  make_decl_rtl (decl, NULL);
+
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+
+#ifdef ASM_OUTPUT_DEF
+  /* Make name accessible from other files, if appropriate.  */
+
+  if (TREE_PUBLIC (decl))
+    {
+      globalize_decl (decl);
+      maybe_assemble_visibility (decl);
+    }
+
+#ifdef ASM_OUTPUT_DEF_FROM_DECLS
+  ASM_OUTPUT_DEF_FROM_DECLS (asm_out_file, decl, target);
+#else
+  ASM_OUTPUT_DEF (asm_out_file, name, IDENTIFIER_POINTER (target));
+#endif
+#else /* !ASM_OUTPUT_DEF */
+#if defined (ASM_OUTPUT_WEAK_ALIAS) || defined (ASM_WEAKEN_DECL)
+  if (DECL_WEAK (decl))
+    {
+      tree *p, t;
+#ifdef ASM_WEAKEN_DECL
+      ASM_WEAKEN_DECL (asm_out_file, decl, name, IDENTIFIER_POINTER (target));
+#else
+      ASM_OUTPUT_WEAK_ALIAS (asm_out_file, name, IDENTIFIER_POINTER (target));
+#endif
+      /* Remove this function from the pending weak list so that
+	 we do not emit multiple .weak directives for it.  */
+      for (p = &weak_decls; (t = *p) ; )
+	if (DECL_ASSEMBLER_NAME (decl)
+	    == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))
+	  *p = TREE_CHAIN (t);
+	else
+	  p = &TREE_CHAIN (t);
+    }
+  else
+    warning ("only weak aliases are supported in this configuration");
+
+#else
+  warning ("alias definitions not supported in this configuration; ignored");
+#endif
+#endif
+
+  TREE_USED (decl) = 1;
+  TREE_ASM_WRITTEN (decl) = 1;
+  TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)) = 1;
+}
+
+/* Emit an assembler directive to set symbol for DECL visibility to
+   the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */
+
+void
+default_assemble_visibility (tree decl, int vis)
+{
+  static const char * const visibility_types[] = {
+    NULL, "internal", "hidden", "protected"
+  };
+
+  const char *name, *type;
+
+  name = (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));
+  type = visibility_types[vis];
+
+#ifdef HAVE_GAS_HIDDEN
+  fprintf (asm_out_file, "\t.%s\t", type);
+  assemble_name (asm_out_file, name);
+  fprintf (asm_out_file, "\n");
+#else
+  warning ("visibility attribute not supported in this configuration; ignored");
+#endif
+}
+
+/* A helper function to call assemble_visibility when needed for a decl.  */
+
+static void
+maybe_assemble_visibility (tree decl)
+{
+  enum symbol_visibility vis = DECL_VISIBILITY (decl);
+
+  if (vis != VISIBILITY_DEFAULT)
+    (* targetm.asm_out.visibility) (decl, vis);
+}
+
+/* Returns 1 if the target configuration supports defining public symbols
+   so that one of them will be chosen at link time instead of generating a
+   multiply-defined symbol error, whether through the use of weak symbols or
+   a target-specific mechanism for having duplicates discarded.  */
+
+int
+supports_one_only (void)
+{
+  if (SUPPORTS_ONE_ONLY)
+    return 1;
+  return SUPPORTS_WEAK;
+}
+
+/* Set up DECL as a public symbol that can be defined in multiple
+   translation units without generating a linker error.  */
+
+void
+make_decl_one_only (tree decl)
+{
+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)
+    abort ();
+
+  TREE_PUBLIC (decl) = 1;
+
+  if (SUPPORTS_ONE_ONLY)
+    {
+#ifdef MAKE_DECL_ONE_ONLY
+      MAKE_DECL_ONE_ONLY (decl);
+#endif
+      DECL_ONE_ONLY (decl) = 1;
+    }
+  else if (TREE_CODE (decl) == VAR_DECL
+      && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))
+    DECL_COMMON (decl) = 1;
+  else if (SUPPORTS_WEAK)
+    DECL_WEAK (decl) = 1;
+  else
+    abort ();
+}
+
+void
+init_varasm_once (void)
+{
+  in_named_htab = htab_create_ggc (31, in_named_entry_hash,
+				   in_named_entry_eq, NULL);
+  const_desc_htab = htab_create_ggc (1009, const_desc_hash,
+				     const_desc_eq, NULL);
+
+  const_alias_set = new_alias_set ();
+}
+
+enum tls_model
+decl_tls_model (tree decl)
+{
+  enum tls_model kind;
+  tree attr = lookup_attribute ("tls_model", DECL_ATTRIBUTES (decl));
+  bool is_local;
+
+  if (attr)
+    {
+      attr = TREE_VALUE (TREE_VALUE (attr));
+      if (TREE_CODE (attr) != STRING_CST)
+	abort ();
+      if (!strcmp (TREE_STRING_POINTER (attr), "local-exec"))
+	kind = TLS_MODEL_LOCAL_EXEC;
+      else if (!strcmp (TREE_STRING_POINTER (attr), "initial-exec"))
+	kind = TLS_MODEL_INITIAL_EXEC;
+      else if (!strcmp (TREE_STRING_POINTER (attr), "local-dynamic"))
+	kind = optimize ? TLS_MODEL_LOCAL_DYNAMIC : TLS_MODEL_GLOBAL_DYNAMIC;
+      else if (!strcmp (TREE_STRING_POINTER (attr), "global-dynamic"))
+	kind = TLS_MODEL_GLOBAL_DYNAMIC;
+      else
+	abort ();
+      return kind;
+    }
+
+  is_local = (*targetm.binds_local_p) (decl);
+  if (!flag_pic)
+    {
+      if (is_local)
+	kind = TLS_MODEL_LOCAL_EXEC;
+      else
+	kind = TLS_MODEL_INITIAL_EXEC;
+    }
+  /* Local dynamic is inefficient when we're not combining the
+     parts of the address.  */
+  else if (optimize && is_local)
+    kind = TLS_MODEL_LOCAL_DYNAMIC;
+  else
+    kind = TLS_MODEL_GLOBAL_DYNAMIC;
+  if (kind < flag_tls_default)
+    kind = flag_tls_default;
+
+  return kind;
+}
+
+/* Select a set of attributes for section NAME based on the properties
+   of DECL and whether or not RELOC indicates that DECL's initializer
+   might contain runtime relocations.
+
+   We make the section read-only and executable for a function decl,
+   read-only for a const data decl, and writable for a non-const data decl.  */
+
+unsigned int
+default_section_type_flags (tree decl, const char *name, int reloc)
+{
+  return default_section_type_flags_1 (decl, name, reloc, flag_pic);
+}
+
+unsigned int
+default_section_type_flags_1 (tree decl, const char *name, int reloc,
+			      int shlib)
+{
+  unsigned int flags;
+
+  if (decl && TREE_CODE (decl) == FUNCTION_DECL)
+    flags = SECTION_CODE;
+  else if (decl && decl_readonly_section_1 (decl, reloc, shlib))
+    flags = 0;
+  else
+    flags = SECTION_WRITE;
+
+  if (decl && DECL_ONE_ONLY (decl))
+    flags |= SECTION_LINKONCE;
+
+  if (decl && TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))
+    flags |= SECTION_TLS | SECTION_WRITE;
+
+  if (strcmp (name, ".bss") == 0
+      || strncmp (name, ".bss.", 5) == 0
+      || strncmp (name, ".gnu.linkonce.b.", 16) == 0
+      || strcmp (name, ".sbss") == 0
+      || strncmp (name, ".sbss.", 6) == 0
+      || strncmp (name, ".gnu.linkonce.sb.", 17) == 0
+      || strcmp (name, ".tbss") == 0
+      || strncmp (name, ".gnu.linkonce.tb.", 17) == 0)
+    flags |= SECTION_BSS;
+
+  if (strcmp (name, ".tdata") == 0
+      || strcmp (name, ".tbss") == 0
+      || strncmp (name, ".gnu.linkonce.td.", 17) == 0
+      || strncmp (name, ".gnu.linkonce.tb.", 17) == 0)
+    flags |= SECTION_TLS;
+
+  /* These three sections have special ELF types.  They are neither
+     SHT_PROGBITS nor SHT_NOBITS, so when changing sections we don't
+     want to print a section type (@progbits or @nobits).  If someone
+     is silly enough to emit code or TLS variables to one of these
+     sections, then don't handle them specially.  */
+  if (!(flags & (SECTION_CODE | SECTION_BSS | SECTION_TLS))
+      && (strcmp (name, ".init_array") == 0
+	  || strcmp (name, ".fini_array") == 0
+	  || strcmp (name, ".preinit_array") == 0))
+    flags |= SECTION_NOTYPE;
+
+  return flags;
+}
+
+/* Output assembly to switch to section NAME with attribute FLAGS.
+   Four variants for common object file formats.  */
+
+void
+default_no_named_section (const char *name ATTRIBUTE_UNUSED,
+			  unsigned int flags ATTRIBUTE_UNUSED)
+{
+  /* Some object formats don't support named sections at all.  The
+     front-end should already have flagged this as an error.  */
+  abort ();
+}
+
+void
+default_elf_asm_named_section (const char *name, unsigned int flags)
+{
+  char flagchars[10], *f = flagchars;
+
+  if (! named_section_first_declaration (name))
+    {
+      fprintf (asm_out_file, "\t.section\t%s\n", name);
+      return;
+    }
+
+  if (!(flags & SECTION_DEBUG))
+    *f++ = 'a';
+  if (flags & SECTION_WRITE)
+    *f++ = 'w';
+  if (flags & SECTION_CODE)
+    *f++ = 'x';
+  if (flags & SECTION_SMALL)
+    *f++ = 's';
+  if (flags & SECTION_MERGE)
+    *f++ = 'M';
+  if (flags & SECTION_STRINGS)
+    *f++ = 'S';
+  if (flags & SECTION_TLS)
+    *f++ = 'T';
+  *f = '\0';
+
+  fprintf (asm_out_file, "\t.section\t%s,\"%s\"", name, flagchars);
+
+  if (!(flags & SECTION_NOTYPE))
+    {
+      const char *type;
+
+      if (flags & SECTION_BSS)
+	type = "nobits";
+      else
+	type = "progbits";
+
+      fprintf (asm_out_file, ",@%s", type);
+
+      if (flags & SECTION_ENTSIZE)
+	fprintf (asm_out_file, ",%d", flags & SECTION_ENTSIZE);
+    }
+
+  putc ('\n', asm_out_file);
+}
+
+void
+default_coff_asm_named_section (const char *name, unsigned int flags)
+{
+  char flagchars[8], *f = flagchars;
+
+  if (flags & SECTION_WRITE)
+    *f++ = 'w';
+  if (flags & SECTION_CODE)
+    *f++ = 'x';
+  *f = '\0';
+
+  fprintf (asm_out_file, "\t.section\t%s,\"%s\"\n", name, flagchars);
+}
+
+void
+default_pe_asm_named_section (const char *name, unsigned int flags)
+{
+  default_coff_asm_named_section (name, flags);
+
+  if (flags & SECTION_LINKONCE)
+    {
+      /* Functions may have been compiled at various levels of
+         optimization so we can't use `same_size' here.
+         Instead, have the linker pick one.  */
+      fprintf (asm_out_file, "\t.linkonce %s\n",
+	       (flags & SECTION_CODE ? "discard" : "same_size"));
+    }
+}
+
+/* The lame default section selector.  */
+
+void
+default_select_section (tree decl, int reloc,
+			unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  bool readonly = false;
+
+  if (DECL_P (decl))
+    {
+      if (decl_readonly_section (decl, reloc))
+	readonly = true;
+    }
+  else if (TREE_CODE (decl) == CONSTRUCTOR)
+    {
+      if (! ((flag_pic && reloc)
+	     || !TREE_READONLY (decl)
+	     || TREE_SIDE_EFFECTS (decl)
+	     || !TREE_CONSTANT (decl)))
+	readonly = true;
+    }
+  else if (TREE_CODE (decl) == STRING_CST)
+    readonly = !flag_writable_strings;
+  else if (! (flag_pic && reloc))
+    readonly = true;
+
+  if (readonly)
+    readonly_data_section ();
+  else
+    data_section ();
+}
+
+/* A helper function for default_elf_select_section and
+   default_elf_unique_section.  Categorizes the DECL.  */
+
+enum section_category
+{
+  SECCAT_TEXT,
+
+  SECCAT_RODATA,
+  SECCAT_RODATA_MERGE_STR,
+  SECCAT_RODATA_MERGE_STR_INIT,
+  SECCAT_RODATA_MERGE_CONST,
+  SECCAT_SRODATA,
+
+  SECCAT_DATA,
+
+  /* To optimize loading of shared programs, define following subsections
+     of data section:
+	_REL	Contains data that has relocations, so they get grouped
+		together and dynamic linker will visit fewer pages in memory.
+	_RO	Contains data that is otherwise read-only.  This is useful
+		with prelinking as most relocations won't be dynamically
+		linked and thus stay read only.
+	_LOCAL	Marks data containing relocations only to local objects.
+		These relocations will get fully resolved by prelinking.  */
+  SECCAT_DATA_REL,
+  SECCAT_DATA_REL_LOCAL,
+  SECCAT_DATA_REL_RO,
+  SECCAT_DATA_REL_RO_LOCAL,
+
+  SECCAT_SDATA,
+  SECCAT_TDATA,
+
+  SECCAT_BSS,
+  SECCAT_SBSS,
+  SECCAT_TBSS
+};
+
+static enum section_category
+categorize_decl_for_section (tree, int, int);
+
+static enum section_category
+categorize_decl_for_section (tree decl, int reloc, int shlib)
+{
+  enum section_category ret;
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    return SECCAT_TEXT;
+  else if (TREE_CODE (decl) == STRING_CST)
+    {
+      if (flag_writable_strings)
+	return SECCAT_DATA;
+      else
+	return SECCAT_RODATA_MERGE_STR;
+    }
+  else if (TREE_CODE (decl) == VAR_DECL)
+    {
+      if (DECL_INITIAL (decl) == NULL
+	  || DECL_INITIAL (decl) == error_mark_node)
+	ret = SECCAT_BSS;
+      else if (! TREE_READONLY (decl)
+	       || TREE_SIDE_EFFECTS (decl)
+	       || ! TREE_CONSTANT (DECL_INITIAL (decl)))
+	{
+	  if (shlib && (reloc & 2))
+	    ret = SECCAT_DATA_REL;
+	  else if (shlib && reloc)
+	    ret = SECCAT_DATA_REL_LOCAL;
+	  else
+	    ret = SECCAT_DATA;
+	}
+      else if (shlib && (reloc & 2))
+	ret = SECCAT_DATA_REL_RO;
+      else if (shlib && reloc)
+	ret = SECCAT_DATA_REL_RO_LOCAL;
+      else if (reloc || flag_merge_constants < 2)
+	/* C and C++ don't allow different variables to share the same
+	   location.  -fmerge-all-constants allows even that (at the
+	   expense of not conforming).  */
+	ret = SECCAT_RODATA;
+      else if (TREE_CODE (DECL_INITIAL (decl)) == STRING_CST)
+	ret = SECCAT_RODATA_MERGE_STR_INIT;
+      else
+	ret = SECCAT_RODATA_MERGE_CONST;
+    }
+  else if (TREE_CODE (decl) == CONSTRUCTOR)
+    {
+      if ((shlib && reloc)
+	  || TREE_SIDE_EFFECTS (decl)
+	  || ! TREE_CONSTANT (decl))
+	ret = SECCAT_DATA;
+      else
+	ret = SECCAT_RODATA;
+    }
+  else
+    ret = SECCAT_RODATA;
+
+  /* There are no read-only thread-local sections.  */
+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))
+    {
+      if (ret == SECCAT_BSS)
+	ret = SECCAT_TBSS;
+      else
+	ret = SECCAT_TDATA;
+    }
+
+  /* If the target uses small data sections, select it.  */
+  else if ((*targetm.in_small_data_p) (decl))
+    {
+      if (ret == SECCAT_BSS)
+	ret = SECCAT_SBSS;
+      else if (targetm.have_srodata_section && ret == SECCAT_RODATA)
+	ret = SECCAT_SRODATA;
+      else
+	ret = SECCAT_SDATA;
+    }
+
+  return ret;
+}
+
+bool
+decl_readonly_section (tree decl, int reloc)
+{
+  return decl_readonly_section_1 (decl, reloc, flag_pic);
+}
+
+bool
+decl_readonly_section_1 (tree decl, int reloc, int shlib)
+{
+  switch (categorize_decl_for_section (decl, reloc, shlib))
+    {
+    case SECCAT_RODATA:
+    case SECCAT_RODATA_MERGE_STR:
+    case SECCAT_RODATA_MERGE_STR_INIT:
+    case SECCAT_RODATA_MERGE_CONST:
+    case SECCAT_SRODATA:
+      return true;
+      break;
+    default:
+      return false;
+      break;
+    }
+}
+
+/* Select a section based on the above categorization.  */
+
+void
+default_elf_select_section (tree decl, int reloc,
+			    unsigned HOST_WIDE_INT align)
+{
+  default_elf_select_section_1 (decl, reloc, align, flag_pic);
+}
+
+void
+default_elf_select_section_1 (tree decl, int reloc,
+			      unsigned HOST_WIDE_INT align, int shlib)
+{
+  switch (categorize_decl_for_section (decl, reloc, shlib))
+    {
+    case SECCAT_TEXT:
+      /* We're not supposed to be called on FUNCTION_DECLs.  */
+      abort ();
+    case SECCAT_RODATA:
+      readonly_data_section ();
+      break;
+    case SECCAT_RODATA_MERGE_STR:
+      mergeable_string_section (decl, align, 0);
+      break;
+    case SECCAT_RODATA_MERGE_STR_INIT:
+      mergeable_string_section (DECL_INITIAL (decl), align, 0);
+      break;
+    case SECCAT_RODATA_MERGE_CONST:
+      mergeable_constant_section (DECL_MODE (decl), align, 0);
+      break;
+    case SECCAT_SRODATA:
+      named_section (decl, ".sdata2", reloc);
+      break;
+    case SECCAT_DATA:
+      data_section ();
+      break;
+    case SECCAT_DATA_REL:
+      named_section (decl, ".data.rel", reloc);
+      break;
+    case SECCAT_DATA_REL_LOCAL:
+      named_section (decl, ".data.rel.local", reloc);
+      break;
+    case SECCAT_DATA_REL_RO:
+      named_section (decl, ".data.rel.ro", reloc);
+      break;
+    case SECCAT_DATA_REL_RO_LOCAL:
+      named_section (decl, ".data.rel.ro.local", reloc);
+      break;
+    case SECCAT_SDATA:
+      named_section (decl, ".sdata", reloc);
+      break;
+    case SECCAT_TDATA:
+      named_section (decl, ".tdata", reloc);
+      break;
+    case SECCAT_BSS:
+#ifdef BSS_SECTION_ASM_OP
+      bss_section ();
+#else
+      named_section (decl, ".bss", reloc);
+#endif
+      break;
+    case SECCAT_SBSS:
+      named_section (decl, ".sbss", reloc);
+      break;
+    case SECCAT_TBSS:
+      named_section (decl, ".tbss", reloc);
+      break;
+    default:
+      abort ();
+    }
+}
+
+/* Construct a unique section name based on the decl name and the
+   categorization performed above.  */
+
+void
+default_unique_section (tree decl, int reloc)
+{
+  default_unique_section_1 (decl, reloc, flag_pic);
+}
+
+void
+default_unique_section_1 (tree decl, int reloc, int shlib)
+{
+  bool one_only = DECL_ONE_ONLY (decl);
+  const char *prefix, *name;
+  size_t nlen, plen;
+  char *string;
+
+  switch (categorize_decl_for_section (decl, reloc, shlib))
+    {
+    case SECCAT_TEXT:
+      prefix = one_only ? ".gnu.linkonce.t." : ".text.";
+      break;
+    case SECCAT_RODATA:
+    case SECCAT_RODATA_MERGE_STR:
+    case SECCAT_RODATA_MERGE_STR_INIT:
+    case SECCAT_RODATA_MERGE_CONST:
+      prefix = one_only ? ".gnu.linkonce.r." : ".rodata.";
+      break;
+    case SECCAT_SRODATA:
+      prefix = one_only ? ".gnu.linkonce.s2." : ".sdata2.";
+      break;
+    case SECCAT_DATA:
+    case SECCAT_DATA_REL:
+    case SECCAT_DATA_REL_LOCAL:
+    case SECCAT_DATA_REL_RO:
+    case SECCAT_DATA_REL_RO_LOCAL:
+      prefix = one_only ? ".gnu.linkonce.d." : ".data.";
+      break;
+    case SECCAT_SDATA:
+      prefix = one_only ? ".gnu.linkonce.s." : ".sdata.";
+      break;
+    case SECCAT_BSS:
+      prefix = one_only ? ".gnu.linkonce.b." : ".bss.";
+      break;
+    case SECCAT_SBSS:
+      prefix = one_only ? ".gnu.linkonce.sb." : ".sbss.";
+      break;
+    case SECCAT_TDATA:
+      prefix = one_only ? ".gnu.linkonce.td." : ".tdata.";
+      break;
+    case SECCAT_TBSS:
+      prefix = one_only ? ".gnu.linkonce.tb." : ".tbss.";
+      break;
+    default:
+      abort ();
+    }
+  plen = strlen (prefix);
+
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+  name = (* targetm.strip_name_encoding) (name);
+  nlen = strlen (name);
+
+  string = alloca (nlen + plen + 1);
+  memcpy (string, prefix, plen);
+  memcpy (string + plen, name, nlen + 1);
+
+  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
+}
+
+void
+default_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,
+			    rtx x,
+			    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  if (flag_pic)
+    switch (GET_CODE (x))
+      {
+      case CONST:
+      case SYMBOL_REF:
+      case LABEL_REF:
+	data_section ();
+	return;
+
+      default:
+	break;
+      }
+
+  readonly_data_section ();
+}
+
+void
+default_elf_select_rtx_section (enum machine_mode mode, rtx x,
+				unsigned HOST_WIDE_INT align)
+{
+  /* ??? Handle small data here somehow.  */
+
+  if (flag_pic)
+    switch (GET_CODE (x))
+      {
+      case CONST:
+      case SYMBOL_REF:
+	named_section (NULL_TREE, ".data.rel.ro", 3);
+	return;
+
+      case LABEL_REF:
+	named_section (NULL_TREE, ".data.rel.ro.local", 1);
+	return;
+
+      default:
+	break;
+      }
+
+  mergeable_constant_section (mode, align, 0);
+}
+
+/* Set the generally applicable flags on the SYMBOL_REF for EXP.  */
+
+void
+default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+{
+  rtx symbol;
+  int flags;
+
+  /* Careful not to prod global register variables.  */
+  if (GET_CODE (rtl) != MEM)
+    return;
+  symbol = XEXP (rtl, 0);
+  if (GET_CODE (symbol) != SYMBOL_REF)
+    return;
+
+  flags = 0;
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    flags |= SYMBOL_FLAG_FUNCTION;
+  if ((*targetm.binds_local_p) (decl))
+    flags |= SYMBOL_FLAG_LOCAL;
+  if ((*targetm.in_small_data_p) (decl))
+    flags |= SYMBOL_FLAG_SMALL;
+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))
+    flags |= decl_tls_model (decl) << SYMBOL_FLAG_TLS_SHIFT;
+  /* ??? Why is DECL_EXTERNAL ever set for non-PUBLIC names?  Without
+     being PUBLIC, the thing *must* be defined in this translation unit.
+     Prevent this buglet from being propagated into rtl code as well.  */
+  if (DECL_P (decl) && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))
+    flags |= SYMBOL_FLAG_EXTERNAL;
+
+  SYMBOL_REF_FLAGS (symbol) = flags;
+}
+
+/* By default, we do nothing for encode_section_info, so we need not
+   do anything but discard the '*' marker.  */
+
+const char *
+default_strip_name_encoding (const char *str)
+{
+  return str + (*str == '*');
+}
+
+/* Assume ELF-ish defaults, since that's pretty much the most liberal
+   wrt cross-module name binding.  */
+
+bool
+default_binds_local_p (tree exp)
+{
+  return default_binds_local_p_1 (exp, flag_shlib);
+}
+
+bool
+default_binds_local_p_1 (tree exp, int shlib)
+{
+  bool local_p;
+
+  /* A non-decl is an entry in the constant pool.  */
+  if (!DECL_P (exp))
+    local_p = true;
+  /* Static variables are always local.  */
+  else if (! TREE_PUBLIC (exp))
+    local_p = true;
+  /* A variable is local if the user tells us so.  */
+  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
+    local_p = true;
+  /* Otherwise, variables defined outside this object may not be local.  */
+  else if (DECL_EXTERNAL (exp))
+    local_p = false;
+  /* Linkonce and weak data are never local.  */
+  else if (DECL_ONE_ONLY (exp) || DECL_WEAK (exp))
+    local_p = false;
+  /* If PIC, then assume that any global name can be overridden by
+     symbols resolved from other modules.  */
+  else if (shlib)
+    local_p = false;
+  /* Uninitialized COMMON variable may be unified with symbols
+     resolved from other modules.  */
+  else if (DECL_COMMON (exp)
+	   && (DECL_INITIAL (exp) == NULL
+	       || DECL_INITIAL (exp) == error_mark_node))
+    local_p = false;
+  /* Otherwise we're left with initialized (or non-common) global data
+     which is of necessity defined locally.  */
+  else
+    local_p = true;
+
+  return local_p;
+}
+
+/* Determine whether or not a pointer mode is valid. Assume defaults
+   of ptr_mode or Pmode - can be overridden.  */
+bool
+default_valid_pointer_mode (enum machine_mode mode)
+{
+  return (mode == ptr_mode || mode == Pmode);
+}
+
+/* Default function to output code that will globalize a label.  A
+   target must define GLOBAL_ASM_OP or provide it's own function to
+   globalize a label.  */
+#ifdef GLOBAL_ASM_OP
+void
+default_globalize_label (FILE * stream, const char *name)
+{
+  fputs (GLOBAL_ASM_OP, stream);
+  assemble_name (stream, name);
+  putc ('\n', stream);
+}
+#endif /* GLOBAL_ASM_OP */
+
+/* This is how to output an internal numbered label where PREFIX is
+   the class of label and LABELNO is the number within the class.  */
+
+void
+default_internal_label (FILE *stream, const char *prefix,
+			unsigned long labelno)
+{
+  char *const buf = alloca (40 + strlen (prefix));
+  ASM_GENERATE_INTERNAL_LABEL (buf, prefix, labelno);
+  ASM_OUTPUT_LABEL (stream, buf);
+}
+
+/* This is the default behavior at the beginning of a file.  It's
+   controlled by two other target-hook toggles.  */
+void
+default_file_start (void)
+{
+  if (targetm.file_start_app_off && !flag_verbose_asm)
+    fputs (ASM_APP_OFF, asm_out_file);
+
+  if (targetm.file_start_file_directive)
+    output_file_directive (asm_out_file, main_input_filename);
+}
+
+/* This is a generic routine suitable for use as TARGET_ASM_FILE_END
+   which emits a special section directive used to indicate whether or
+   not this object file needs an executable stack.  This is primarily
+   a GNU extension to ELF but could be used on other targets.  */
+void
+file_end_indicate_exec_stack (void)
+{
+  unsigned int flags = SECTION_DEBUG;
+  if (trampolines_created)
+    flags |= SECTION_CODE;
+
+  named_section_flags (".note.GNU-stack", flags);
+}
+
+#include "gt-varasm.h"
diff -Nbaur gcc-3.4.3/gcc/version.c gcc-3.4.3-new/gcc/version.c
--- gcc-3.4.3/gcc/version.c	Fri Nov  5 03:35:02 2004
+++ gcc-3.4.3-new/gcc/version.c	Fri Jan 21 10:25:51 2005
@@ -14,4 +14,4 @@
    forward us bugs reported to you, if you determine that they are
    not bugs in your modifications.)  */
 
-const char bug_report_url[] = "<URL:http://gcc.gnu.org/bugs.html>";
+const char bug_report_url[] = "<URL:http://www.mingw.org/bugs.shtml>";
diff -Nbaur gcc-3.4.3/include/libiberty.h gcc-3.4.3-new/include/libiberty.h
--- gcc-3.4.3/include/libiberty.h	Thu May 15 20:02:12 2003
+++ gcc-3.4.3-new/include/libiberty.h	Fri Jan 21 10:25:51 2005
@@ -1,6 +1,6 @@
 /* Function declarations for libiberty.
 
-   Copyright 2001, 2002 Free Software Foundation, Inc.
+   Copyright 2001, 2002, 2004 Free Software Foundation, Inc.
    
    Note - certain prototypes declared in this header file are for
    functions whoes implementation copyright does not belong to the
@@ -41,6 +41,8 @@
 
 #include "ansidecl.h"
 
+#include <stdio.h>
+
 #ifdef ANSI_PROTOTYPES
 /* Get a definition for size_t.  */
 #include <stddef.h>
@@ -74,7 +76,7 @@
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__sun__) || defined (HAVE_DECL_BASENAME)
 extern char *basename PARAMS ((const char *));
 #else
 extern char *basename ();
@@ -274,7 +276,7 @@
 extern int pexecute PARAMS ((const char *, char * const *, const char *,
 			    const char *, char **, char **, int));
 
-/* Wait for pexecute to finish.  */
+/* Wait for a process created by pexecute.  */
 
 extern int pwait PARAMS ((int, int *, int));
 
diff -Nbaur gcc-3.4.3/include/pex-read.h gcc-3.4.3-new/include/pex-read.h
--- gcc-3.4.3/include/pex-read.h	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/include/pex-read.h	Fri Jan 21 10:25:51 2005
@@ -0,0 +1,41 @@
+/* Declarations of the pex-read functions for libiberty.
+   Copyright 2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef PEX_READ_H
+#define PEX_READ_H
+
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+ 
+/* Execute a program and read its standard output.  */
+
+extern FILE *pex_read (const char *, char * const *, const char *,
+		       const char *, char **, char **, int, int *);
+
+/* Wait for pex_read to finish.  */
+
+extern int pex_read_close (int, FILE *, int *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PEX_READ_H */
diff -Nbaur gcc-3.4.3/libiberty/ChangeLog gcc-3.4.3-new/libiberty/ChangeLog
--- gcc-3.4.3/libiberty/ChangeLog	Fri Nov  5 03:34:35 2004
+++ gcc-3.4.3-new/libiberty/ChangeLog	Fri Jan 21 10:25:52 2005
@@ -14,11 +14,33 @@
 
 	* GCC 3.4.0 released.
 
-2004-02-25  Ian Lance Taylor  <ian@wasabisystems.com>
+2004-03-17  Ian Lance Taylor  <ian@wasabisystems.com>
 
-	Taken from mainline:
+	* pex-unix.c (pexecute): Use vfork instead of fork, with
+	appropriate changes to make this safe.
+	* pex-common.h (STDERR_FILE_NO): Define.
 
-	2004-02-24  Ian Lance Taylor  <ian@wasabisystems.com>
+	* Makefile.in: Clean up REQUIRED_OFILES and CONFIGURED_OFILES for
+	an 80 column screen.  Run maint-deps.
+
+2004-03-09  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.ac: Bump version to 2.59.  Apply suggested autoupdates.
+	* acconfig.h: Delete redundant file.
+	* config.in: Regenerate.
+	* configure: Regenerate.
+
+2004-03-09  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure: Regenerate for config/accross.m4 correction.
+
+2004-03-07  Andreas Jaeger  <aj@suse.de>
+
+	* testsuite/test-demangle.c: Include <string.h> and <stdlib.h> for
+	prototypes.
+	(main): Initialize style.
+
+2004-02-24  Ian Lance Taylor  <ian@wasabisystems.com>
 
 	* cp-demangle.h (enum d_builtin_type_print): Add D_PRINT_UNSIGNED,
 	D_PRINT_UNSIGNED_LONG, D_PRINT_LONG_LONG,
@@ -51,7 +73,7 @@
 	past ones which have been printed already.
 	* testsuite/demangle-expected: Add three test cases.
 
-	2004-02-23  Ian Lance Taylor  <ian@wasabisystems.com>
+2004-02-23  Ian Lance Taylor  <ian@wasabisystems.com>
 
 	* cp-demangle.c (__cxa_demangle): Adjust last patch to handle
 	empty string correctly.
@@ -61,6 +83,29 @@
 	built-in type name.
 	(main): If IN_GLIBCPP_V3 is defined, test __cxa_demangle rather
 	than cplus_demangle_v3.
+
+	* dyn-string.c: Remove test of IN_LIBGCC2 and IN_GLIBCPP_V3 and
+	the associated #define of RETURN_ON_ALLOCATION_FAILURE.
+
+2004-02-16  Matt Kraai  <kraai@alumni.cmu.edu>
+
+	* regex.c: Include <ansidecl.h>.
+	(regcomp): Cast i to int.
+	(regerror): Add ATTRIBUTE_UNUSED to parameter preg.
+
+2004-01-25  Ian Lance Taylor  <ian@wasabisystems.com>
+
+	* configure.ac: Add m4_pattern_allow(LIBOBJS).
+	* configure: Regenerate.
+
+2004-01-22  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.in: Convert to ./ throughout.  Rebuild dependencies
+	with explicit build rules.
+	(VPATH): Remove.
+	(.c.o): Poison.
+	* configure.ac (pexecute, LIBOBJS): Add ./ .
+	* maint-tool: Build dependencies with explicit rules.
 
 2004-01-15  Kazu Hirata  <kazu@cs.umass.edu>
 
diff -Nbaur gcc-3.4.3/libiberty/Makefile.in gcc-3.4.3-new/libiberty/Makefile.in
--- gcc-3.4.3/libiberty/Makefile.in	Wed Jan 14 21:27:28 2004
+++ gcc-3.4.3-new/libiberty/Makefile.in	Fri Jan 21 10:25:52 2005
@@ -28,7 +28,6 @@
 
 libiberty_topdir = @libiberty_topdir@
 srcdir = @srcdir@
-VPATH = @srcdir@
 
 prefix = @prefix@
 
@@ -70,8 +69,8 @@
 
 MAKEOVERRIDES =
 
-TARGETLIB = libiberty.a
-TESTLIB = testlib.a
+TARGETLIB = ./libiberty.a
+TESTLIB = ./testlib.a
 
 LIBOBJS = @LIBOBJS@
 
@@ -118,15 +117,15 @@
 INCDIR=$(srcdir)/$(MULTISRCTOP)../include
 
 COMPILE.c = $(CC) -c @DEFS@ $(LIBCFLAGS) -I. -I$(INCDIR) $(HDEFINES) @ac_libiberty_warn_cflags@
+
+# Just to make sure we don't use a built-in rule with VPATH
 .c.o:
-	if [ x"$(PICFLAG)" != x ]; then \
-	  $(COMPILE.c) $(PICFLAG) $< -o pic/$@; \
-	else true; fi
-	$(COMPILE.c) $< $(OUTPUT_OPTION)
+	false
 
 # NOTE: If you add new files to the library, add them to this list
 # (alphabetical), and add them to REQUIRED_OFILES, or
-# CONFIGURED_OFILES and funcs in configure.ac.
+# CONFIGURED_OFILES and funcs in configure.ac.  Also run "make maint-deps"
+# to build the new rules.
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
@@ -145,6 +144,7 @@
 	partition.c							\
 	 pex-djgpp.c pex-mpw.c pex-msdos.c pex-os2.c			\
 	 pex-unix.c pex-win32.c						\
+	 pexrd-unix.c pexrd-generic.c					\
          physmem.c putenv.c						\
 	random.c regex.c rename.c rindex.c				\
 	safe-ctype.c setenv.c sigsetmask.c snprintf.c sort.c spaces.c	\
@@ -158,45 +158,48 @@
 
 # These are always included in the library.  The first four are listed
 # first and by compile time to optimize parallel builds.
-REQUIRED_OFILES = regex.o cplus-dem.o cp-demangle.o cp-demint.o md5.o	\
-	alloca.o argv.o							\
-	choose-temp.o concat.o						\
-	dyn-string.o							\
-	fdmatch.o fibheap.o floatformat.o fnmatch.o			\
-	getopt.o getopt1.o getpwd.o getruntime.o			\
-	hashtab.o hex.o							\
-	lbasename.o							\
-	lrealpath.o							\
-	make-relative-prefix.o						\
-	make-temp-file.o						\
-	objalloc.o obstack.o						\
-	partition.o physmem.o @pexecute@						\
-	safe-ctype.o sort.o spaces.o splay-tree.o strerror.o		\
-	 strsignal.o							\
-	ternary.o							\
-	xatexit.o xexit.o xmalloc.o xmemdup.o xstrdup.o xstrerror.o
+REQUIRED_OFILES = ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o	\
+	./alloca.o ./argv.o						\
+	./choose-temp.o ./concat.o ./cp-demint.o			\
+	./dyn-string.o							\
+	./fdmatch.o ./fibheap.o ./floatformat.o ./fnmatch.o		\
+	./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o		\
+	./hashtab.o ./hex.o						\
+	./lbasename.o ./lrealpath.o					\
+	./make-relative-prefix.o ./make-temp-file.o			\
+	./objalloc.o ./obstack.o					\
+	./partition.o ./physmem.o @pexecute@				\
+	./safe-ctype.o ./sort.o ./spaces.o ./splay-tree.o ./strerror.o	\
+	 ./strsignal.o							\
+	./ternary.o							\
+	./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o	\
+	 ./xstrerror.o
 
 # These are all the objects that configure may add to the library via
 # $funcs or EXTRA_OFILES.  This list exists here only for "make
 # maint-missing" and "make check".
-CONFIGURED_OFILES = asprintf.o atexit.o					\
-	basename.o bcmp.o bcopy.o bsearch.o bzero.o			\
-	calloc.o clock.o copysign.o					\
-	_doprnt.o							\
-	ffs.o								\
-	getcwd.o getpagesize.o						\
-	index.o insque.o						\
-	memchr.o memcmp.o memcpy.o memmove.o mempcpy.o memset.o mkstemps.o \
-	pex-djgpp.o pex-mpw.o pex-msdos.o pex-os2.o			\
-	 pex-unix.o pex-win32.o						\
-	 putenv.o							\
-	random.o rename.o rindex.o					\
-	setenv.o sigsetmask.o snprintf.o stpcpy.o stpncpy.o strcasecmp.o \
-	 strchr.o strdup.o strncasecmp.o strncmp.o strrchr.o strstr.o	\
-	 strtod.o strtol.o strtoul.o					\
-	tmpnam.o							\
-	vasprintf.o vfork.o vfprintf.o vprintf.o vsnprintf.o vsprintf.o	\
-	waitpid.o
+CONFIGURED_OFILES = ./asprintf.o ./atexit.o				\
+	./basename.o ./bcmp.o ./bcopy.o ./bsearch.o ./bzero.o		\
+	./calloc.o ./clock.o ./copysign.o				\
+	./_doprnt.o							\
+	./ffs.o								\
+	./getcwd.o ./getpagesize.o					\
+	./index.o ./insque.o						\
+	./memchr.o ./memcmp.o ./memcpy.o ./memmove.o ./mempcpy.o	\
+	 ./memset.o ./mkstemps.o					\
+	./pex-djgpp.o ./pex-mpw.o ./pex-msdos.o ./pex-os2.o		\
+	 ./pex-unix.o ./pex-win32.o					\
+	 ./pexrd-unix.o ./pexrd-generic.o				\
+	 ./putenv.o							\
+	./random.o ./rename.o ./rindex.o				\
+	./setenv.o ./sigsetmask.o ./snprintf.o ./stpcpy.o ./stpncpy.o	\
+	 ./strcasecmp.o ./strchr.o ./strdup.o ./strncasecmp.o		\
+	 ./strncmp.o ./strrchr.o ./strstr.o				\
+	 ./strtod.o ./strtol.o ./strtoul.o				\
+	./tmpnam.o							\
+	./vasprintf.o ./vfork.o ./vfprintf.o ./vprintf.o ./vsnprintf.o	\
+	 ./vsprintf.o							\
+	./waitpid.o
 
 # These files are installed if the library has been configured to do so.
 INSTALLED_HEADERS =                                                     \
@@ -390,8 +393,8 @@
 # Depending on Makefile makes sure that config.status has been re-run
 # if needed.  This prevents problems with parallel builds.
 config.h: stamp-h ; @true
-stamp-h: config.in config.status Makefile
-	CONFIG_FILES= CONFIG_HEADERS=config.h:config.in $(SHELL) ./config.status
+stamp-h: $(srcdir)/config.in config.status Makefile
+	CONFIG_FILES= CONFIG_HEADERS=config.h:$(srcdir)/config.in $(SHELL) ./config.status
 
 config.status: $(srcdir)/configure $(srcdir)/config.table
 	$(SHELL) ./config.status --recheck
@@ -415,113 +418,658 @@
 # The dependencies in the remainder of this file are automatically
 # generated by "make maint-deps".  Manual edits will be lost.
 
-_doprnt.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/safe-ctype.h
-alloca.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-argv.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-asprintf.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-atexit.o: config.h
-basename.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+./_doprnt.o: $(srcdir)/_doprnt.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/safe-ctype.h
-bsearch.o: config.h $(INCDIR)/ansidecl.h
-calloc.o: $(INCDIR)/ansidecl.h
-choose-temp.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-clock.o: config.h
-concat.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-copysign.o: $(INCDIR)/ansidecl.h
-cp-demangle.o: config.h $(INCDIR)/ansidecl.h $(srcdir)/cp-demangle.h \
-	$(INCDIR)/demangle.h $(INCDIR)/dyn-string.h $(INCDIR)/getopt.h \
-	$(INCDIR)/libiberty.h
-cp-demint.o: config.h $(INCDIR)/ansidecl.h $(srcdir)/cp-demangle.h \
-	$(INCDIR)/demangle.h $(INCDIR)/libiberty.h
-cplus-dem.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/demangle.h \
-	$(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
-dyn-string.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/dyn-string.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/_doprnt.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/_doprnt.c $(OUTPUT_OPTION)
+
+./alloca.o: $(srcdir)/alloca.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
-fdmatch.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-fibheap.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/fibheap.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/alloca.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/alloca.c $(OUTPUT_OPTION)
+
+./argv.o: $(srcdir)/argv.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/argv.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/argv.c $(OUTPUT_OPTION)
+
+./asprintf.o: $(srcdir)/asprintf.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/asprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/asprintf.c $(OUTPUT_OPTION)
+
+./atexit.o: $(srcdir)/atexit.c config.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/atexit.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/atexit.c $(OUTPUT_OPTION)
+
+./basename.o: $(srcdir)/basename.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/basename.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/basename.c $(OUTPUT_OPTION)
+
+./bcmp.o: $(srcdir)/bcmp.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/bcmp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/bcmp.c $(OUTPUT_OPTION)
+
+./bcopy.o: $(srcdir)/bcopy.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/bcopy.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/bcopy.c $(OUTPUT_OPTION)
+
+./bsearch.o: $(srcdir)/bsearch.c config.h $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/bsearch.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/bsearch.c $(OUTPUT_OPTION)
+
+./bzero.o: $(srcdir)/bzero.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/bzero.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/bzero.c $(OUTPUT_OPTION)
+
+./calloc.o: $(srcdir)/calloc.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/calloc.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/calloc.c $(OUTPUT_OPTION)
+
+./choose-temp.o: $(srcdir)/choose-temp.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
-floatformat.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/floatformat.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/choose-temp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/choose-temp.c $(OUTPUT_OPTION)
+
+./clock.o: $(srcdir)/clock.c config.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/clock.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/clock.c $(OUTPUT_OPTION)
+
+./concat.o: $(srcdir)/concat.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
-fnmatch.o: config.h $(INCDIR)/fnmatch.h $(INCDIR)/safe-ctype.h
-getcwd.o: config.h
-getopt.o: config.h $(INCDIR)/getopt.h
-getopt1.o: config.h $(INCDIR)/getopt.h
-getpagesize.o: config.h
-getpwd.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-getruntime.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-hashtab.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/hashtab.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/concat.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/concat.c $(OUTPUT_OPTION)
+
+./copysign.o: $(srcdir)/copysign.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/copysign.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/copysign.c $(OUTPUT_OPTION)
+
+./cp-demangle.o: $(srcdir)/cp-demangle.c config.h $(INCDIR)/ansidecl.h \
+	$(srcdir)/cp-demangle.h $(INCDIR)/demangle.h \
+	$(INCDIR)/dyn-string.h $(INCDIR)/getopt.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cp-demangle.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cp-demangle.c $(OUTPUT_OPTION)
+
+./cp-demint.o: $(srcdir)/cp-demint.c config.h $(INCDIR)/ansidecl.h \
+	$(srcdir)/cp-demangle.h $(INCDIR)/demangle.h \
 	$(INCDIR)/libiberty.h
-hex.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cp-demint.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cp-demint.c $(OUTPUT_OPTION)
+
+./cplus-dem.o: $(srcdir)/cplus-dem.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/demangle.h $(INCDIR)/libiberty.h \
 	$(INCDIR)/safe-ctype.h
-lbasename.o: $(INCDIR)/ansidecl.h $(INCDIR)/filenames.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cplus-dem.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cplus-dem.c $(OUTPUT_OPTION)
+
+./dyn-string.o: $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/dyn-string.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/dyn-string.c $(OUTPUT_OPTION)
+
+./fdmatch.o: $(srcdir)/fdmatch.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/fdmatch.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/fdmatch.c $(OUTPUT_OPTION)
+
+./ffs.o: $(srcdir)/ffs.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/ffs.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/ffs.c $(OUTPUT_OPTION)
+
+./fibheap.o: $(srcdir)/fibheap.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/fibheap.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/fibheap.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/fibheap.c $(OUTPUT_OPTION)
+
+./floatformat.o: $(srcdir)/floatformat.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/floatformat.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/floatformat.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/floatformat.c $(OUTPUT_OPTION)
+
+./fnmatch.o: $(srcdir)/fnmatch.c config.h $(INCDIR)/fnmatch.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/fnmatch.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/fnmatch.c $(OUTPUT_OPTION)
+
+./getcwd.o: $(srcdir)/getcwd.c config.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getcwd.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getcwd.c $(OUTPUT_OPTION)
+
+./getopt.o: $(srcdir)/getopt.c config.h $(INCDIR)/getopt.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getopt.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getopt.c $(OUTPUT_OPTION)
+
+./getopt1.o: $(srcdir)/getopt1.c config.h $(INCDIR)/getopt.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getopt1.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getopt1.c $(OUTPUT_OPTION)
+
+./getpagesize.o: $(srcdir)/getpagesize.c config.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getpagesize.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getpagesize.c $(OUTPUT_OPTION)
+
+./getpwd.o: $(srcdir)/getpwd.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getpwd.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getpwd.c $(OUTPUT_OPTION)
+
+./getruntime.o: $(srcdir)/getruntime.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/getruntime.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/getruntime.c $(OUTPUT_OPTION)
+
+./hashtab.o: $(srcdir)/hashtab.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/hashtab.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/hashtab.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/hashtab.c $(OUTPUT_OPTION)
+
+./hex.o: $(srcdir)/hex.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/hex.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/hex.c $(OUTPUT_OPTION)
+
+./index.o: $(srcdir)/index.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/index.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/index.c $(OUTPUT_OPTION)
+
+./insque.o: $(srcdir)/insque.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/insque.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/insque.c $(OUTPUT_OPTION)
+
+./lbasename.o: $(srcdir)/lbasename.c $(INCDIR)/ansidecl.h $(INCDIR)/filenames.h \
 	$(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
-lrealpath.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-make-relative-prefix.o: config.h $(INCDIR)/ansidecl.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/lbasename.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/lbasename.c $(OUTPUT_OPTION)
+
+./lrealpath.o: $(srcdir)/lrealpath.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/lrealpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/lrealpath.c $(OUTPUT_OPTION)
+
+./make-relative-prefix.o: $(srcdir)/make-relative-prefix.c config.h \
+	$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/make-relative-prefix.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/make-relative-prefix.c $(OUTPUT_OPTION)
+
+./make-temp-file.o: $(srcdir)/make-temp-file.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/make-temp-file.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/make-temp-file.c $(OUTPUT_OPTION)
+
+./md5.o: $(srcdir)/md5.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/md5.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/md5.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/md5.c $(OUTPUT_OPTION)
+
+./memchr.o: $(srcdir)/memchr.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/memchr.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/memchr.c $(OUTPUT_OPTION)
+
+./memcmp.o: $(srcdir)/memcmp.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/memcmp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/memcmp.c $(OUTPUT_OPTION)
+
+./memcpy.o: $(srcdir)/memcpy.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/memcpy.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/memcpy.c $(OUTPUT_OPTION)
+
+./memmove.o: $(srcdir)/memmove.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/memmove.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/memmove.c $(OUTPUT_OPTION)
+
+./mempcpy.o: $(srcdir)/mempcpy.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/mempcpy.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/mempcpy.c $(OUTPUT_OPTION)
+
+./memset.o: $(srcdir)/memset.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/memset.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/memset.c $(OUTPUT_OPTION)
+
+./mkstemps.o: $(srcdir)/mkstemps.c config.h $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/mkstemps.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/mkstemps.c $(OUTPUT_OPTION)
+
+./mpw.o: $(srcdir)/mpw.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/mpw.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/mpw.c $(OUTPUT_OPTION)
+
+./msdos.o: $(srcdir)/msdos.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/msdos.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/msdos.c $(OUTPUT_OPTION)
+
+./objalloc.o: $(srcdir)/objalloc.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/objalloc.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/objalloc.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/objalloc.c $(OUTPUT_OPTION)
+
+./obstack.o: $(srcdir)/obstack.c config.h $(INCDIR)/obstack.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/obstack.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/obstack.c $(OUTPUT_OPTION)
+
+./partition.o: $(srcdir)/partition.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(INCDIR)/partition.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/partition.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/partition.c $(OUTPUT_OPTION)
+
+./pex-djgpp.o: $(srcdir)/pex-djgpp.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-djgpp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-djgpp.c $(OUTPUT_OPTION)
+
+./pex-mpw.o: $(srcdir)/pex-mpw.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-mpw.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-mpw.c $(OUTPUT_OPTION)
+
+./pex-msdos.o: $(srcdir)/pex-msdos.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-msdos.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-msdos.c $(OUTPUT_OPTION)
+
+./pex-os2.o: $(srcdir)/pex-os2.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-os2.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-os2.c $(OUTPUT_OPTION)
+
+./pex-unix.o: $(srcdir)/pex-unix.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-unix.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-unix.c $(OUTPUT_OPTION)
+
+./pex-win32.o: $(srcdir)/pex-win32.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-win32.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-win32.c $(OUTPUT_OPTION)
+
+./pexrd-generic.o: $(srcdir)/pexrd-generic.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pexrd-generic.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pexrd-generic.c $(OUTPUT_OPTION)
+
+./pexrd-unix.o: $(srcdir)/pexrd-unix.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pexrd-unix.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pexrd-unix.c $(OUTPUT_OPTION)
+
+./physmem.o: $(srcdir)/physmem.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
-make-temp-file.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-md5.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/md5.h
-memchr.o: $(INCDIR)/ansidecl.h
-memcmp.o: $(INCDIR)/ansidecl.h
-memcpy.o: $(INCDIR)/ansidecl.h
-memmove.o: $(INCDIR)/ansidecl.h
-mempcpy.o: $(INCDIR)/ansidecl.h
-memset.o: $(INCDIR)/ansidecl.h
-mkstemps.o: config.h $(INCDIR)/ansidecl.h
-objalloc.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/objalloc.h
-obstack.o: config.h $(INCDIR)/obstack.h
-partition.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(INCDIR)/partition.h
-pex-djgpp.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h
-pex-mpw.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h
-pex-msdos.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h $(INCDIR)/safe-ctype.h
-pex-os2.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h
-pex-unix.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h
-pex-win32.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(srcdir)/pex-common.h
-physmem.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-putenv.o: config.h $(INCDIR)/ansidecl.h
-random.o: $(INCDIR)/ansidecl.h
-regex.o: config.h $(INCDIR)/xregex.h $(INCDIR)/xregex2.h
-rename.o: config.h $(INCDIR)/ansidecl.h
-safe-ctype.o: $(INCDIR)/ansidecl.h $(INCDIR)/safe-ctype.h
-setenv.o: config.h $(INCDIR)/ansidecl.h
-sigsetmask.o: $(INCDIR)/ansidecl.h
-snprintf.o: $(INCDIR)/ansidecl.h
-sort.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/physmem.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/physmem.c $(OUTPUT_OPTION)
+
+./putenv.o: $(srcdir)/putenv.c config.h $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/putenv.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/putenv.c $(OUTPUT_OPTION)
+
+./random.o: $(srcdir)/random.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/random.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/random.c $(OUTPUT_OPTION)
+
+./regex.o: $(srcdir)/regex.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/xregex.h \
+	$(INCDIR)/xregex2.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/regex.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/regex.c $(OUTPUT_OPTION)
+
+./rename.o: $(srcdir)/rename.c config.h $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/rename.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/rename.c $(OUTPUT_OPTION)
+
+./rindex.o: $(srcdir)/rindex.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/rindex.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/rindex.c $(OUTPUT_OPTION)
+
+./safe-ctype.o: $(srcdir)/safe-ctype.c $(INCDIR)/ansidecl.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/safe-ctype.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/safe-ctype.c $(OUTPUT_OPTION)
+
+./setenv.o: $(srcdir)/setenv.c config.h $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/setenv.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/setenv.c $(OUTPUT_OPTION)
+
+./sigsetmask.o: $(srcdir)/sigsetmask.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/sigsetmask.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/sigsetmask.c $(OUTPUT_OPTION)
+
+./snprintf.o: $(srcdir)/snprintf.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/snprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/snprintf.c $(OUTPUT_OPTION)
+
+./sort.o: $(srcdir)/sort.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
 	$(INCDIR)/sort.h
-spaces.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-splay-tree.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(INCDIR)/splay-tree.h
-stpcpy.o: $(INCDIR)/ansidecl.h
-stpncpy.o: $(INCDIR)/ansidecl.h
-strcasecmp.o: $(INCDIR)/ansidecl.h
-strchr.o: $(INCDIR)/ansidecl.h
-strdup.o: $(INCDIR)/ansidecl.h
-strerror.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-strncasecmp.o: $(INCDIR)/ansidecl.h
-strncmp.o: $(INCDIR)/ansidecl.h
-strrchr.o: $(INCDIR)/ansidecl.h
-strsignal.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-strtod.o: $(INCDIR)/ansidecl.h $(INCDIR)/safe-ctype.h
-strtol.o: config.h $(INCDIR)/safe-ctype.h
-strtoul.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/safe-ctype.h
-ternary.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
-	$(INCDIR)/ternary.h
-vasprintf.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-vfork.o: $(INCDIR)/ansidecl.h
-vfprintf.o: $(INCDIR)/ansidecl.h
-vprintf.o: $(INCDIR)/ansidecl.h
-vsnprintf.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-vsprintf.o: $(INCDIR)/ansidecl.h
-waitpid.o: config.h
-xatexit.o: $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-xexit.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-xmalloc.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-xmemdup.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-xstrdup.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
-xstrerror.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/sort.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/sort.c $(OUTPUT_OPTION)
+
+./spaces.o: $(srcdir)/spaces.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/spaces.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/spaces.c $(OUTPUT_OPTION)
+
+./splay-tree.o: $(srcdir)/splay-tree.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(INCDIR)/splay-tree.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/splay-tree.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/splay-tree.c $(OUTPUT_OPTION)
+
+./stpcpy.o: $(srcdir)/stpcpy.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/stpcpy.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/stpcpy.c $(OUTPUT_OPTION)
+
+./stpncpy.o: $(srcdir)/stpncpy.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/stpncpy.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/stpncpy.c $(OUTPUT_OPTION)
+
+./strcasecmp.o: $(srcdir)/strcasecmp.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strcasecmp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strcasecmp.c $(OUTPUT_OPTION)
+
+./strchr.o: $(srcdir)/strchr.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strchr.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strchr.c $(OUTPUT_OPTION)
+
+./strdup.o: $(srcdir)/strdup.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strdup.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strdup.c $(OUTPUT_OPTION)
+
+./strerror.o: $(srcdir)/strerror.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strerror.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strerror.c $(OUTPUT_OPTION)
+
+./strncasecmp.o: $(srcdir)/strncasecmp.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strncasecmp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strncasecmp.c $(OUTPUT_OPTION)
+
+./strncmp.o: $(srcdir)/strncmp.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strncmp.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strncmp.c $(OUTPUT_OPTION)
+
+./strrchr.o: $(srcdir)/strrchr.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strrchr.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strrchr.c $(OUTPUT_OPTION)
+
+./strsignal.o: $(srcdir)/strsignal.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strsignal.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strsignal.c $(OUTPUT_OPTION)
+
+./strstr.o: $(srcdir)/strstr.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strstr.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strstr.c $(OUTPUT_OPTION)
+
+./strtod.o: $(srcdir)/strtod.c $(INCDIR)/ansidecl.h $(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strtod.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strtod.c $(OUTPUT_OPTION)
+
+./strtol.o: $(srcdir)/strtol.c config.h $(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strtol.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strtol.c $(OUTPUT_OPTION)
+
+./strtoul.o: $(srcdir)/strtoul.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/safe-ctype.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/strtoul.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/strtoul.c $(OUTPUT_OPTION)
+
+./ternary.o: $(srcdir)/ternary.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(INCDIR)/ternary.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/ternary.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/ternary.c $(OUTPUT_OPTION)
+
+./tmpnam.o: $(srcdir)/tmpnam.c
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/tmpnam.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/tmpnam.c $(OUTPUT_OPTION)
+
+./vasprintf.o: $(srcdir)/vasprintf.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vasprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vasprintf.c $(OUTPUT_OPTION)
+
+./vfork.o: $(srcdir)/vfork.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vfork.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vfork.c $(OUTPUT_OPTION)
+
+./vfprintf.o: $(srcdir)/vfprintf.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vfprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vfprintf.c $(OUTPUT_OPTION)
+
+./vprintf.o: $(srcdir)/vprintf.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vprintf.c $(OUTPUT_OPTION)
+
+./vsnprintf.o: $(srcdir)/vsnprintf.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vsnprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vsnprintf.c $(OUTPUT_OPTION)
+
+./vsprintf.o: $(srcdir)/vsprintf.c $(INCDIR)/ansidecl.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/vsprintf.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/vsprintf.c $(OUTPUT_OPTION)
+
+./waitpid.o: $(srcdir)/waitpid.c config.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/waitpid.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/waitpid.c $(OUTPUT_OPTION)
+
+./xatexit.o: $(srcdir)/xatexit.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xatexit.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xatexit.c $(OUTPUT_OPTION)
+
+./xexit.o: $(srcdir)/xexit.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xexit.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xexit.c $(OUTPUT_OPTION)
+
+./xmalloc.o: $(srcdir)/xmalloc.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xmalloc.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xmalloc.c $(OUTPUT_OPTION)
+
+./xmemdup.o: $(srcdir)/xmemdup.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xmemdup.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xmemdup.c $(OUTPUT_OPTION)
+
+./xstrdup.o: $(srcdir)/xstrdup.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xstrdup.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xstrdup.c $(OUTPUT_OPTION)
+
+./xstrerror.o: $(srcdir)/xstrerror.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/xstrerror.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/xstrerror.c $(OUTPUT_OPTION)
+
diff -Nbaur gcc-3.4.3/libiberty/config.in gcc-3.4.3-new/libiberty/config.in
--- gcc-3.4.3/libiberty/config.in	Sat Jan 10 02:17:41 2004
+++ gcc-3.4.3-new/libiberty/config.in	Fri Jan 21 10:25:52 2005
@@ -1,7 +1,4 @@
 /* config.in.  Generated from configure.ac by autoheader.  */
-/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
-#undef uintptr_t
-
 
 /* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */
 #undef BYTEORDER
@@ -362,9 +359,11 @@
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
 
-/* Define as `__inline' if that's what the C compiler calls it, or to nothing
-   if it is not supported. */
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
 #undef inline
+#endif
 
 /* Define to `int' if <sys/types.h> does not define. */
 #undef pid_t
diff -Nbaur gcc-3.4.3/libiberty/configure gcc-3.4.3-new/libiberty/configure
--- gcc-3.4.3/libiberty/configure	Wed Oct  1 18:11:29 2003
+++ gcc-3.4.3-new/libiberty/configure	Fri Jan 21 10:25:52 2005
@@ -1,9 +1,8 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.57.
+# Generated by GNU Autoconf 2.59.
 #
-# Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -20,9 +19,10 @@
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -41,7 +41,7 @@
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -218,16 +218,17 @@
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
@@ -901,12 +902,45 @@
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
     cd $ac_dir
     # Check for guested configure; otherwise get Cygnus style configure.
@@ -931,8 +965,7 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -944,7 +977,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
@@ -1120,7 +1153,7 @@
       echo "$as_me: caught signal $ac_signal"
     echo "$as_me: exit $exit_status"
   } >&5
-  rm -f core core.* *.core &&
+  rm -f core *.core &&
   rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
     exit $exit_status
      ' 0
@@ -2030,7 +2063,6 @@
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2064,7 +2096,6 @@
   EXEEXT=
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2084,8 +2115,8 @@
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-echo "$as_me:$LINENO: checking for C compiler default output" >&5
-echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
   (eval $ac_link_default) 2>&5
@@ -2222,7 +2253,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2273,7 +2303,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2293,10 +2322,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2310,7 +2349,7 @@
 
 ac_compiler_gnu=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
@@ -2326,7 +2365,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2343,10 +2381,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2360,7 +2408,7 @@
 
 ac_cv_prog_cc_g=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
@@ -2387,7 +2435,6 @@
   ac_cv_prog_cc_stdc=no
 ac_save_CC=$CC
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2415,6 +2462,16 @@
   va_end (v);
   return s;
 }
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
 int test (int i, double x);
 struct s1 {int (*f) (int a);};
 struct s2 {int (*f) (double a);};
@@ -2441,10 +2498,20 @@
   CC="$ac_save_CC $ac_arg"
   rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2458,7 +2525,7 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext
+rm -f conftest.err conftest.$ac_objext
 done
 rm -f conftest.$ac_ext conftest.$ac_objext
 CC=$ac_save_CC
@@ -2486,10 +2553,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2497,8 +2574,7 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
+   '' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
@@ -2506,14 +2582,13 @@
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
 $ac_declaration
+#include <stdlib.h>
 int
 main ()
 {
@@ -2524,10 +2599,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2541,9 +2626,8 @@
 
 continue
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2560,10 +2644,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -2576,7 +2670,7 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 rm -f conftest*
 if test -n "$ac_declaration"; then
@@ -2590,7 +2684,7 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -2625,7 +2719,6 @@
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2648,6 +2741,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -2668,7 +2762,6 @@
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2686,6 +2779,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -2732,7 +2826,6 @@
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2755,6 +2848,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -2775,7 +2869,6 @@
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2793,6 +2886,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -2852,7 +2946,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2946,7 +3039,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3009,10 +3101,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3026,7 +3128,7 @@
 
 ac_cv_c_const=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
 echo "${ECHO_T}$ac_cv_c_const" >&6
@@ -3046,7 +3148,6 @@
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3061,10 +3162,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3077,21 +3188,25 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
 echo "${ECHO_T}$ac_cv_c_inline" >&6
+
+
 case $ac_cv_c_inline in
   inline | yes) ;;
-  no)
-cat >>confdefs.h <<\_ACEOF
-#define inline
-_ACEOF
- ;;
-  *)  cat >>confdefs.h <<_ACEOF
-#define inline $ac_cv_c_inline
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
 _ACEOF
  ;;
 esac
@@ -3104,7 +3219,6 @@
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3125,10 +3239,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3137,7 +3261,6 @@
   (exit $ac_status); }; }; then
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3158,10 +3281,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3175,19 +3308,18 @@
 
 ac_cv_c_bigendian=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 if test $ac_cv_c_bigendian = unknown; then
 if test "$cross_compiling" = yes; then
    echo $ac_n "cross-compiling... " 2>&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3224,7 +3356,7 @@
 ( exit $ac_status )
 ac_cv_c_bigendian=yes
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 fi
@@ -3244,7 +3376,7 @@
 int main() { _ascii (); _ebcdic (); return 0; }
 EOF
  if test -f conftest.c ; then
-     if ${CC-cc} ${CFLAGS} conftest.c -o conftest.o && test -f conftest.o ; then
+     if ${CC-cc} ${CFLAGS} -c conftest.c -o conftest.o && test -f conftest.o ; then
         if test `grep -l BIGenDianSyS conftest.o` ; then
            echo $ac_n ' big endian probe OK, ' 1>&6
            ac_cv_c_bigendian=yes
@@ -3284,9 +3416,9 @@
 _ACEOF
 
 if test $ac_cv_c_bigendian = unknown; then
-  { { echo "$as_me:$LINENO: error: unknown endianess - sorry" >&5
-echo "$as_me: error: unknown endianess - sorry" >&2;}
-   { (exit please pre-set ac_cv_c_bigendian); exit please pre-set ac_cv_c_bigendian; }; }
+  { { echo "$as_me:$LINENO: error: unknown endianess - sorry, please pre-set ac_cv_c_bigendian" >&5
+echo "$as_me: error: unknown endianess - sorry, please pre-set ac_cv_c_bigendian" >&2;}
+   { (exit 1); exit 1; }; }
 fi
 
 
@@ -3307,6 +3439,7 @@
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
 echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
 echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
@@ -3323,6 +3456,7 @@
 case $as_dir/ in
   ./ | .// | /cC/* | \
   /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
   /usr/ucb/* ) ;;
   *)
     # OSF1 and SCO ODT 3.0 have their own names for install.
@@ -3413,7 +3547,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3431,6 +3564,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3463,7 +3597,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3490,10 +3623,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3507,7 +3650,7 @@
 
 ac_cv_header_sys_wait_h=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
 echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6
@@ -3525,7 +3668,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3546,10 +3688,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3563,7 +3715,7 @@
 
 ac_cv_header_time=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
 echo "${ECHO_T}$ac_cv_header_time" >&6
@@ -3582,7 +3734,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3599,10 +3750,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3616,7 +3777,7 @@
 
 libiberty_cv_declare_errno=yes
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $libiberty_cv_declare_errno" >&5
 echo "${ECHO_T}$libiberty_cv_declare_errno" >&6
@@ -3650,7 +3811,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3671,10 +3831,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3688,12 +3858,11 @@
 
 ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3715,7 +3884,6 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3740,7 +3908,6 @@
   :
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3790,7 +3957,7 @@
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 fi
@@ -3824,7 +3991,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3842,6 +4008,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3875,7 +4042,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3895,10 +4061,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3912,7 +4088,7 @@
 
 ac_cv_type_uintptr_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_uintptr_t" >&5
 echo "${ECHO_T}$ac_cv_type_uintptr_t" >&6
@@ -3941,7 +4117,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3961,10 +4136,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -3978,7 +4163,7 @@
 
 ac_cv_type_pid_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 echo "${ECHO_T}$ac_cv_type_pid_t" >&6
@@ -4139,7 +4324,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4186,10 +4370,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4203,7 +4397,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -4250,12 +4445,54 @@
   # newlib provide and which ones we will be expected to provide.
 
   if test "x${with_newlib}" = "xyes"; then
-    LIBOBJS="$LIBOBJS asprintf.$ac_objext"
-    LIBOBJS="$LIBOBJS basename.$ac_objext"
-    LIBOBJS="$LIBOBJS insque.$ac_objext"
-    LIBOBJS="$LIBOBJS random.$ac_objext"
-    LIBOBJS="$LIBOBJS strdup.$ac_objext"
-    LIBOBJS="$LIBOBJS vasprintf.$ac_objext"
+    case $LIBOBJS in
+    "asprintf.$ac_objext"   | \
+  *" asprintf.$ac_objext"   | \
+    "asprintf.$ac_objext "* | \
+  *" asprintf.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS asprintf.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "basename.$ac_objext"   | \
+  *" basename.$ac_objext"   | \
+    "basename.$ac_objext "* | \
+  *" basename.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS basename.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "insque.$ac_objext"   | \
+  *" insque.$ac_objext"   | \
+    "insque.$ac_objext "* | \
+  *" insque.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS insque.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "random.$ac_objext"   | \
+  *" random.$ac_objext"   | \
+    "random.$ac_objext "* | \
+  *" random.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "strdup.$ac_objext"   | \
+  *" strdup.$ac_objext"   | \
+    "strdup.$ac_objext "* | \
+  *" strdup.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strdup.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "vasprintf.$ac_objext"   | \
+  *" vasprintf.$ac_objext"   | \
+    "vasprintf.$ac_objext "* | \
+  *" vasprintf.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS vasprintf.$ac_objext" ;;
+esac
+
 
     for f in $funcs; do
       case "$f" in
@@ -4337,16 +4574,86 @@
     # Handle VxWorks configuration specially, since on VxWorks the
     # libraries are actually on the target board, not in the file
     # system.
-    LIBOBJS="$LIBOBJS basename.$ac_objext"
-    LIBOBJS="$LIBOBJS getpagesize.$ac_objext"
-    LIBOBJS="$LIBOBJS insque.$ac_objext"
-    LIBOBJS="$LIBOBJS random.$ac_objext"
-    LIBOBJS="$LIBOBJS strcasecmp.$ac_objext"
-    LIBOBJS="$LIBOBJS strncasecmp.$ac_objext"
-    LIBOBJS="$LIBOBJS strdup.$ac_objext"
-    LIBOBJS="$LIBOBJS vfork.$ac_objext"
-    LIBOBJS="$LIBOBJS waitpid.$ac_objext"
-    LIBOBJS="$LIBOBJS vasprintf.$ac_objext"
+    case $LIBOBJS in
+    "basename.$ac_objext"   | \
+  *" basename.$ac_objext"   | \
+    "basename.$ac_objext "* | \
+  *" basename.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS basename.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "getpagesize.$ac_objext"   | \
+  *" getpagesize.$ac_objext"   | \
+    "getpagesize.$ac_objext "* | \
+  *" getpagesize.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS getpagesize.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "insque.$ac_objext"   | \
+  *" insque.$ac_objext"   | \
+    "insque.$ac_objext "* | \
+  *" insque.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS insque.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "random.$ac_objext"   | \
+  *" random.$ac_objext"   | \
+    "random.$ac_objext "* | \
+  *" random.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "strcasecmp.$ac_objext"   | \
+  *" strcasecmp.$ac_objext"   | \
+    "strcasecmp.$ac_objext "* | \
+  *" strcasecmp.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strcasecmp.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "strncasecmp.$ac_objext"   | \
+  *" strncasecmp.$ac_objext"   | \
+    "strncasecmp.$ac_objext "* | \
+  *" strncasecmp.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strncasecmp.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "strdup.$ac_objext"   | \
+  *" strdup.$ac_objext"   | \
+    "strdup.$ac_objext "* | \
+  *" strdup.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strdup.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "vfork.$ac_objext"   | \
+  *" vfork.$ac_objext"   | \
+    "vfork.$ac_objext "* | \
+  *" vfork.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS vfork.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "waitpid.$ac_objext"   | \
+  *" waitpid.$ac_objext"   | \
+    "waitpid.$ac_objext "* | \
+  *" waitpid.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS waitpid.$ac_objext" ;;
+esac
+
+    case $LIBOBJS in
+    "vasprintf.$ac_objext"   | \
+  *" vasprintf.$ac_objext"   | \
+    "vasprintf.$ac_objext "* | \
+  *" vasprintf.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS vasprintf.$ac_objext" ;;
+esac
+
     for f in $funcs; do
       case "$f" in
 	basename | getpagesize | insque | random | strcasecmp)
@@ -4399,7 +4706,14 @@
     if test -n "${with_target_subdir}"
     then
       funcs="`echo $funcs | sed -e 's/random//'`"
-      LIBOBJS="$LIBOBJS random.$ac_objext"
+      case $LIBOBJS in
+    "random.$ac_objext"   | \
+  *" random.$ac_objext"   | \
+    "random.$ac_objext "* | \
+  *" random.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS random.$ac_objext" ;;
+esac
+
       vars="`echo $vars | sed -e 's/sys_siglist//'`"
       checkfuncs="`echo $checkfuncs | sed -e 's/strsignal//' -e 's/psignal//'`"
     fi
@@ -4448,7 +4762,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4472,10 +4785,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4488,7 +4811,8 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_strerror" = no; then
   for ac_lib in cposix; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
@@ -4498,7 +4822,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4522,10 +4845,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4539,7 +4872,8 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
@@ -4566,7 +4900,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4613,10 +4946,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4630,7 +4973,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -4640,7 +4984,14 @@
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS $ac_func.$ac_objext"
+  case $LIBOBJS in
+    "$ac_func.$ac_objext"   | \
+  *" $ac_func.$ac_objext"   | \
+    "$ac_func.$ac_objext "* | \
+  *" $ac_func.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS $ac_func.$ac_objext" ;;
+esac
+
 fi
 done
 
@@ -4651,7 +5002,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4689,7 +5039,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4736,10 +5085,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4753,7 +5112,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -4777,7 +5137,6 @@
   ac_cv_c_stack_direction=0
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4820,7 +5179,7 @@
 ( exit $ac_status )
 ac_cv_c_stack_direction=-1
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
@@ -4842,7 +5201,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4860,6 +5218,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -4902,7 +5261,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -4949,10 +5307,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -4966,7 +5334,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -5021,7 +5390,7 @@
 ( exit $ac_status )
 ac_cv_func_fork_works=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_fork_works" >&5
@@ -5054,7 +5423,6 @@
   ac_cv_func_vfork_works=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5176,7 +5544,7 @@
 ( exit $ac_status )
 ac_cv_func_vfork_works=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_vfork_works" >&5
@@ -5184,7 +5552,7 @@
 
 fi;
 if test "x$ac_cv_func_fork_works" = xcross; then
-  ac_cv_func_vfork_works=ac_cv_func_vfork
+  ac_cv_func_vfork_works=$ac_cv_func_vfork
   { echo "$as_me:$LINENO: WARNING: result $ac_cv_func_vfork_works guessed because of cross compilation" >&5
 echo "$as_me: WARNING: result $ac_cv_func_vfork_works guessed because of cross compilation" >&2;}
 fi
@@ -5211,7 +5579,14 @@
 fi
 
   if test $ac_cv_func_vfork_works = no; then
-    LIBOBJS="$LIBOBJS vfork.$ac_objext"
+    case $LIBOBJS in
+    "vfork.$ac_objext"   | \
+  *" vfork.$ac_objext"   | \
+    "vfork.$ac_objext "* | \
+  *" vfork.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS vfork.$ac_objext" ;;
+esac
+
   fi
   # We only need _doprnt if we might use it to implement v*printf.
   if test $ac_cv_func_vprintf != yes \
@@ -5232,7 +5607,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5279,10 +5653,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5296,7 +5680,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -5306,7 +5691,14 @@
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS $ac_func.$ac_objext"
+  case $LIBOBJS in
+    "$ac_func.$ac_objext"   | \
+  *" $ac_func.$ac_objext"   | \
+    "$ac_func.$ac_objext "* | \
+  *" $ac_func.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS $ac_func.$ac_objext" ;;
+esac
+
 fi
 done
 
@@ -5327,7 +5719,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5374,10 +5765,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5391,7 +5792,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -5417,7 +5819,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5434,10 +5835,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5451,7 +5862,8 @@
 
 eval "libiberty_cv_var_$v=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 
     if eval "test \"`echo '$libiberty_cv_var_'$v`\" = yes"; then
@@ -5473,7 +5885,6 @@
   echo "$as_me:$LINENO: checking for external symbol _system_configuration" >&5
 echo $ECHO_N "checking for external symbol _system_configuration... $ECHO_C" >&6
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5490,10 +5901,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5514,7 +5935,7 @@
 echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
 for ac_func in $checkfuncs
@@ -5531,7 +5952,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5578,10 +5998,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5595,7 +6025,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -5613,7 +6044,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5645,10 +6075,20 @@
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5662,7 +6102,7 @@
 
 libiberty_cv_decl_needed_canonicalize_file_name=yes
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 
 echo "$as_me:$LINENO: result: $libiberty_cv_decl_needed_canonicalize_file_name" >&5
@@ -5679,11 +6119,11 @@
 
 # Figure out which version of pexecute to use.
 case "${host}" in
-     *-*-mingw* | *-*-winnt*)	pexecute=pex-win32.o  ;;
-     *-*-msdosdjgpp*)		pexecute=pex-djgpp.o  ;;
-     *-*-msdos*)		pexecute=pex-msdos.o  ;;
-     *-*-os2-emx*)		pexecute=pex-os2.o    ;;
-     *)				pexecute=pex-unix.o   ;;
+     *-*-mingw* | *-*-winnt*)	pexecute="./pex-win32.o ./pexrd-generic.o"  ;;
+     *-*-msdosdjgpp*)		pexecute="./pex-djgpp.o ./pexrd-generic.o"  ;;
+     *-*-msdos*)		pexecute="./pex-msdos.o ./pexrd-generic.o"  ;;
+     *-*-os2-emx*)		pexecute="./pex-os2.o   ./pexrd-generic.o"  ;;
+     *)				pexecute="./pex-unix.o  ./pexrd-unix.o"     ;;
 esac
 
 
@@ -5704,7 +6144,6 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5722,6 +6161,7 @@
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -5763,7 +6203,6 @@
    { (exit 1); exit 1; }; }
 fi
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5810,10 +6249,20 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
@@ -5827,7 +6276,8 @@
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -5848,7 +6298,6 @@
   ac_cv_func_mmap_fixed_mapped=no
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -5956,7 +6405,7 @@
   data2 = (char *) malloc (2 * pagesize);
   if (!data2)
     exit (1);
-  data2 += (pagesize - ((int) data2 & (pagesize - 1))) & (pagesize - 1);
+  data2 += (pagesize - ((long) data2 & (pagesize - 1))) & (pagesize - 1);
   if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_FIXED, fd, 0L))
     exit (1);
@@ -6001,7 +6450,7 @@
 ( exit $ac_status )
 ac_cv_func_mmap_fixed_mapped=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_mmap_fixed_mapped" >&5
@@ -6026,7 +6475,6 @@
   ac_cv_func_strncmp_works=no
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -6114,14 +6562,21 @@
 ( exit $ac_status )
 ac_cv_func_strncmp_works=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f core core.* *.core
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_strncmp_works" >&5
 echo "${ECHO_T}$ac_cv_func_strncmp_works" >&6
 if test $ac_cv_func_strncmp_works = no ; then
-  LIBOBJS="$LIBOBJS strncmp.$ac_objext"
+  case $LIBOBJS in
+    "strncmp.$ac_objext"   | \
+  *" strncmp.$ac_objext"   | \
+    "strncmp.$ac_objext "* | \
+  *" strncmp.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS strncmp.$ac_objext" ;;
+esac
+
 fi
 
 
@@ -6134,6 +6589,16 @@
 fi
 
 
+
+L=""
+for l in x $LIBOBJS; do
+  case $l in
+    x) ;;
+    *) L="$L ./$l" ;;
+  esac
+done
+LIBOBJS="$L"
+
 # We need multilib support, but only if configuring for the target.
                     ac_config_files="$ac_config_files Makefile testsuite/Makefile"
           ac_config_commands="$ac_config_commands default"
@@ -6262,9 +6727,10 @@
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -6283,7 +6749,7 @@
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -6462,16 +6928,17 @@
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
@@ -6498,7 +6965,7 @@
 cat >&5 <<_CSEOF
 
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -6561,11 +7028,10 @@
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.57,
+configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 srcdir=$srcdir
@@ -6932,12 +7398,45 @@
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
   case $INSTALL in
@@ -6972,14 +7471,14 @@
          test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 echo "$f";;
       *) # Relative
          if test -f "$f"; then
            # Build tree
-           echo $f
+	   echo "$f"
          elif test -f "$srcdir/$f"; then
            # Source tree
-           echo $srcdir/$f
+	   echo "$srcdir/$f"
          else
            # /dev/null tree
            { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
@@ -7063,14 +7562,15 @@
          test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
       *) # Relative
          if test -f "$f"; then
            # Build tree
-           echo $f
+	   echo "$f"
          elif test -f "$srcdir/$f"; then
            # Source tree
-           echo $srcdir/$f
+	   echo "$srcdir/$f"
          else
            # /dev/null tree
            { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
@@ -7259,6 +7759,31 @@
   	  /^X\(\/\/\)$/{ s//\1/; q; }
   	  /^X\(\/\).*/{ s//\1/; q; }
   	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
   ac_builddir=.
 
 if test "$ac_dir" != .; then
@@ -7284,12 +7809,45 @@
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
   { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
diff -Nbaur gcc-3.4.3/libiberty/configure.ac gcc-3.4.3-new/libiberty/configure.ac
--- gcc-3.4.3/libiberty/configure.ac	Sat Jan 10 02:17:41 2004
+++ gcc-3.4.3-new/libiberty/configure.ac	Fri Jan 21 10:25:52 2005
@@ -1,7 +1,8 @@
 dnl Process this file with autoconf to produce a configure script
 
-AC_PREREQ(2.57)
-AC_INIT(xmalloc.c)
+AC_PREREQ(2.59)
+AC_INIT
+AC_CONFIG_SRCDIR([xmalloc.c])
 
 # This works around the fact that libtool configuration may change LD
 # for this particular configuration, but some shells, instead of
@@ -433,7 +434,7 @@
   AC_ISC_POSIX
   AC_REPLACE_FUNCS($funcs)
   libiberty_AC_FUNC_C_ALLOCA
-  AC_FUNC_VFORK
+  AC_FUNC_FORK
   if test $ac_cv_func_vfork_works = no; then
     AC_LIBOBJ([vfork])
   fi
@@ -449,7 +450,7 @@
   for v in $vars; do
     AC_MSG_CHECKING([for $v])
     AC_CACHE_VAL(libiberty_cv_var_$v,
-      [AC_TRY_LINK([int *p;], [extern int $v []; p = $v;],
+      [AC_LINK_IFELSE([AC_LANG_PROGRAM([[int *p;]],[[extern int $v []; p = $v;]])],
 		   [eval "libiberty_cv_var_$v=yes"],
 		   [eval "libiberty_cv_var_$v=no"])])
     if eval "test \"`echo '$libiberty_cv_var_'$v`\" = yes"; then
@@ -464,8 +465,8 @@
   # special check for _system_configuration because AIX <4.3.2 do not
   # contain the `physmem' member.
   AC_MSG_CHECKING([for external symbol _system_configuration])
-  AC_TRY_COMPILE([#include <sys/systemcfg.h>],
-                 [double x = _system_configuration.physmem;],
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/systemcfg.h>]],
+			[[double x = _system_configuration.physmem;]])],
     [AC_MSG_RESULT([yes])
     AC_DEFINE(HAVE__SYSTEM_CONFIGURATION, 1,
               [Define if you have the _system_configuration variable.])],
@@ -477,11 +478,11 @@
 
 # Figure out which version of pexecute to use.
 case "${host}" in
-     *-*-mingw* | *-*-winnt*)	pexecute=pex-win32.o  ;;
-     *-*-msdosdjgpp*)		pexecute=pex-djgpp.o  ;;
-     *-*-msdos*)		pexecute=pex-msdos.o  ;;
-     *-*-os2-emx*)		pexecute=pex-os2.o    ;;
-     *)				pexecute=pex-unix.o   ;;
+     *-*-mingw* | *-*-winnt*)	pexecute="./pex-win32.o ./pexrd-generic.o"  ;;
+     *-*-msdosdjgpp*)		pexecute="./pex-djgpp.o ./pexrd-generic.o"  ;;
+     *-*-msdos*)		pexecute="./pex-msdos.o ./pexrd-generic.o"  ;;
+     *-*-os2-emx*)		pexecute="./pex-os2.o   ./pexrd-generic.o"  ;;
+     *)				pexecute="./pex-unix.o  ./pexrd-unix.o"     ;;
 esac
 AC_SUBST(pexecute)
 
@@ -496,9 +497,20 @@
 fi
 AC_SUBST(INSTALL_DEST)
 
+m4_pattern_allow(LIBOBJS)
+L=""
+for l in x $LIBOBJS; do
+  case $l in
+    x) ;;
+    *) L="$L ./$l" ;;
+  esac
+done
+LIBOBJS="$L"
+
 # We need multilib support, but only if configuring for the target.
-AC_OUTPUT(Makefile testsuite/Makefile,
-[test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h
+AC_CONFIG_FILES([Makefile testsuite/Makefile])
+AC_CONFIG_COMMANDS([default],
+  [[test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h
 if test -n "$CONFIG_FILES"; then
   if test -n "${with_build_subdir}" || test -n "${with_target_subdir}"; then
     # FIXME: We shouldn't need to set ac_file
@@ -506,8 +518,8 @@
     LD="${ORIGINAL_LD_FOR_MULTILIBS}"
     . ${libiberty_topdir}/config-ml.in
   fi
-fi],
-srcdir=${srcdir}
+fi]],
+[[srcdir=${srcdir}
 host=${host}
 target=${target}
 with_target_subdir=${with_target_subdir}
@@ -517,4 +529,5 @@
 CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
 ORIGINAL_LD_FOR_MULTILIBS="${ORIGINAL_LD_FOR_MULTILIBS}"
 libiberty_topdir=${libiberty_topdir}
-)
+]])
+AC_OUTPUT
diff -Nbaur gcc-3.4.3/libiberty/dyn-string.c gcc-3.4.3-new/libiberty/dyn-string.c
--- gcc-3.4.3/libiberty/dyn-string.c	Mon Apr  1 22:55:12 2002
+++ gcc-3.4.3-new/libiberty/dyn-string.c	Fri Jan 21 10:25:52 2005
@@ -1,5 +1,5 @@
 /* An abstract string datatype.
-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
    Contributed by Mark Mitchell (mark@markmitchell.com).
 
 This file is part of GNU CC.
@@ -44,15 +44,6 @@
 
 #include "libiberty.h"
 #include "dyn-string.h"
-
-/* If this file is being compiled for inclusion in the C++ runtime
-   library, as part of the demangler implementation, we don't want to
-   abort if an allocation fails.  Instead, percolate an error code up
-   through the call chain.  */
-
-#if defined(IN_LIBGCC2) || defined(IN_GLIBCPP_V3)
-#define RETURN_ON_ALLOCATION_FAILURE
-#endif
 
 /* Performs in-place initialization of a dyn_string struct.  This
    function can be used with a dyn_string struct on the stack or
diff -Nbaur gcc-3.4.3/libiberty/getpwd.c gcc-3.4.3-new/libiberty/getpwd.c
--- gcc-3.4.3/libiberty/getpwd.c	Sun Oct  7 22:53:31 2001
+++ gcc-3.4.3-new/libiberty/getpwd.c	Fri Jan 21 10:25:52 2005
@@ -35,6 +35,9 @@
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
+#if HAVE_LIMITS_H
+#include <limits.h>
+#endif
 
 /* Prototype these in case the system headers don't provide them. */
 extern char *getpwd ();
diff -Nbaur gcc-3.4.3/libiberty/maint-tool gcc-3.4.3-new/libiberty/maint-tool
--- gcc-3.4.3/libiberty/maint-tool	Tue Apr 15 20:21:38 2003
+++ gcc-3.4.3-new/libiberty/maint-tool	Fri Jan 21 10:25:52 2005
@@ -213,6 +213,12 @@
 
 sub deps {
 
+    $crule  = "\tif [ x\"\$(PICFLAG)\" != x ]; then \\\n";
+    $crule .= "\t  \$(COMPILE.c) \$(PICFLAG) \$< -o pic/\$@; \\\n";
+    $crule .= "\telse true; fi\n";
+    $crule .= "\t\$(COMPILE.c) \$< \$(OUTPUT_OPTION)\n";
+    $crule .= "\n";
+
     $incdir = shift @ARGV;
 
     opendir(INC, $incdir);
@@ -260,10 +266,10 @@
 	    @deps = sort { &locals_first($a,$b) } keys %scanned;
 	    $obj = $f;
 	    $obj =~ s/\.c$/.o/;
-	    $obj = "$obj:";
+	    $obj = "./$obj:";
 	    if ($#deps >= 0) {
-		print OUT $obj;
-		$len = length($obj);
+		print OUT "$obj \$(srcdir)/$f";
+		$len = length("$obj $f");
 		for $dt (@deps) {
 		    $d = $mine{$dt};
 		    if ($len + length($d) > 70) {
@@ -275,7 +281,12 @@
 		    }
 		}
 		print OUT "\n";
+	    } else {
+		print OUT "$obj \$(srcdir)/$f\n";
 	    }
+	    $c = $crule;
+	    $c =~ s@\$\<@\$\(srcdir\)\/$f@g;
+	    print OUT $c;
 	}
     }
     closedir(S);
diff -Nbaur gcc-3.4.3/libiberty/pex-common.h gcc-3.4.3-new/libiberty/pex-common.h
--- gcc-3.4.3/libiberty/pex-common.h	Fri Jan 24 20:02:11 2003
+++ gcc-3.4.3-new/libiberty/pex-common.h	Fri Jan 21 10:25:52 2005
@@ -1,6 +1,6 @@
 /* Utilities to execute a program in a subprocess (possibly linked by pipes
    with other subprocesses), and wait for it.  Shared logic.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
    Free Software Foundation, Inc.
 
 This file is part of the libiberty library.
@@ -32,6 +32,9 @@
 
 /* stdout file number.  */
 #define STDOUT_FILE_NO 1
+
+/* stderr file number.  */
+#define STDERR_FILE_NO 2
 
 /* value of `pipe': port index for reading.  */
 #define READ_PORT 0
diff -Nbaur gcc-3.4.3/libiberty/pex-unix.c gcc-3.4.3-new/libiberty/pex-unix.c
--- gcc-3.4.3/libiberty/pex-unix.c	Fri Jan 24 20:02:11 2003
+++ gcc-3.4.3-new/libiberty/pex-unix.c	Fri Jan 21 10:25:52 2005
@@ -1,7 +1,7 @@
 /* Utilities to execute a program in a subprocess (possibly linked by pipes
    with other subprocesses), and wait for it.  Generic Unix version
    (also used for UWIN and VMS).
-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
    Free Software Foundation, Inc.
 
 This file is part of the libiberty library.
@@ -44,28 +44,66 @@
 #define waitpid(pid, status, flags) wait(status)
 #endif
 
-extern int execv ();
-extern int execvp ();
+#ifdef vfork /* Autoconf may define this to fork for us. */
+# define VFORK_STRING "fork"
+#else
+# define VFORK_STRING "vfork"
+#endif
+#ifdef HAVE_VFORK_H
+#include <vfork.h>
+#endif
+#ifdef VMS
+#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
+               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
+#endif /* VMS */
+
+/* Execute a program, possibly setting up pipes to programs executed
+   via other calls to this function.
+
+   This version of the function uses vfork.  In general vfork is
+   similar to setjmp/longmp, in that any variable which is modified by
+   the child process has an indeterminate value in the parent process.
+   We follow a safe approach here by not modifying any variables at
+   all in the child process (with the possible exception of variables
+   modified by xstrerror if exec fails, but this is unlikely to be
+   detectable).
+
+   We work a little bit harder to avoid gcc warnings.  gcc will warn
+   about any automatic variable which is live at the time of the
+   vfork, which is non-volatile, and which is either set more than
+   once or is an argument to the function.  This warning isn't quite
+   right, since what we really care about is whether the variable is
+   live at the time of the vfork and set afterward by the child
+   process, but gcc only checks whether the variable is set more than
+   once.  To avoid this warning, we ensure that any variable which is
+   live at the time of the vfork (i.e., used after the vfork) is set
+   exactly once and is not an argument, or is marked volatile.  */
 
 int
-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,
+	  flagsarg)
      const char *program;
      char * const *argv;
      const char *this_pname;
      const char *temp_base ATTRIBUTE_UNUSED;
      char **errmsg_fmt, **errmsg_arg;
-     int flags;
+     int flagsarg;
 {
-  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);
   int pid;
   int pdes[2];
+  int out;
   int input_desc, output_desc;
-  int retries, sleep_interval;
+  int flags;
+  /* We declare these to be volatile to avoid warnings from gcc about
+     them being clobbered by vfork.  */
+  volatile int retries, sleep_interval;
   /* Pipe waiting from last process, to be used as input for the next one.
      Value is STDIN_FILE_NO if no pipe is waiting
      (i.e. the next command is the first of a group).  */
   static int last_pipe_input;
 
+  flags = flagsarg;
+
   /* If this is the first process, initialize.  */
   if (flags & PEXECUTE_FIRST)
     last_pipe_input = STDIN_FILE_NO;
@@ -82,22 +120,24 @@
 	  *errmsg_arg = NULL;
 	  return -1;
 	}
-      output_desc = pdes[WRITE_PORT];
+      out = pdes[WRITE_PORT];
       last_pipe_input = pdes[READ_PORT];
     }
   else
     {
       /* Last process.  */
-      output_desc = STDOUT_FILE_NO;
+      out = STDOUT_FILE_NO;
       last_pipe_input = STDIN_FILE_NO;
     }
 
+  output_desc = out;
+
   /* Fork a subprocess; wait and retry if it fails.  */
   sleep_interval = 1;
   pid = -1;
   for (retries = 0; retries < 4; retries++)
     {
-      pid = fork ();
+      pid = vfork ();
       if (pid >= 0)
 	break;
       sleep (sleep_interval);
@@ -131,12 +171,21 @@
 	close (last_pipe_input);
 
       /* Exec the program.  */
-      (*func) (program, argv);
+      if (flags & PEXECUTE_SEARCH)
+	execvp (program, argv);
+      else
+	execv (program, argv);
 
-      fprintf (stderr, "%s: ", this_pname);
-      fprintf (stderr, install_error_msg, program);
-      fprintf (stderr, ": %s\n", xstrerror (errno));
-      exit (-1);
+      /* We don't want to call fprintf after vfork.  */
+#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
+      writeerr (this_pname);
+      writeerr (": ");
+      writeerr ("installation problem, cannot exec '");
+      writeerr (program);
+      writeerr ("': ");
+      writeerr (xstrerror (errno));
+      writeerr ("\n");
+      _exit (-1);
       /* NOTREACHED */
       return 0;
 
diff -Nbaur gcc-3.4.3/libiberty/pexecute.txh gcc-3.4.3-new/libiberty/pexecute.txh
--- gcc-3.4.3/libiberty/pexecute.txh	Fri Jan 24 20:02:11 2003
+++ gcc-3.4.3-new/libiberty/pexecute.txh	Fri Jan 21 10:25:52 2005
@@ -1,4 +1,4 @@
-@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)
+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int @var{flags})
 
 Executes a program.
 
@@ -61,3 +61,39 @@
 
 pfinish is necessary for systems like MPW where a script is generated
 that runs the requested programs.
+
+@end undocumented
+
+@deftypefn Extension FILE* pex_read (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int @var{flags}, int *@var{pidptr})
+
+Executes a program and returns a stdio file for the program's standard
+output.  This is a safe version of the usual Unix function
+@code{popen}.
+
+The first seven parameters are the same as for @code{pexecute}.  The
+last parameter returns a process identifier to be passed to
+@code{pex_read_close}.
+
+The only flags used for the @var{flags} parameter is
+@code{PEXECUTE_SEARCH}.
+
+Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the
+text of the error message with an optional argument (if not needed,
+@var{errmsg_arg} is set to @code{NULL}), and @code{NULL} is returned.
+@code{errno} is available to the caller to use.
+
+@end deftypefn
+
+@deftypefn Extension int pex_read_close (int @var{pid}, FILE *@var{file}, int *@var{status}, int @var{flags})
+
+Close a file opened by @code{pex_read}, and wait for the subprocess to
+complete.  The @var{pid} and @var{file} arguments should have been
+obtained from a call to @code{pex_read}.
+
+The result is the pid of the child reaped, or -1 for failure
+(@code{errno} says why).
+
+On a successful return, *@var{status} is set to the exit status of the
+subprocess.
+
+@end deftypefn
diff -Nbaur gcc-3.4.3/libiberty/pexrd-generic.c gcc-3.4.3-new/libiberty/pexrd-generic.c
--- gcc-3.4.3/libiberty/pexrd-generic.c	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/libiberty/pexrd-generic.c	Fri Jan 21 10:25:52 2005
@@ -0,0 +1,72 @@
+/* Execute a program and read stdout.  Generic version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not,
+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "pex-common.h"
+#include "pex-read.h"
+
+#include <errno.h>
+#ifdef NEED_DECLARATION_ERRNO
+extern int errno;
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+FILE *
+pex_read (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags,
+	  pidptr)
+     const char *program;
+     char * const *argv;
+     const char *this_pname ATTRIBUTE_UNUSED;
+     const char *temp_base ATTRIBUTE_UNUSED;
+     char **errmsg_fmt;
+     char **errmsg_arg;
+     int flags ATTRIBUTE_UNUSED;
+     int *pidptr ATTRIBUTE_UNUSED;
+{
+  char *cmd;
+  int i;
+  FILE *ret;
+
+  cmd = xstrdup (program);
+  for (i = 0; argv[i] != NULL; ++i)
+    cmd = reconcat (cmd, cmd, " ", argv[i], NULL);
+
+  ret = popen (cmd, "r");
+  if (ret == NULL)
+    {
+      *errmsg_fmt = "popen";
+      *errmsg_arg = NULL;
+    }
+
+  free (cmd);
+
+  return ret;
+}
+
+int
+pex_read_close (pid, file, status, flags)
+     int pid ATTRIBUTE_UNUSED;
+     FILE *file;
+     int *status;
+     int flags ATTRIBUTE_UNUSED;
+{
+  *status = pclose (file);
+  return 0;
+}
diff -Nbaur gcc-3.4.3/libiberty/pexrd-unix.c gcc-3.4.3-new/libiberty/pexrd-unix.c
--- gcc-3.4.3/libiberty/pexrd-unix.c	Thu Jan  1 00:00:00 1970
+++ gcc-3.4.3-new/libiberty/pexrd-unix.c	Fri Jan 21 10:25:52 2005
@@ -0,0 +1,164 @@
+/* Execute a program and read stdout.  Generic Unix version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not,
+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "pex-common.h"
+
+#include <stdio.h>
+#include <errno.h>
+#ifdef NEED_DECLARATION_ERRNO
+extern int errno;
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_SYS_WAIT_H
+#include <sys/wait.h>
+#endif
+
+#ifndef HAVE_WAITPID
+#define waitpid(pid, status, flags) wait(status)
+#endif
+
+#ifdef vfork /* Autoconf may define this to fork for us. */
+# define VFORK_STRING "fork"
+#else
+# define VFORK_STRING "vfork"
+#endif
+#ifdef HAVE_VFORK_H
+#include <vfork.h>
+#endif
+#ifdef VMS
+#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
+               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
+#endif /* VMS */
+
+/* A safe version of popen.  See pex-unix.c for notes on vfork.  */
+
+FILE *
+pex_read (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,
+	  flagsarg, pidptr)
+     const char *program;
+     char * const *argv;
+     const char *this_pname;
+     const char *temp_base ATTRIBUTE_UNUSED;
+     char **errmsg_fmt;
+     char **errmsg_arg;
+     int flagsarg;
+     int *pidptr;
+{
+  int flags;
+  int pid;
+  int pdes[2];
+  int in;
+  int out;
+  FILE *ret;
+  /* We declare these to be volatile to avoid warnings from gcc about
+     them being clobbered by vfork.  */
+  volatile int retries;
+  volatile int sleep_interval;
+
+  flags = flagsarg;
+
+  if (pipe (pdes) < 0)
+    {
+      *errmsg_fmt = "pipe";
+      *errmsg_arg = NULL;
+      return NULL;
+    }
+
+  in = pdes[READ_PORT];
+  out = pdes[WRITE_PORT];
+
+  sleep_interval = 1;
+  pid = -1;
+  for (retries = 0; retries < 4; retries++)
+    {
+      pid = vfork ();
+      if (pid >= 0)
+	break;
+      sleep (sleep_interval);
+      sleep_interval *= 2;
+    }
+
+  switch (pid)
+    {
+    case -1:
+      *errmsg_fmt = "fork";
+      *errmsg_arg = NULL;
+      return NULL;
+
+    case 0:
+      if (out != STDOUT_FILE_NO)
+	{
+	  close (STDOUT_FILE_NO);
+	  dup (out);
+	  close (out);
+	}
+      close (in);
+
+      if (flags & PEXECUTE_SEARCH)
+	execvp (program, argv);
+      else
+	execv (program, argv);
+
+      /* We don't want to call fprintf after vfork.  */
+#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
+      writeerr (this_pname);
+      writeerr (": ");
+      writeerr ("installation problem, cannot exec '");
+      writeerr (program);
+      writeerr ("': ");
+      writeerr (xstrerror (errno));
+      writeerr ("\n");
+      _exit (-1);
+      /* NOTREACHED */
+      return NULL;
+
+    default:
+      close (out);
+      ret = fdopen (in, "r");
+      if (ret == NULL)
+	{
+	  *errmsg_fmt = "fdopen";
+	  *errmsg_arg = NULL;
+	  return NULL;
+	}
+      *pidptr = pid;
+      return ret;
+    }
+  /* NOTREACHED */
+}
+
+int
+pex_read_close (pid, file, status, flags)
+     int pid;
+     FILE *file;
+     int *status;
+     int flags ATTRIBUTE_UNUSED;
+{
+  /* ??? Canonicalize STATUS value?  */
+  fclose (file);
+  return waitpid (pid, status, 0);
+}
diff -Nbaur gcc-3.4.3/libiberty/regex.c gcc-3.4.3-new/libiberty/regex.c
--- gcc-3.4.3/libiberty/regex.c	Tue Apr 15 15:24:26 2003
+++ gcc-3.4.3-new/libiberty/regex.c	Fri Jan 21 10:25:52 2005
@@ -36,6 +36,8 @@
 # include <config.h>
 #endif
 
+#include <ansidecl.h>
+
 #ifndef PARAMS
 # if defined __GNUC__ || (defined __STDC__ && __STDC__)
 #  define PARAMS(args) args
@@ -8040,7 +8042,7 @@
 
       /* Map uppercase characters to corresponding lowercase ones.  */
       for (i = 0; i < CHAR_SET_SIZE; i++)
-        preg->translate[i] = ISUPPER (i) ? TOLOWER (i) : i;
+        preg->translate[i] = ISUPPER (i) ? TOLOWER (i) : (int) i;
     }
   else
     preg->translate = NULL;
@@ -8175,7 +8177,7 @@
 size_t
 regerror (errcode, preg, errbuf, errbuf_size)
     int errcode;
-    const regex_t *preg;
+    const regex_t *preg ATTRIBUTE_UNUSED;
     char *errbuf;
     size_t errbuf_size;
 {
diff -Nbaur gcc-3.4.3/libiberty/strerror.c gcc-3.4.3-new/libiberty/strerror.c
--- gcc-3.4.3/libiberty/strerror.c	Thu Oct  2 20:06:29 2003
+++ gcc-3.4.3-new/libiberty/strerror.c	Fri Jan 21 10:25:52 2005
@@ -2,9 +2,6 @@
    Written by Fred Fish.  fnf@cygnus.com
    This file is in the public domain.  --Per Bothner.  */
 
-#include "ansidecl.h"
-#include "libiberty.h"
-
 #include "config.h"
 
 #ifdef HAVE_SYS_ERRLIST
@@ -17,6 +14,9 @@
 #define sys_errlist sys_errlist__
 #endif
 
+#include "ansidecl.h"
+#include "libiberty.h"
+
 #include <stdio.h>
 #include <errno.h>
 
@@ -469,8 +469,10 @@
 
 #else
 
+#ifndef __MINGW32__
 extern int sys_nerr;
 extern char *sys_errlist[];
+#endif
 
 #endif
 
diff -Nbaur gcc-3.4.3/libiberty/testsuite/test-demangle.c gcc-3.4.3-new/libiberty/testsuite/test-demangle.c
--- gcc-3.4.3/libiberty/testsuite/test-demangle.c	Fri Jan  2 20:33:55 2004
+++ gcc-3.4.3-new/libiberty/testsuite/test-demangle.c	Fri Jan 21 10:25:52 2005
@@ -26,6 +26,12 @@
 #include <stdio.h>
 #include "libiberty.h"
 #include "demangle.h"
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#if HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
 
 struct line
 {
@@ -119,7 +125,7 @@
      int argc;
      char **argv;
 {
-  enum demangling_styles style;
+  enum demangling_styles style = auto_demangling;
   int no_params;
   int is_v3_ctor;
   int is_v3_dtor;
diff -Nbaur gcc-3.4.3/libstdc++-v3/config/os/mingw32/os_defines.h gcc-3.4.3-new/libstdc++-v3/config/os/mingw32/os_defines.h
--- gcc-3.4.3/libstdc++-v3/config/os/mingw32/os_defines.h	Sat Jul  5 05:05:32 2003
+++ gcc-3.4.3-new/libstdc++-v3/config/os/mingw32/os_defines.h	Fri Jan 21 10:25:52 2005
@@ -45,4 +45,11 @@
 #undef NOMINMAX
 #define NOMINMAX 1
 
+// mingw32 local hack: Override  _GLIBCXX_USE_WCHAR_T for wstring
+#define _GLIBCXX_USE_WSTRING 1
+
+// mingw32 local hack: Cast long double to doubles to workaround
+// printf bug.	
+#define _GLIBCXX_NO_LONG_DOUBLE_IO 1
+
 #endif
diff -Nbaur gcc-3.4.3/libstdc++-v3/configure.host gcc-3.4.3-new/libstdc++-v3/configure.host
--- gcc-3.4.3/libstdc++-v3/configure.host	Tue Oct  5 17:32:49 2004
+++ gcc-3.4.3-new/libstdc++-v3/configure.host	Fri Jan 21 10:25:52 2005
@@ -180,6 +180,7 @@
     ;;
   mingw32*)
     os_include_dir="os/mingw32"
+    atomicity_dir="cpu/i486"
     ;;
   netbsd*)
     os_include_dir="os/bsd/netbsd"
diff -Nbaur gcc-3.4.3/libstdc++-v3/include/bits/char_traits.h gcc-3.4.3-new/libstdc++-v3/include/bits/char_traits.h
--- gcc-3.4.3/libstdc++-v3/include/bits/char_traits.h	Thu Mar 18 17:36:47 2004
+++ gcc-3.4.3-new/libstdc++-v3/include/bits/char_traits.h	Fri Jan 21 10:25:52 2005
@@ -296,7 +296,7 @@
   };
 
 
-#ifdef _GLIBCXX_USE_WCHAR_T
+#if defined (_GLIBCXX_USE_WCHAR_T) || defined (_GLIBCXX_USE_WSTRING)
   /// 21.1.3.2  char_traits specializations
   template<>
     struct char_traits<wchar_t>
@@ -304,8 +304,10 @@
       typedef wchar_t           char_type;
       typedef wint_t            int_type;
       typedef streamoff         off_type;
+#if defined (_GLIBCXX_USE_WCHAR_T)
       typedef wstreampos        pos_type;
       typedef mbstate_t         state_type;
+#endif
 
       static void
       assign(char_type& __c1, const char_type& __c2)
diff -Nbaur gcc-3.4.3/libstdc++-v3/include/bits/locale_facets.tcc gcc-3.4.3-new/libstdc++-v3/include/bits/locale_facets.tcc
--- gcc-3.4.3/libstdc++-v3/include/bits/locale_facets.tcc	Tue Sep 14 00:43:24 2004
+++ gcc-3.4.3-new/libstdc++-v3/include/bits/locale_facets.tcc	Fri Jan 21 10:25:52 2005
@@ -765,7 +765,13 @@
       string __xtrc;
       __xtrc.reserve(32);
       __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
+#if defined (GLIBCXX_NO_LONG_DOUBLE_IO) && !defined(_GLIBCXX_USE_C99)
+      double __vd;
+      std::__convert_to_v(__xtrc.c_str(), __vd, __err, _S_get_c_locale());
+      __v = static_cast<long double>(__vd);	
+#else
       std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
+#endif
       return __beg;
     }
 
@@ -1220,7 +1226,14 @@
     num_put<_CharT, _OutIter>::
     do_put(iter_type __s, ios_base& __io, char_type __fill,
 	   long double __v) const
-    { return _M_insert_float(__s, __io, __fill, 'L', __v); }
+    {
+#ifdef  _GLIBCXX_NO_LONG_DOUBLE_IO
+      return _M_insert_float(__s, __io, __fill, char_type(),
+			      static_cast<double>(__v));
+#else
+      return _M_insert_float(__s, __io, __fill, 'L', __v);
+#endif
+    }
 
   template<typename _CharT, typename _OutIter>
     _OutIter
@@ -1464,7 +1477,13 @@
 	__beg = _M_extract<true>(__beg, __end, __io, __err, __str);
       else
 	__beg = _M_extract<false>(__beg, __end, __io, __err, __str);
+#if defined _GLIBCXX_NO_LONG_DOUBLE_IO  && !defined (_GLIBCXX_USE_C99)
+      double __dunits;
+      std::__convert_to_v(__str.c_str(), __dunits, __err, _S_get_c_locale());
+      __units = static_cast<long double>(__dunits);	
+#else  //  _GLIBCXX_NO_LONG_DOUBLE_IO && !defined (_GLIBCXX_USE_C99)
       std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
+#endif  //  _GLIBCXX_NO_LONG_DOUBLE_IO
       return __beg;
     }
 
@@ -1667,6 +1686,32 @@
     {
       const locale __loc = __io.getloc();
       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
+#ifdef  _GLIBCXX_NO_LONG_DOUBLE_IO
+      double __dunits = static_cast<double>(__units);
+#ifdef _GLIBCXX_USE_C99
+      // First try a buffer perhaps big enough.
+      int __cs_size = 64;
+      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 328. Bad sprintf format modifier in money_put<>::do_put()
+      int __len = std::__convert_from_v(__cs, __cs_size, "%.0f", __dunits,
+					_S_get_c_locale());
+      // If the buffer was not large enough, try again with the correct size.
+      if (__len >= __cs_size)
+	{
+	  __cs_size = __len + 1;
+	  __cs = static_cast<char*>(__builtin_alloca(__cs_size));
+	  __len = std::__convert_from_v(__cs, __cs_size, "%.0f", __dunits,
+					_S_get_c_locale());
+	}
+#else
+      // max_exponent10 + 1 for the integer part, + 2 for sign and '\0'.
+      const int __cs_size = numeric_limits<long double>::max_exponent10 + 3;
+      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
+      int __len = std::__convert_from_v(__cs, 0, "%.0f", __dunits,
+					_S_get_c_locale());
+#endif
+#else // _GLIBCXX_NO_LONG_DOUBLE_IO
 #ifdef _GLIBCXX_USE_C99
       // First try a buffer perhaps big enough.
       int __cs_size = 64;
@@ -1690,6 +1735,7 @@
       int __len = std::__convert_from_v(__cs, 0, "%.*Lf", __units,
 					_S_get_c_locale(), 0);
 #endif
+#endif  // _GLIBCXX_NO_LONG_DOUBLE_IO
       _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
 							   * __cs_size));
       __ctype.widen(__cs, __cs + __len, __ws);
diff -Nbaur gcc-3.4.3/libstdc++-v3/include/bits/stringfwd.h gcc-3.4.3-new/libstdc++-v3/include/bits/stringfwd.h
--- gcc-3.4.3/libstdc++-v3/include/bits/stringfwd.h	Thu Mar 18 17:37:03 2004
+++ gcc-3.4.3-new/libstdc++-v3/include/bits/stringfwd.h	Fri Jan 21 10:25:52 2005
@@ -59,7 +59,7 @@
 
   typedef basic_string<char>    string;
 
-#ifdef _GLIBCXX_USE_WCHAR_T
+#if defined (_GLIBCXX_USE_WCHAR_T) || defined (_GLIBCXX_USE_WSTRING)
   template<> struct char_traits<wchar_t>;
 
   typedef basic_string<wchar_t> wstring;
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/Makefile.in gcc-3.4.3-new/libstdc++-v3/libsupc++/Makefile.in
--- gcc-3.4.3/libstdc++-v3/libsupc++/Makefile.in	Thu Mar 18 17:37:08 2004
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/Makefile.in	Fri Jan 21 10:25:52 2005
@@ -210,7 +210,7 @@
 # These bits are all figured out from configure.  Look in acinclude.m4
 # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
 CONFIG_CXXFLAGS = \
-	$(SECTION_FLAGS) $(EXTRA_CXX_FLAGS)
+	$(EXTRA_CXX_FLAGS)
 
 WARN_CXXFLAGS = \
 	$(WARN_FLAGS) $(WERROR) -fdiagnostics-show-location=once
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/eh_globals.cc gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_globals.cc
--- gcc-3.4.3/libstdc++-v3/libsupc++/eh_globals.cc	Fri Apr 30 05:20:24 2004
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_globals.cc	Fri Jan 21 10:25:52 2005
@@ -32,6 +32,9 @@
 #include <cstdlib>
 #include "unwind-cxx.h"
 #include "bits/c++config.h"
+#ifdef __MINGW32__
+#undef __GTHREAD_HIDE_WIN32API
+#endif
 #include "bits/gthr.h"
 
 using namespace __cxxabiv1;
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/eh_term_handler.cc gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_term_handler.cc
--- gcc-3.4.3/libstdc++-v3/libsupc++/eh_term_handler.cc	Tue Sep  2 19:46:54 2003
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_term_handler.cc	Fri Jan 21 10:25:52 2005
@@ -41,6 +41,7 @@
 # include <cstdlib>
 #endif
 
+#if !(defined (__MINGW32__) || defined (__CYGWIN__))
 /* The current installed user handler.  */
 std::terminate_handler __cxxabiv1::__terminate_handler =
 #if _GLIBCXX_HOSTED
@@ -49,3 +50,4 @@
 	std::abort;
 #endif
 
+#endif
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/eh_terminate.cc gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_terminate.cc
--- gcc-3.4.3/libstdc++-v3/libsupc++/eh_terminate.cc	Sat May 24 17:22:03 2003
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_terminate.cc	Fri Jan 21 10:25:52 2005
@@ -50,6 +50,11 @@
 void
 std::terminate ()
 {
+#if 0 // (defined (__MINGW32__) || defined (__CYGWIN__))
+  if (__terminate_handler == NULL )
+    __terminate (__gnu_cxx::__verbose_terminate_handler);
+  else
+#endif
   __terminate (__terminate_handler);
 }
 
@@ -63,6 +68,11 @@
 void
 std::unexpected ()
 {
+#if  0 // (defined (__MINGW32__) || defined (__CYGWIN__))
+  if (__unexpected_handler == NULL)
+    std::terminate();
+  else
+#endif
   __unexpected (__unexpected_handler);
 }
 
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/eh_unex_handler.cc gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_unex_handler.cc
--- gcc-3.4.3/libstdc++-v3/libsupc++/eh_unex_handler.cc	Sat May 24 17:22:03 2003
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/eh_unex_handler.cc	Fri Jan 21 10:25:52 2005
@@ -29,6 +29,7 @@
 
 #include "unwind-cxx.h"
 
+#if !(defined  (__MINGW32__) || defined (__CYGWIN__))
 /* The current installed user handler.  */
 std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
-
+#endif
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/typeinfo gcc-3.4.3-new/libstdc++-v3/libsupc++/typeinfo
--- gcc-3.4.3/libstdc++-v3/libsupc++/typeinfo	Sat Jul  5 05:05:40 2003
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/typeinfo	Fri Jan 21 10:25:52 2005
@@ -44,7 +44,7 @@
   class __class_type_info;
 } // namespace __cxxabiv1
 
-#if !__GXX_WEAK__
+#if !__GXX_WEAK__ || defined (__MINGW32__) || defined (__CYGWIN__)
   // If weak symbols are not supported, typeinfo names are not merged.
   #define __GXX_MERGED_TYPEINFO_NAMES 0
 #else
diff -Nbaur gcc-3.4.3/libstdc++-v3/libsupc++/unwind-cxx.h gcc-3.4.3-new/libstdc++-v3/libsupc++/unwind-cxx.h
--- gcc-3.4.3/libstdc++-v3/libsupc++/unwind-cxx.h	Sat Jul  5 05:05:41 2003
+++ gcc-3.4.3-new/libstdc++-v3/libsupc++/unwind-cxx.h	Fri Jan 21 10:25:52 2005
@@ -125,9 +125,16 @@
 extern void __terminate(std::terminate_handler) __attribute__((noreturn));
 extern void __unexpected(std::unexpected_handler) __attribute__((noreturn));
 
-// The current installed user handlers.
+ // The current installed user handlers.
+#if defined  (__MINGW32__) || defined (__CYGWIN__)
+extern "C" void** __w32_sharedptr_terminate;
+extern "C" void** __w32_sharedptr_unexpected;
+#define __terminate_handler (*(std::terminate_handler*)(__w32_sharedptr_terminate))
+#define __unexpected_handler (*(std::unexpected_handler*)(__w32_sharedptr_unexpected))
+#else
 extern std::terminate_handler __terminate_handler;
 extern std::unexpected_handler __unexpected_handler;
+#endif
 
 // These are explicitly GNU C++ specific.
 
diff -Nbaur gcc-3.4.3/libstdc++-v3/src/Makefile.in gcc-3.4.3-new/libstdc++-v3/src/Makefile.in
--- gcc-3.4.3/libstdc++-v3/src/Makefile.in	Fri Apr 16 20:08:35 2004
+++ gcc-3.4.3-new/libstdc++-v3/src/Makefile.in	Fri Jan 21 10:25:52 2005
@@ -211,7 +211,7 @@
 # These bits are all figured out from configure.  Look in acinclude.m4
 # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
 CONFIG_CXXFLAGS = \
-	$(SECTION_FLAGS) $(EXTRA_CXX_FLAGS)
+	$(EXTRA_CXX_FLAGS)
 
 WARN_CXXFLAGS = \
 	$(WARN_FLAGS) $(WERROR) -fdiagnostics-show-location=once
diff -Nbaur gcc-3.4.3/libstdc++-v3/src/globals_io.cc gcc-3.4.3-new/libstdc++-v3/src/globals_io.cc
--- gcc-3.4.3/libstdc++-v3/src/globals_io.cc	Thu Mar 18 17:37:13 2004
+++ gcc-3.4.3-new/libstdc++-v3/src/globals_io.cc	Fri Jan 21 10:25:52 2005
@@ -26,6 +26,9 @@
 // the GNU General Public License.
 
 #include "bits/c++config.h"
+#ifdef __MINGW32__
+#undef __GTHREAD_HIDE_WIN32API
+#endif
 #include "bits/gthr.h"
 #include <fstream>
 #include <istream>
diff -Nbaur gcc-3.4.3/ltcf-c.sh gcc-3.4.3-new/ltcf-c.sh
--- gcc-3.4.3/ltcf-c.sh	Wed Nov 19 05:29:32 2003
+++ gcc-3.4.3-new/ltcf-c.sh	Fri Jan 21 10:25:52 2005
@@ -38,17 +38,17 @@
 lt_simple_link_test_code='main(){return(0);}'
 
 ## Linker Characteristics
-case $host_os in
-cygwin* | mingw*)
+#case $host_os in
+#cygwin* | mingw*)
   # FIXME: the MSVC++ port hasn't been tested in a loooong time
   # When not using gcc, we currently assume that we are using
   # Microsoft Visual C++.
-  if test "$with_gcc" != yes; then
-    with_gnu_ld=no
-  fi
-  ;;
-
-esac
+#  if test "$with_gcc" != yes; then
+#    with_gnu_ld=no
+#  fi
+#  ;;
+#
+#esac
 
 ld_shlibs=yes
 if test "$with_gnu_ld" = yes; then
