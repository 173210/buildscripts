diff -Nbaur gdb-6.6/configure gdb-6.6-mingw/configure
--- gdb-6.6/configure	Tue Nov 14 23:26:39 2006
+++ gdb-6.6-mingw/configure	Tue Jun 12 18:33:14 2007
@@ -3271,7 +3271,7 @@
 
 # Host dirs don't like to share a cache file either, horribly enough.
 # This seems to be due to autoconf 2.5x stupidity.
-host_configargs="--cache-file=./config.cache --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
+host_configargs="${cache_file_option} --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
 
 target_configargs=${baseargs}
 
diff -Nbaur gdb-6.6/configure.in gdb-6.6-mingw/configure.in
--- gdb-6.6/configure.in	Mon Dec 18 07:22:58 2006
+++ gdb-6.6-mingw/configure.in	Tue Jun 12 18:33:14 2007
@@ -2024,7 +2024,7 @@
 
 # Host dirs don't like to share a cache file either, horribly enough.
 # This seems to be due to autoconf 2.5x stupidity.
-host_configargs="--cache-file=./config.cache --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
+host_configargs="${cache_file_option} --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
 
 target_configargs=${baseargs}
 
diff -Nbaur gdb-6.6/gdb/Makefile.in gdb-6.6-mingw/gdb/Makefile.in
--- gdb-6.6/gdb/Makefile.in	Fri Nov 24 19:54:14 2006
+++ gdb-6.6-mingw/gdb/Makefile.in	Tue Jun 12 18:33:14 2007
@@ -2983,7 +2983,7 @@
 insight$(EXEEXT): gdbtk-main.o libgdb.a $(ADD_DEPS) \
 		$(CDEPS) $(TDEPLIBS)
 	rm -f insight$(EXEEXT)
-	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
+	$(CC_LD) -mwindows $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
 		-o insight$(EXEEXT) gdbtk-main.o libgdb.a \
 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
 
diff -Nbaur gdb-6.6/gdb/config/i386/mingw.mh gdb-6.6-mingw/gdb/config/i386/mingw.mh
--- gdb-6.6/gdb/config/i386/mingw.mh	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-mingw/gdb/config/i386/mingw.mh	Tue Jun 12 18:33:15 2007
@@ -0,0 +1,5 @@
+MH_CFLAGS=-D_POSIX_
+XM_FILE=xm-mingw32.h
+NATDEPFILES= i386-nat.o win32-nat.o corelow.o
+NAT_FILE=nm-mingw32.h
+XM_CLIBS=
diff -Nbaur gdb-6.6/gdb/config/i386/mingw.mt gdb-6.6-mingw/gdb/config/i386/mingw.mt
--- gdb-6.6/gdb/config/i386/mingw.mt	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-mingw/gdb/config/i386/mingw.mt	Tue Jun 12 18:33:15 2007
@@ -0,0 +1,4 @@
+# Target: Intel x86 running Win32 (MinGW)
+TDEPFILES= i386-tdep.o i386-win32-tdep.o i387-tdep.o
+DEPRECATED_TM_FILE= tm-mingw32.h
+GDBSERVER_DEPFILES=
diff -Nbaur gdb-6.6/gdb/config/i386/nm-mingw32.h gdb-6.6-mingw/gdb/config/i386/nm-mingw32.h
--- gdb-6.6/gdb/config/i386/nm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-mingw/gdb/config/i386/nm-mingw32.h	Tue Jun 12 18:33:15 2007
@@ -0,0 +1,38 @@
+/* Native definitions for Intel x86 running MinGW.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define NO_PTRACE_H
+
+#define I386_USE_GENERIC_WATCHPOINTS
+
+#include "i386/nm-i386.h"
+
+/* Support for hardware-assisted breakpoints and watchpoints.  */
+
+#define I386_DR_LOW_SET_CONTROL(VAL)	cygwin_set_dr7 (VAL)
+extern void cygwin_set_dr7 (unsigned);
+
+#define I386_DR_LOW_SET_ADDR(N,ADDR)	cygwin_set_dr (N,ADDR)
+extern void cygwin_set_dr (int, CORE_ADDR);
+
+#define I386_DR_LOW_RESET_ADDR(N)
+
+#define I386_DR_LOW_GET_STATUS()	cygwin_get_dr6 ()
+extern unsigned cygwin_get_dr6 (void);
diff -Nbaur gdb-6.6/gdb/config/i386/tm-mingw32.h gdb-6.6-mingw/gdb/config/i386/tm-mingw32.h
--- gdb-6.6/gdb/config/i386/tm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-mingw/gdb/config/i386/tm-mingw32.h	Tue Jun 12 18:33:15 2007
@@ -0,0 +1,21 @@
+/* Macro definitions for i386 running under Win32.
+   Copyright 1999 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "i386/tm-cygwin.h"
+
diff -Nbaur gdb-6.6/gdb/config/i386/xm-mingw32.h gdb-6.6-mingw/gdb/config/i386/xm-mingw32.h
--- gdb-6.6/gdb/config/i386/xm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-mingw/gdb/config/i386/xm-mingw32.h	Tue Jun 12 18:33:15 2007
@@ -0,0 +1,25 @@
+/* Definitions for hosting on WIN32, building with MinGW, for GDB.
+   Copyright 1999 Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "fopen-bin.h"
+#define getkey getch
+#define DIRNAME_SEPARATOR ';'
+
+/* Define this if source files use \r\n rather than just \n.  */
+#define CRLF_SOURCE_FILES
diff -Nbaur gdb-6.6/gdb/defs.h gdb-6.6-mingw/gdb/defs.h
--- gdb-6.6/gdb/defs.h	Thu Sep 21 14:50:51 2006
+++ gdb-6.6-mingw/gdb/defs.h	Tue Jun 12 18:33:15 2007
@@ -1167,7 +1167,7 @@
 /* FIXME, this doesn't work very well if host and executable
    filesystems conventions are different.  */
 
-#ifdef __MSDOS__
+#if defined(__MSDOS__) || (!defined (__CYGWIN__) && defined (_WIN32))
 # define CANT_FORK
 # define GLOBAL_CURDIR
 # define DIRNAME_SEPARATOR ';'
diff -Nbaur gdb-6.6/gdb/tui/tui-io.c gdb-6.6-mingw/gdb/tui/tui-io.c
--- gdb-6.6/gdb/tui/tui-io.c	Fri Dec 23 19:10:02 2005
+++ gdb-6.6-mingw/gdb/tui/tui-io.c	Tue Jun 12 18:33:24 2007
@@ -113,8 +113,11 @@
 
 /* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
 #define TUI_USE_PIPE_FOR_READLINE
-/*#undef TUI_USE_PIPE_FOR_READLINE*/
 
+/* but remove for mingw host */
+#ifdef __MINGW32__
+#undef TUI_USE_PIPE_FOR_READLINE
+#endif
 /* TUI output files.  */
 static struct ui_file *tui_stdout;
 static struct ui_file *tui_stderr;
diff -Nbaur gdb-6.6/gdb/win32-nat.c gdb-6.6-mingw/gdb/win32-nat.c
--- gdb-6.6/gdb/win32-nat.c	Mon May 22 00:04:39 2006
+++ gdb-6.6-mingw/gdb/win32-nat.c	Tue Jun 12 18:33:24 2007
@@ -43,7 +43,11 @@
 #include <stdlib.h>
 #include <windows.h>
 #include <imagehlp.h>
+
+#if defined (__CYGWIN__)
 #include <sys/cygwin.h>
+#endif /* __CYGWIN__ */
+
 #include <signal.h>
 
 #include "buildsym.h"
@@ -81,7 +85,65 @@
     CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
   };
 #endif
-#include <sys/procfs.h>
+#ifndef __MINGW32__
+  #include <sys/procfs.h>
+#else
+  #define	NOTE_INFO_PROCESS	1
+  #define	NOTE_INFO_THREAD	2
+  #define	NOTE_INFO_MODULE	3
+
+  struct win32_core_process_info
+  {
+    DWORD pid;
+    int signal;
+    int command_line_size;
+    char command_line[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_thread_info
+  {
+    DWORD tid;
+    BOOL is_active_thread;
+    CONTEXT thread_context;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_module_info
+  {
+    void* base_address;
+    int module_name_size;
+    char module_name[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_pstatus
+  {
+    unsigned long data_type;
+    union
+      {
+        struct win32_core_process_info process_info;
+        struct win32_core_thread_info thread_info;
+        struct win32_core_module_info module_info;
+      } data ;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  typedef struct win32_pstatus win32_pstatus_t ;
+
+#endif
 #include <psapi.h>
 
 #define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
@@ -446,30 +508,23 @@
 static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD) = NULL;
 static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD) = NULL;
 
-static int
-psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
-{
-  DWORD len;
-  MODULEINFO mi;
-  int i;
-  HMODULE dh_buf[1];
-  HMODULE *DllHandle = dh_buf;
-  DWORD cbNeeded;
-  BOOL ok;
 
+BOOL
+load_psapi ()
+{
   if (!psapi_loaded ||
       psapi_EnumProcessModules == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
     {
       if (psapi_loaded)
-	goto failed;
+        return FALSE;
       psapi_loaded = 1;
       psapi_module_handle = LoadLibrary ("psapi.dll");
       if (!psapi_module_handle)
 	{
 	  /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ()); */
-	  goto failed;
+	  return FALSE;
 	}
       psapi_EnumProcessModules = GetProcAddress (psapi_module_handle, "EnumProcessModules");
       psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
@@ -478,8 +533,24 @@
       if (psapi_EnumProcessModules == NULL ||
 	  psapi_GetModuleInformation == NULL ||
 	  psapi_GetModuleFileNameExA == NULL)
-	goto failed;
+	    return FALSE;
     }
+  return TRUE;
+}
+
+int
+psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
+{
+  DWORD len;
+  MODULEINFO mi;
+  int i;
+  HMODULE dh_buf[1];
+  HMODULE *DllHandle = dh_buf;
+  DWORD cbNeeded;
+  BOOL ok;
+
+  if (!load_psapi ())
+    goto failed;
 
   cbNeeded = 0;
   ok = (*psapi_EnumProcessModules) (current_process_handle,
@@ -507,14 +578,14 @@
 					  DllHandle[i],
 					  &mi,
 					  sizeof (mi)))
-	error (_("Can't get module info"));
+	error ("Can't get module info");
 
       len = (*psapi_GetModuleFileNameExA) (current_process_handle,
 					   DllHandle[i],
 					   dll_name_ret,
 					   MAX_PATH);
       if (len == 0)
-	error (_("Error getting dll name: %u."), (unsigned) GetLastError ());
+	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
 
       if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
 	return 1;
@@ -525,6 +596,30 @@
   return 0;
 }
 
+int
+psapi_get_module_filename (HANDLE hProcess,
+                           HMODULE hModule,
+                           LPTSTR lpFilename,
+                           DWORD nSize)
+{
+  DWORD len;
+
+  if (!load_psapi ())
+    goto failed;
+
+  len = (*psapi_GetModuleFileNameExA) (hProcess,
+                                       hModule,
+                                       lpFilename,
+                                       nSize);
+  if (len == 0)
+    error ("Error getting file name: %u\n", (unsigned) GetLastError ());
+
+failed:
+  lpFilename[0] = '\0';
+  return 0;
+}
+
+
 /* Encapsulate the information required in a call to
    symbol_file_add_args */
 struct safe_symbol_file_add_args
@@ -753,7 +848,13 @@
   so = XZALLOC (struct so_list);
   so->lm_info = (struct lm_info *) xmalloc (sizeof (struct lm_info));
   so->lm_info->load_addr = load_addr;
+
+#ifdef __CYGWIN__
   cygwin_conv_to_posix_path (buf, so->so_name);
+#else
+  strcpy( so->so_name, buf);
+#endif
+
   strcpy (so->so_original_name, so->so_name);
 
   solib_end->next = so;
@@ -1734,6 +1835,7 @@
 
   if (!ok)
     {
+#ifdef __CYGWIN__
       /* Try fall back to Cygwin pid */
       pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);
 
@@ -1741,6 +1843,7 @@
 	ok = DebugActiveProcess (pid);
 
       if (!ok)
+#endif /* __CYGWIN__ */
 	error (_("Can't attach to process."));
     }
 
@@ -1800,13 +1903,14 @@
 static char *
 win32_pid_to_exec_file (int pid)
 {
+  static char path[MAX_PATH + 1];
+  char *path_ptr = NULL;
+#ifdef __CYGWIN__
   /* Try to find the process path using the Cygwin internal process list
      pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
      instead.  */
   /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
 
-  static char path[MAX_PATH + 1];
-  char *path_ptr = NULL;
   int cpid;
   struct external_pinfo *pinfo;
 
@@ -1824,6 +1928,13 @@
        }
     }
   cygwin_internal (CW_UNLOCK_PINFO);
+#else
+  if (!psapi_get_module_filename (current_process_handle, NULL, path, MAX_PATH))
+    printf_unfiltered ("error reading the process's file name: %lu",
+                       GetLastError ());
+  else
+    path_ptr = path;
+#endif
   return path_ptr;
 }
 
@@ -1873,8 +1984,16 @@
   char *toexec;
   char shell[MAX_PATH + 1]; /* Path to shell */
   const char *sh;
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  HANDLE hStdInput = 0;
+  HANDLE hStdOutput = 0;
+  HANDLE hStdError = 0;
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   int tty;
   int ostdin, ostdout, ostderr;
+#endif /* !__MINGW32__ */
   const char *inferior_io_terminal = get_inferior_io_terminal ();
 
   if (!exec_file)
@@ -1886,7 +2005,12 @@
   if (!useshell)
     {
       flags = DEBUG_ONLY_THIS_PROCESS;
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (exec_file, real_path);
+#else
+      strcpy (real_path, exec_file);
+#endif
+
       toexec = real_path;
     }
   else
@@ -1895,7 +2019,11 @@
       sh = getenv ("SHELL");
       if (!sh)
 	sh = "/bin/sh";
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (sh, shell);
+#else
+      strcpy (shell, sh);
+#endif
       newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
 			   + strlen (allargs) + 2);
       sprintf (newallargs, " -c 'exec %s %s'", exec_file, allargs);
@@ -1946,10 +2074,12 @@
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], in_env[i], len) == 0)
 	      {
-		if (cygwin_posix_path_list_p (in_env[i] + len))
+#ifdef __CYGWIN__
+		if (cygwin_posix_path_list_p (env[i] + len))
 		  envlen += len
-		    + cygwin_posix_to_win32_path_list_buf_size (in_env[i] + len);
+		    + cygwin_posix_to_win32_path_list_buf_size (env[i] + len);
 		else
+#endif
 		  envlen += strlen (in_env[i]) + 1;
 		break;
 	      }
@@ -1976,12 +2106,14 @@
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], env[i], len) == 0)
 	      {
+#ifdef __CYGWIN__
 		if (cygwin_posix_path_list_p (env[i] + len))
 		  {
 		    memcpy (temp, env[i], len);
 		    cygwin_posix_to_win32_path_list (env[i] + len, temp + len);
 		  }
 		else
+#endif
 		  strcpy (temp, env[i]);
 		break;
 	      }
@@ -1996,6 +2128,20 @@
     *temp = 0;
   }
 
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      hStdInput = GetStdHandle( STD_INPUT_HANDLE);
+      hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE);
+      hStdError = GetStdHandle( STD_ERROR_HANDLE);
+
+      SetStdHandle( STD_INPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_OUTPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_ERROR_HANDLE, INVALID_HANDLE_VALUE);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   if (!inferior_io_terminal)
     tty = ostdin = ostdout = ostderr = -1;
   else
@@ -2016,6 +2162,7 @@
 	  dup2 (tty, 2);
 	}
     }
+#endif /* !__MINGW32__ */
 
   win32_init_thread_list ();
   ret = CreateProcess (0,
@@ -2028,6 +2175,16 @@
 		       NULL,	/* current directory */
 		       &si,
 		       &pi);
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      SetStdHandle( STD_INPUT_HANDLE, hStdInput);
+      SetStdHandle( STD_OUTPUT_HANDLE, hStdOutput);
+      SetStdHandle( STD_ERROR_HANDLE, hStdError);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   if (tty >= 0)
     {
       close (tty);
@@ -2038,6 +2195,7 @@
       close (ostdout);
       close (ostderr);
     }
+#endif /* !__MINGW32__ */
 
   if (!ret)
     error (_("Error creating process %s, (error %d)."),
