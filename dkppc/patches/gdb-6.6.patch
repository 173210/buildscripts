diff -Nbaur gdb-6.6/config.sub gdb-6.6-ppc/config.sub
--- gdb-6.6/config.sub	Tue Sep 26 06:22:50 2006
+++ gdb-6.6-ppc/config.sub	Sat Jun 16 04:14:21 2007
@@ -230,6 +230,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	-gekko)
+		basic_machine=powerpc-eabi
+		os=-elf
+		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
diff -Nbaur gdb-6.6/configure gdb-6.6-ppc/configure
--- gdb-6.6/configure	Tue Nov 14 23:26:39 2006
+++ gdb-6.6-ppc/configure	Sat Jun 16 04:14:12 2007
@@ -3271,7 +3271,7 @@
 
 # Host dirs don't like to share a cache file either, horribly enough.
 # This seems to be due to autoconf 2.5x stupidity.
-host_configargs="--cache-file=./config.cache --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
+host_configargs="${cache_file_option} --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
 
 target_configargs=${baseargs}
 
diff -Nbaur gdb-6.6/configure.in gdb-6.6-ppc/configure.in
--- gdb-6.6/configure.in	Mon Dec 18 07:22:58 2006
+++ gdb-6.6-ppc/configure.in	Sat Jun 16 04:14:12 2007
@@ -2024,7 +2024,7 @@
 
 # Host dirs don't like to share a cache file either, horribly enough.
 # This seems to be due to autoconf 2.5x stupidity.
-host_configargs="--cache-file=./config.cache --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
+host_configargs="${cache_file_option} --build=${build_alias} --host=${host_alias} --target=${target_alias} ${extra_host_args} ${baseargs}"
 
 target_configargs=${baseargs}
 
diff -Nbaur gdb-6.6/gdb/Makefile.in gdb-6.6-ppc/gdb/Makefile.in
--- gdb-6.6/gdb/Makefile.in	Fri Nov 24 19:54:14 2006
+++ gdb-6.6-ppc/gdb/Makefile.in	Sat Jun 16 04:14:12 2007
@@ -2983,7 +2983,7 @@
 insight$(EXEEXT): gdbtk-main.o libgdb.a $(ADD_DEPS) \
 		$(CDEPS) $(TDEPLIBS)
 	rm -f insight$(EXEEXT)
-	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
+	$(CC_LD) -mwindows $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
 		-o insight$(EXEEXT) gdbtk-main.o libgdb.a \
 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
 
diff -Nbaur gdb-6.6/gdb/config/i386/mingw.mh gdb-6.6-ppc/gdb/config/i386/mingw.mh
--- gdb-6.6/gdb/config/i386/mingw.mh	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-ppc/gdb/config/i386/mingw.mh	Sat Jun 16 04:14:12 2007
@@ -0,0 +1,5 @@
+MH_CFLAGS=-D_POSIX_
+XM_FILE=xm-mingw32.h
+NATDEPFILES= i386-nat.o win32-nat.o corelow.o
+NAT_FILE=nm-mingw32.h
+XM_CLIBS=
diff -Nbaur gdb-6.6/gdb/config/i386/mingw.mt gdb-6.6-ppc/gdb/config/i386/mingw.mt
--- gdb-6.6/gdb/config/i386/mingw.mt	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-ppc/gdb/config/i386/mingw.mt	Sat Jun 16 04:14:12 2007
@@ -0,0 +1,4 @@
+# Target: Intel x86 running Win32 (MinGW)
+TDEPFILES= i386-tdep.o i386-win32-tdep.o i387-tdep.o
+DEPRECATED_TM_FILE= tm-mingw32.h
+GDBSERVER_DEPFILES=
diff -Nbaur gdb-6.6/gdb/config/i386/nm-mingw32.h gdb-6.6-ppc/gdb/config/i386/nm-mingw32.h
--- gdb-6.6/gdb/config/i386/nm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-ppc/gdb/config/i386/nm-mingw32.h	Sat Jun 16 04:14:12 2007
@@ -0,0 +1,38 @@
+/* Native definitions for Intel x86 running MinGW.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define NO_PTRACE_H
+
+#define I386_USE_GENERIC_WATCHPOINTS
+
+#include "i386/nm-i386.h"
+
+/* Support for hardware-assisted breakpoints and watchpoints.  */
+
+#define I386_DR_LOW_SET_CONTROL(VAL)	cygwin_set_dr7 (VAL)
+extern void cygwin_set_dr7 (unsigned);
+
+#define I386_DR_LOW_SET_ADDR(N,ADDR)	cygwin_set_dr (N,ADDR)
+extern void cygwin_set_dr (int, CORE_ADDR);
+
+#define I386_DR_LOW_RESET_ADDR(N)
+
+#define I386_DR_LOW_GET_STATUS()	cygwin_get_dr6 ()
+extern unsigned cygwin_get_dr6 (void);
diff -Nbaur gdb-6.6/gdb/config/i386/tm-mingw32.h gdb-6.6-ppc/gdb/config/i386/tm-mingw32.h
--- gdb-6.6/gdb/config/i386/tm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-ppc/gdb/config/i386/tm-mingw32.h	Sat Jun 16 04:14:12 2007
@@ -0,0 +1,21 @@
+/* Macro definitions for i386 running under Win32.
+   Copyright 1999 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "i386/tm-cygwin.h"
+
diff -Nbaur gdb-6.6/gdb/config/i386/xm-mingw32.h gdb-6.6-ppc/gdb/config/i386/xm-mingw32.h
--- gdb-6.6/gdb/config/i386/xm-mingw32.h	Thu Jan  1 00:00:00 1970
+++ gdb-6.6-ppc/gdb/config/i386/xm-mingw32.h	Sat Jun 16 04:14:12 2007
@@ -0,0 +1,25 @@
+/* Definitions for hosting on WIN32, building with MinGW, for GDB.
+   Copyright 1999 Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "fopen-bin.h"
+#define getkey getch
+#define DIRNAME_SEPARATOR ';'
+
+/* Define this if source files use \r\n rather than just \n.  */
+#define CRLF_SOURCE_FILES
diff -Nbaur gdb-6.6/gdb/defs.h gdb-6.6-ppc/gdb/defs.h
--- gdb-6.6/gdb/defs.h	Thu Sep 21 14:50:51 2006
+++ gdb-6.6-ppc/gdb/defs.h	Sat Jun 16 04:14:12 2007
@@ -1167,7 +1167,7 @@
 /* FIXME, this doesn't work very well if host and executable
    filesystems conventions are different.  */
 
-#ifdef __MSDOS__
+#if defined(__MSDOS__) || (!defined (__CYGWIN__) && defined (_WIN32))
 # define CANT_FORK
 # define GLOBAL_CURDIR
 # define DIRNAME_SEPARATOR ';'
diff -Nbaur gdb-6.6/gdb/tui/tui-io.c gdb-6.6-ppc/gdb/tui/tui-io.c
--- gdb-6.6/gdb/tui/tui-io.c	Fri Dec 23 19:10:02 2005
+++ gdb-6.6-ppc/gdb/tui/tui-io.c	Sat Jun 16 04:14:12 2007
@@ -113,8 +113,11 @@
 
 /* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
 #define TUI_USE_PIPE_FOR_READLINE
-/*#undef TUI_USE_PIPE_FOR_READLINE*/
 
+/* but remove for mingw host */
+#ifdef __MINGW32__
+#undef TUI_USE_PIPE_FOR_READLINE
+#endif
 /* TUI output files.  */
 static struct ui_file *tui_stdout;
 static struct ui_file *tui_stderr;
diff -Nbaur gdb-6.6/gdb/win32-nat.c gdb-6.6-ppc/gdb/win32-nat.c
--- gdb-6.6/gdb/win32-nat.c	Mon May 22 00:04:39 2006
+++ gdb-6.6-ppc/gdb/win32-nat.c	Sat Jun 16 04:14:12 2007
@@ -43,7 +43,11 @@
 #include <stdlib.h>
 #include <windows.h>
 #include <imagehlp.h>
+
+#if defined (__CYGWIN__)
 #include <sys/cygwin.h>
+#endif /* __CYGWIN__ */
+
 #include <signal.h>
 
 #include "buildsym.h"
@@ -81,7 +85,65 @@
     CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
   };
 #endif
-#include <sys/procfs.h>
+#ifndef __MINGW32__
+  #include <sys/procfs.h>
+#else
+  #define	NOTE_INFO_PROCESS	1
+  #define	NOTE_INFO_THREAD	2
+  #define	NOTE_INFO_MODULE	3
+
+  struct win32_core_process_info
+  {
+    DWORD pid;
+    int signal;
+    int command_line_size;
+    char command_line[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_thread_info
+  {
+    DWORD tid;
+    BOOL is_active_thread;
+    CONTEXT thread_context;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_module_info
+  {
+    void* base_address;
+    int module_name_size;
+    char module_name[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_pstatus
+  {
+    unsigned long data_type;
+    union
+      {
+        struct win32_core_process_info process_info;
+        struct win32_core_thread_info thread_info;
+        struct win32_core_module_info module_info;
+      } data ;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  typedef struct win32_pstatus win32_pstatus_t ;
+
+#endif
 #include <psapi.h>
 
 #define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
@@ -446,30 +508,23 @@
 static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD) = NULL;
 static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD) = NULL;
 
-static int
-psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
-{
-  DWORD len;
-  MODULEINFO mi;
-  int i;
-  HMODULE dh_buf[1];
-  HMODULE *DllHandle = dh_buf;
-  DWORD cbNeeded;
-  BOOL ok;
 
+BOOL
+load_psapi ()
+{
   if (!psapi_loaded ||
       psapi_EnumProcessModules == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
     {
       if (psapi_loaded)
-	goto failed;
+        return FALSE;
       psapi_loaded = 1;
       psapi_module_handle = LoadLibrary ("psapi.dll");
       if (!psapi_module_handle)
 	{
 	  /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ()); */
-	  goto failed;
+	  return FALSE;
 	}
       psapi_EnumProcessModules = GetProcAddress (psapi_module_handle, "EnumProcessModules");
       psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
@@ -478,8 +533,24 @@
       if (psapi_EnumProcessModules == NULL ||
 	  psapi_GetModuleInformation == NULL ||
 	  psapi_GetModuleFileNameExA == NULL)
-	goto failed;
+	    return FALSE;
     }
+  return TRUE;
+}
+
+int
+psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
+{
+  DWORD len;
+  MODULEINFO mi;
+  int i;
+  HMODULE dh_buf[1];
+  HMODULE *DllHandle = dh_buf;
+  DWORD cbNeeded;
+  BOOL ok;
+
+  if (!load_psapi ())
+    goto failed;
 
   cbNeeded = 0;
   ok = (*psapi_EnumProcessModules) (current_process_handle,
@@ -507,14 +578,14 @@
 					  DllHandle[i],
 					  &mi,
 					  sizeof (mi)))
-	error (_("Can't get module info"));
+	error ("Can't get module info");
 
       len = (*psapi_GetModuleFileNameExA) (current_process_handle,
 					   DllHandle[i],
 					   dll_name_ret,
 					   MAX_PATH);
       if (len == 0)
-	error (_("Error getting dll name: %u."), (unsigned) GetLastError ());
+	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
 
       if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
 	return 1;
@@ -525,6 +596,30 @@
   return 0;
 }
 
+int
+psapi_get_module_filename (HANDLE hProcess,
+                           HMODULE hModule,
+                           LPTSTR lpFilename,
+                           DWORD nSize)
+{
+  DWORD len;
+
+  if (!load_psapi ())
+    goto failed;
+
+  len = (*psapi_GetModuleFileNameExA) (hProcess,
+                                       hModule,
+                                       lpFilename,
+                                       nSize);
+  if (len == 0)
+    error ("Error getting file name: %u\n", (unsigned) GetLastError ());
+
+failed:
+  lpFilename[0] = '\0';
+  return 0;
+}
+
+
 /* Encapsulate the information required in a call to
    symbol_file_add_args */
 struct safe_symbol_file_add_args
@@ -753,7 +848,13 @@
   so = XZALLOC (struct so_list);
   so->lm_info = (struct lm_info *) xmalloc (sizeof (struct lm_info));
   so->lm_info->load_addr = load_addr;
+
+#ifdef __CYGWIN__
   cygwin_conv_to_posix_path (buf, so->so_name);
+#else
+  strcpy( so->so_name, buf);
+#endif
+
   strcpy (so->so_original_name, so->so_name);
 
   solib_end->next = so;
@@ -1734,6 +1835,7 @@
 
   if (!ok)
     {
+#ifdef __CYGWIN__
       /* Try fall back to Cygwin pid */
       pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);
 
@@ -1741,6 +1843,7 @@
 	ok = DebugActiveProcess (pid);
 
       if (!ok)
+#endif /* __CYGWIN__ */
 	error (_("Can't attach to process."));
     }
 
@@ -1800,13 +1903,14 @@
 static char *
 win32_pid_to_exec_file (int pid)
 {
+  static char path[MAX_PATH + 1];
+  char *path_ptr = NULL;
+#ifdef __CYGWIN__
   /* Try to find the process path using the Cygwin internal process list
      pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
      instead.  */
   /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
 
-  static char path[MAX_PATH + 1];
-  char *path_ptr = NULL;
   int cpid;
   struct external_pinfo *pinfo;
 
@@ -1824,6 +1928,13 @@
        }
     }
   cygwin_internal (CW_UNLOCK_PINFO);
+#else
+  if (!psapi_get_module_filename (current_process_handle, NULL, path, MAX_PATH))
+    printf_unfiltered ("error reading the process's file name: %lu",
+                       GetLastError ());
+  else
+    path_ptr = path;
+#endif
   return path_ptr;
 }
 
@@ -1873,8 +1984,16 @@
   char *toexec;
   char shell[MAX_PATH + 1]; /* Path to shell */
   const char *sh;
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  HANDLE hStdInput = 0;
+  HANDLE hStdOutput = 0;
+  HANDLE hStdError = 0;
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   int tty;
   int ostdin, ostdout, ostderr;
+#endif /* !__MINGW32__ */
   const char *inferior_io_terminal = get_inferior_io_terminal ();
 
   if (!exec_file)
@@ -1886,7 +2005,12 @@
   if (!useshell)
     {
       flags = DEBUG_ONLY_THIS_PROCESS;
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (exec_file, real_path);
+#else
+      strcpy (real_path, exec_file);
+#endif
+
       toexec = real_path;
     }
   else
@@ -1895,7 +2019,11 @@
       sh = getenv ("SHELL");
       if (!sh)
 	sh = "/bin/sh";
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (sh, shell);
+#else
+      strcpy (shell, sh);
+#endif
       newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
 			   + strlen (allargs) + 2);
       sprintf (newallargs, " -c 'exec %s %s'", exec_file, allargs);
@@ -1946,10 +2074,12 @@
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], in_env[i], len) == 0)
 	      {
-		if (cygwin_posix_path_list_p (in_env[i] + len))
+#ifdef __CYGWIN__
+		if (cygwin_posix_path_list_p (env[i] + len))
 		  envlen += len
-		    + cygwin_posix_to_win32_path_list_buf_size (in_env[i] + len);
+		    + cygwin_posix_to_win32_path_list_buf_size (env[i] + len);
 		else
+#endif
 		  envlen += strlen (in_env[i]) + 1;
 		break;
 	      }
@@ -1976,12 +2106,14 @@
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], env[i], len) == 0)
 	      {
+#ifdef __CYGWIN__
 		if (cygwin_posix_path_list_p (env[i] + len))
 		  {
 		    memcpy (temp, env[i], len);
 		    cygwin_posix_to_win32_path_list (env[i] + len, temp + len);
 		  }
 		else
+#endif
 		  strcpy (temp, env[i]);
 		break;
 	      }
@@ -1996,6 +2128,20 @@
     *temp = 0;
   }
 
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      hStdInput = GetStdHandle( STD_INPUT_HANDLE);
+      hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE);
+      hStdError = GetStdHandle( STD_ERROR_HANDLE);
+
+      SetStdHandle( STD_INPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_OUTPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_ERROR_HANDLE, INVALID_HANDLE_VALUE);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   if (!inferior_io_terminal)
     tty = ostdin = ostdout = ostderr = -1;
   else
@@ -2016,6 +2162,7 @@
 	  dup2 (tty, 2);
 	}
     }
+#endif /* !__MINGW32__ */
 
   win32_init_thread_list ();
   ret = CreateProcess (0,
@@ -2028,6 +2175,16 @@
 		       NULL,	/* current directory */
 		       &si,
 		       &pi);
+#if defined (__MINGW32__)
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      SetStdHandle( STD_INPUT_HANDLE, hStdInput);
+      SetStdHandle( STD_OUTPUT_HANDLE, hStdOutput);
+      SetStdHandle( STD_ERROR_HANDLE, hStdError);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+#else /* !__MINGW32__ */
   if (tty >= 0)
     {
       close (tty);
@@ -2038,6 +2195,7 @@
       close (ostdout);
       close (ostderr);
     }
+#endif /* !__MINGW32__ */
 
   if (!ret)
     error (_("Error creating process %s, (error %d)."),
diff -Nbaur gdb-6.6/include/opcode/ppc.h gdb-6.6-ppc/include/opcode/ppc.h
--- gdb-6.6/include/opcode/ppc.h	Tue Oct 24 02:27:28 2006
+++ gdb-6.6-ppc/include/opcode/ppc.h	Sat Jun 16 04:15:10 2007
@@ -146,6 +146,9 @@
 /* Opcode is only supported by PowerPC Cell family.  */
 #define PPC_OPCODE_CELL		 0x8000000
 
+/* Opcode is only supported by the PowerPC Gekko processor.  */
+#define PPC_OPCODE_GEKKO    (040000000)
+
 /* A macro to extract the major opcode from an instruction.  */
 #define PPC_OP(i) (((i) >> 26) & 0x3f)
 
@@ -293,6 +296,10 @@
 /* This operand is for the DQ field in a DQ form instruction.  */
 #define PPC_OPERAND_DQ (0100000)
 
+/* This operand names a quantization register.  The disassembler
+   prints these with a leading 'gqr'.  */
+#define PPC_OPERAND_GQR (040000)
+
 /* The POWER and PowerPC assemblers use a few macros.  We keep them
    with the operands table for simplicity.  The macro table is an
    array of struct powerpc_macro.  */
diff -Nbaur gdb-6.6/opcodes/ppc-dis.c gdb-6.6-ppc/opcodes/ppc-dis.c
--- gdb-6.6/opcodes/ppc-dis.c	Tue Oct 24 02:27:28 2006
+++ gdb-6.6-ppc/opcodes/ppc-dis.c	Sat Jun 16 04:15:10 2007
@@ -62,6 +62,13 @@
 	   && strstr (info->disassembler_options, "e300") != NULL)
     dialect |= PPC_OPCODE_E300 | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON;
   else
+	if (info->disassembler_options
+	&& (strstr (info->disassembler_options, "gekko") == 0))
+	  {
+    dialect |= PPC_OPCODE_GEKKO;
+    dialect &= ~PPC_OPCODE_ALTIVEC;
+	  }
+  else
     dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
 		| PPC_OPCODE_COMMON | PPC_OPCODE_ALTIVEC);
 
@@ -249,6 +256,8 @@
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
 	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
+	  else if ((operand->flags & PPC_OPERAND_GQR) != 0)
+	    (*info->fprintf_func) (info->stream, "gqr%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_CR) == 0
 		   || (dialect & PPC_OPCODE_PPC) == 0)
 	    (*info->fprintf_func) (info->stream, "%ld", value);
@@ -317,4 +326,5 @@
   fprintf (stream, "  power6                   Disassemble the Power6 instructions\n");
   fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
   fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
+  fprintf (stream, "  gekko                    Disassemble the Gamecube Gekko instructions\n");
 }
diff -Nbaur gdb-6.6/opcodes/ppc-opc.c gdb-6.6-ppc/opcodes/ppc-opc.c
--- gdb-6.6/opcodes/ppc-opc.c	Mon Nov  6 00:46:07 2006
+++ gdb-6.6-ppc/opcodes/ppc-opc.c	Sat Jun 16 04:40:02 2007
@@ -95,6 +95,13 @@
 static unsigned long insert_ev8 (unsigned long, long, int, const char **);
 static long extract_ev8 (unsigned long, int, int *);
 
+static unsigned long insert_psq_gd (unsigned long, long, int, const char **);
+static long extract_psq_gd (unsigned long, int, int *);
+static unsigned long insert_psq_gx (unsigned long, long, int, const char **);
+static long extract_psq_gx (unsigned long, int, int *);
+
+
+
 /* The operands table.
 
    The fields are bits, shift, insert, extract, flags.
@@ -598,6 +605,27 @@
   /* The EH field in larx instruction.  */
 #define EH XRT_L + 1
   { 1, 0, NULL, NULL, PPC_OPERAND_OPTIONAL },
+
+  /* I Field in psq_ instructions */
+#define PSQ_DD MTMSRD_L + 1
+  { 12, 0, 0, 0, PPC_OPERAND_PARENS|PPC_OPERAND_SIGNED },
+
+  /* W Field in psq_ instructions */
+#define PSQ_WD PSQ_DD + 1
+  { 1, 15, 0, 0, 0 },
+
+  /* d Field in psq_ instructions */
+#define PSQ_GD PSQ_WD + 1
+  { 10, 12, insert_psq_gd, extract_psq_gd, PPC_OPERAND_GQR },
+
+  /* I Field in psq_ instructions A*/
+#define PSQ_WX PSQ_GD + 1
+  { 1, 10, 0, 0, 0 },
+
+  /* W Field in psq_ instructions */
+#define PSQ_GX PSQ_WX + 1
+  { 10, 7, insert_psq_gx, extract_psq_gx, PPC_OPERAND_GQR },
+
 };
 
 /* The functions used to insert and extract complicated operands.  */
@@ -1513,6 +1541,50 @@
   return ret;
 }
 
+static unsigned long
+insert_psq_gd (unsigned long insn,
+	       long value,
+	       int dialect ATTRIBUTE_UNUSED,
+	       const char **errmsg)
+{
+  if (value >= 912 && value <= 919)
+    value -= 912;
+  if (value < 0 || value > 7)
+    *errmsg = _("invalid quantization register");
+  return insn | ((value & 7) << 12);
+}
+
+static long
+extract_psq_gd (unsigned long insn,
+		int dialect ATTRIBUTE_UNUSED,
+		int *invalid ATTRIBUTE_UNUSED)
+{
+  return ((insn & 0x7000) >> 12);
+}
+
+static unsigned long
+insert_psq_gx (unsigned long insn,
+	       long value,
+	       int dialect ATTRIBUTE_UNUSED,
+	       const char **errmsg)
+{
+  if (value >= 912 && value <= 919)
+    value -= 912;
+  if (value < 0 || value > 7)
+    *errmsg = _("invalid quantization register");
+  return insn | ((value & 7) << 7);
+}
+
+static long
+extract_psq_gx (unsigned long insn,
+		int dialect ATTRIBUTE_UNUSED,
+		int *invalid ATTRIBUTE_UNUSED)
+{
+  return ((insn & 0x380) >> 7);
+}
+
+
+
 /* Macros used to form opcodes.  */
 
 /* The main opcode.  */
@@ -1814,6 +1886,11 @@
 #define XUC(op, xop)  (OP (op) | (((unsigned long)(xop)) & 0x1f))
 #define XUC_MASK      XUC(0x3f, 0x1f)
 
+/* A PSQ style load/store indexed */
+#define PSQX(op, xop) (OP (op) | (((unsigned long)(xop)) & 0x7f))
+#define PSQX_MASK     PSQX(0x3f,0x7f)
+ 
+
 /* The BO encodings used in extended conditional branch mnemonics.  */
 #define BODNZF	(0x0)
 #define BODNZFP	(0x1)
@@ -1908,6 +1985,7 @@
 #define PPCCHLK	PPC_OPCODE_CACHELCK
 #define PPCCHLK64	PPC_OPCODE_CACHELCK | PPC_OPCODE_BOOKE64
 #define PPCRFMCI	PPC_OPCODE_RFMCI
+#define PPCGEKKO	PPC_OPCODE_GEKKO
 
 /* The opcode table.
 
@@ -4928,6 +5006,99 @@
 { "diexq",   XRC(63,866,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "diexq.",  XRC(63,866,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 
+/* GEKKO specific stuff */
+{ "dcbz_l",   X(4,1014), XRT_MASK, PPCGEKKO, { RA, RB }},
+
+{ "ps_abs",   XRC(4,264,0), XRA_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_abs.",   XRC(4,264,1), XRA_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_add",   A(4,21,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_add.",  A(4,21,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_cmpo0", X(4,32), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+{ "ps_cmpo1", X(4,96), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+
+{ "ps_cmpu0", X(4,0), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+{ "ps_cmpu1", X(4,64), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+
+{ "ps_div",   A(4,18,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_div.",  A(4,18,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_madd",   A(4,29,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madd.",  A(4,29,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_madds0",   A(4,14,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madds0.",  A(4,14,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_madds1",   A(4,15,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madds1.",  A(4,15,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_merge00",   XRC(4,528,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge00.",  XRC(4,528,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge01",   XRC(4,560,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge01.",  XRC(4,560,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge10",   XRC(4,592,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge10.",  XRC(4,592,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge11",   XRC(4,624,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge11.",  XRC(4,624,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_mr",   XRC(4,72,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_mr.",  XRC(4,72,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_msub",   A(4,28,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_msub.",  A(4,28,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_mul",   A(4,25,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_mul.",  A(4,25,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_muls0",   A(4,12,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_muls0.",  A(4,12,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_muls1",   A(4,13,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_muls1.",  A(4,13,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_nabs",   XRC(4,136,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_nabs.",  XRC(4,136,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_neg",   XRC(4,40,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_neg.",  XRC(4,40,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_nmadd",   A(4,31,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_nmadd.",  A(4,31,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_nmsub",   A(4,30,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_nmsub.",  A(4,30,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_res",   A(4,13,0), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_res.",  A(4,13,1), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_rsqrte",   A(4,26,0), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_rsqrte.",  A(4,26,1), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_sel",   A(4,23,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sel.",  A(4,23,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_sub",   A(4,20,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_sub.",  A(4,20,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_sum0",   A(4,10,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sum0.",  A(4,10,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_sum1",   A(4,11,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sum1.",  A(4,11,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "psq_l",     OP(56),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_lu",    OP(57),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_lux",   PSQX(4,76),PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_lx",    PSQX(4,12),PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_st",    OP(60),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_stu",   OP(61),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_stux",  PSQX(4,78), PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_stx",   PSQX(4,14),  PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+
 };
 
 const int powerpc_num_opcodes =
